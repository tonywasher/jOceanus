/* General settings  */
buildscript {
    repositories {
        mavenLocal()
        maven {
            url = uri('https://repo.maven.apache.org/maven2/')
        }
    }
}

/* project-wise setup */
allprojects {
    /* Standard plugins */
    apply plugin: 'java'
    apply plugin: 'maven-publish'
    apply plugin: 'jacoco'
    apply plugin: 'signing'

    /* general identity */
    group = 'net.sourceforge.joceanus'
    version = '1.6.3-SNAPSHOT'

    /* Maven repositories */
    repositories {
        mavenLocal()
        mavenCentral()
    }

    /* Standard properties */
    project.ext { 
        /* Dependency versions */
        bouncyCastleVersion = "1.83"
        jUnitVersion = "6.0.1"
        jsonVersion = "20251224"
        mySQLVersion = "9.5.0"
        MariaDBVersion = "3.5.7"
        postGreSQLVersion = "42.7.8"
        mssqlVersion = "13.2.1.jre11"
        h2Version = "2.4.240"
        apachePOIVersion = "5.5.1"
        jsoupVersion = "1.22.1"
        jFreeChartVersion = "1.5.6"
        javaParserVersion = "3.27.1"

        /* javaFX versions */
        javaFXVersion = "17"
        javaFXPluginVersion = "0.1.0"

        /* Annotation versions */
        jetBrainsAnnotationsVersion = "26.0.2"

        /* jacoco config */
        jacocoVersion = "0.8.14"

        /* Distribution details */
        appDir = "$rootDir/dist"
        appBinDir = "bin/"
        appLibDir = "lib/"
    }
}

/* Store calculated properties in the root project */
ext { 
    /* git details */
    gitRepo = getGitRepo()
    gitBranch = getGitBranch()
    gitRev = getGitRev()

    /* Distribution mappings */
    distributionMap = [:];

    /* Base manifest details */
    baseManifest = [
            "Implementation-Version": project.version,
            "Created-By"     : "Gradle ${gradle.gradleVersion}",
            "Git-Repo"       : gitRepo,
            "Git-Branch"     : gitBranch,
            "Git-Rev"        : "sha1-" + gitRev,
            "Built-By"       : System.properties['user.name'],
            "Build-Timestamp": new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").format(new Date()),
            "Build-Jdk"      : "${System.properties['java.version']} (${System.properties['java.vendor']} ${System.properties['java.vm.version']})",
            "Build-OS"       : "${System.properties['os.name']} ${System.properties['os.arch']} ${System.properties['os.version']}"
    ]    
}

/* sub-project setup */
subprojects {
    tasks.withType(JavaCompile) {
        options.deprecation = true
        options.encoding = 'UTF-8'
        options.release = 17
    }
    tasks.withType(Javadoc).all {
        enabled = false
    }

    /* Build source and javaDoc jars */
    java {
        //withJavadocJar()
        withSourcesJar()
    }

    /* Support jUnit 5 */
    testing {
        suites {
            test {
                useJUnitJupiter()

                targets {
                    all {
                        testTask.configure {
                            maxHeapSize = '4g'
                        }
                    }
                }
            }
        }
    }

    /* Add annotations */
    dependencies {
	    compileOnly "org.jetbrains:annotations:$jetBrainsAnnotationsVersion"
    } 

    /* Java options */
    compileJava {
        options.compilerArgs += ["-Xlint:unchecked"]
    }

    /* Maven publishing */
    publishing {
        publications {
            maven(MavenPublication) {
                from(components.java)
            }
        }
    }

    /* Jacoco */
    test {
        finalizedBy jacocoTestReport
    }
    jacocoTestReport {
        dependsOn test
    }
    jacoco {
        toolVersion = "$jacocoVersion"
    }

    /* Project properties */
    project.ext { 
        /* Manifest Attributes */
        manifestAttrs = rootProject.ext.baseManifest.clone()

        /* manifest control */
        mainClass = null
        moduleName = null
        preLoaderClass = null
        splashScreen = null
    } 
}

/* Distribution task */
task distribute {
    doLast {
        rootProject.ext.distributionMap.each{ k, v -> 
            if (shouldCopy(k, "$appDir/$v")) {
                copy {
                    into("$appDir/" + stripFileName("$v"))
                    from k
                }
            }	
        }
        buildJRE()
    }        
}
distribute.dependsOn ":moneywise-swing:jar", ":moneywise-javafx:jar", ":themis-javafx:jar", ":prometheus-sheet-odf:jar", ":prometheus-sheet-hssf:jar"
assemble.dependsOn distribute

/* Make sure distribution directory is cleared on clean */
clean.doFirst {
    delete = "${appDir}/"
}

/* Disable jar building for root project */
jar.enabled = false

/* Obtain gitBranch details */
String getGitBranch() {
    def projectDirFile = new File("$projectDir")

    def srCmd = 'git symbolic-ref --short HEAD'
    def srProc = srCmd.execute(null, projectDirFile)
    srProc.waitForOrKill(10 * 1000)
    if (srProc.exitValue() == 0) {
        return srProc.text.trim()
    }
    return "GitBranch not found"
}

/* Obtain gitRevision details */
String getGitRev() {
    def projectDirFile = new File("$projectDir")

    def rpCmd = 'git rev-parse --short=12 HEAD'
    def rpProc = rpCmd.execute(null, projectDirFile)
    rpProc.waitForOrKill(10 * 1000)
    if (rpProc.exitValue() == 0) {
        return rpProc.text.trim()
    } 
    return "gitRevision not found"
}

/* Obtain gitRepository details */
String getGitRepo() {
    def projectDirFile = new File("$projectDir")

    def rmCmd = 'git remote get-url origin'
    def rmProc = rmCmd.execute(null, projectDirFile)
    rmProc.waitForOrKill(10 * 1000)
    if (rmProc.exitValue() == 0) {
        return rmProc.text.trim()
    } 
    return "gitRepository not found"
}

/* Obtain Maven repository style path for artifact */
String standardizePath(String pPath) {
    /* Convert to standard style and access root directory */
    String myPath = pPath.replaceAll("\\\\", "/")
    String projDir = "$rootDir"

    /* If the artifact has been built within the project */
    if (pPath.startsWith(projDir)) { 
       /* Obtain directory version of group */      
       String myGroup = group.replaceAll("\\.", "/") 

       /* Strip of the full prefix to the artifact */
       myPath = myPath.substring(projDir.length())
       String bldDir = "/build/libs/"
       int myIndex = myPath.indexOf(bldDir)
       String myJar = myPath.substring(myIndex + bldDir.length()) 

       /* Split out artifact name */
       myIndex = myJar.indexOf("-" + version)
       String myArtifact = myJar.substring(0, myIndex)

       /* return required path */
       return myGroup + "/" + myArtifact + "/" + version + "/" + myJar
    }

    /* If the artifact is in the gradle cache */
    String gradleCacheDir = "/.gradle/caches/modules-2/files-2.1/"
    int myIndex = myPath.indexOf(gradleCacheDir)
    if (myIndex != -1) {
        /* Split off prefix */
        myPath = myPath.substring(myIndex + gradleCacheDir.length()) 

        /* Split off group */
        myIndex = myPath.indexOf("/")
        String myGroup = myPath.substring(0, myIndex).replaceAll("\\.", "/")
        myPath = myPath.substring(myIndex+1)

        /* Split off artifact */
        myIndex = myPath.indexOf("/")
        String myArtifact = myPath.substring(0, myIndex)
        myPath = myPath.substring(myIndex+1)

        /* Split off version */
        myIndex = myPath.indexOf("/")
        String myVersion = myPath.substring(0, myIndex)
   
        /* return required path */
        return myGroup + "/" + myArtifact + "/" + myVersion + "/" + myArtifact + "-" + myVersion + ".jar"
    } 

    /* Must be from local maven repository */
    String mavenDir = "/.m2/repository/"
    myIndex = myPath.indexOf(mavenDir)
    return myPath.substring(myIndex + mavenDir.length()) 
}

/* Strip the fileName from the path */
String stripFileName(String pPath) {
    int myIndex = pPath.lastIndexOf("/")
    return pPath.substring(0, myIndex) 
}

/* Register project */
void registerProject(Project pProject) {
    /* Add implementation title and classPath */
    pProject.ext.manifestAttrs["Implementation-Title"] = pProject.description
    pProject.ext.manifestAttrs["Class-Path"] = pProject.configurations.runtimeClasspath.collect { 
                                       "../${appLibDir}" + standardizePath(it.absolutePath) }.join(' ')

    /* Add mainClass and moduleName if defined */
    if (pProject.ext.mainClass != null) {
        pProject.ext.manifestAttrs["Main-Class"] = pProject.ext.mainClass
        buildDistribution(pProject)
    }          
    if (pProject.ext.moduleName != null) {
        pProject.ext.manifestAttrs["Automatic-Module-Name"] = pProject.ext.moduleName
    }          

    /* Add preLoader/splashScreen if defined */
    if (pProject.ext.preLoaderClass != null) {
        pProject.ext.manifestAttrs["JavaFX-Preloader-Class"] = pProject.ext.preLoaderClass
    }          
    if (pProject.ext.splashScreen != null) {
        pProject.ext.manifestAttrs["SplashScreen-Image"] = pProject.ext.splashScreen
    }          
}

/* Build list of distributable modules */
void buildDistribution(Project pProject) {
    def jarName = pProject.name + "-" + version + ".jar"
    def fullJarName = "${pProject.projectDir}/build/libs/$jarName"
    rootProject.ext.distributionMap[fullJarName] = "${appBinDir}" + jarName
    pProject.configurations.runtimeClasspath.each { d ->
            def oldName = d.getAbsolutePath()
            def newName = "${appLibDir}" + standardizePath(d.getAbsolutePath())
            rootProject.ext.distributionMap[oldName] = newName
    }
}

/* Check to see whether we should copy a file */
boolean shouldCopy(String pSource, String pTarget) {
    /* Can't copy if source file does not exist */
    File mySrc = new File(pSource)
    if (!mySrc.exists()) {
       return false;
    }

    /* Always copy if target file does not exist */
    File myTgt = new File(pTarget)
    if (!myTgt.exists()) {
       return true;
    }

    /* Only copy if source file is newer than target */
    return mySrc.lastModified() > myTgt.lastModified();
}

/* Build the JRE */
void buildJRE() {
    def projectDirFile = new File("$projectDir")
    def MODS = 'java.base,java.xml,java.net.http,java.prefs,java.sql,java.desktop,java.logging,java.security.jgss,jdk.net,jdk.unsupported,java.datatransfer,java.naming,java.management,jdk.net,jdk.crypto.ec,jdk.jsobject,jdk.xml.dom'
    def bldCmd = 'jlink --no-header-files --no-man-pages --vendor-version jOceanus --output ' + "$appDir" + '/java --add-modules ' + MODS
    def bldProc = bldCmd.execute(null, projectDirFile)
    bldProc.waitForOrKill(10 * 1000)
}

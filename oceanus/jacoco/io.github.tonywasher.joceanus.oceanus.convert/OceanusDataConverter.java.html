<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OceanusDataConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Oceanus Java Core Utilities</a> &gt; <a href="index.source.html" class="el_package">io.github.tonywasher.joceanus.oceanus.convert</a> &gt; <span class="el_source">OceanusDataConverter.java</span></div><h1>OceanusDataConverter.java</h1><pre class="source lang-java linenums">/*
 * Oceanus: Java Utilities
 * Copyright 2012-2026. Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.github.tonywasher.joceanus.oceanus.convert;

import io.github.tonywasher.joceanus.oceanus.base.OceanusException;
import io.github.tonywasher.joceanus.oceanus.exc.OceanusDataException;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

/**
 * Data Conversion utility functions.
 */
public final class OceanusDataConverter {
    /**
     * Invalid hexadecimal length string.
     */
    private static final String ERROR_HEXLEN = &quot;Invalid HexString Length: &quot;;

    /**
     * Invalid hexadecimal error string.
     */
    private static final String ERROR_HEXDIGIT = &quot;Non Hexadecimal Value: &quot;;

    /**
     * Base64 Encoding array.
     */
<span class="fc" id="L47">    private static final char[] BASE64_ENCODE = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;.toCharArray();</span>

    /**
     * Base64 Decoding array.
     */
<span class="fc" id="L52">    private static final int[] BASE64_DECODE = new int[BASE64_ENCODE.length &lt;&lt; 1];</span>

    static {
<span class="fc bfc" id="L55" title="All 2 branches covered.">        for (int i = 0; i &lt; BASE64_ENCODE.length; i++) {</span>
<span class="fc" id="L56">            BASE64_DECODE[BASE64_ENCODE[i]] = i;</span>
        }
<span class="fc" id="L58">    }</span>

    /**
     * Base64 triplet size.
     */
    private static final int BASE64_TRIPLE = 3;

    /**
     * Base64 padding character.
     */
    private static final char BASE64_PAD = '=';

    /**
     * Base64 shift 1.
     */
    private static final int BASE64_SHIFT1 = 2;

    /**
     * Base64 shift 2.
     */
    private static final int BASE64_SHIFT2 = 4;

    /**
     * Base64 shift 3.
     */
    private static final int BASE64_SHIFT3 = 6;

    /**
     * Hexadecimal Radix.
     */
    public static final int HEX_RADIX = 16;

    /**
     * Byte shift.
     */
    public static final int BYTE_SHIFT = Byte.SIZE;

    /**
     * Byte mask.
     */
    public static final int BYTE_MASK = 0xFF;

    /**
     * Base64 mask.
     */
    public static final int BASE64_MASK = 0x3F;

    /**
     * Color mask.
     */
    public static final int COLOR_MASK = 0x00FFFFFF;

    /**
     * Nybble shift.
     */
    public static final int NYBBLE_SHIFT = Byte.SIZE &gt;&gt; 1;

    /**
     * Nybble mask.
     */
    public static final int NYBBLE_MASK = 0xF;

    /**
     * RGB colour length.
     */
    public static final int RGB_LENGTH = 6;

    /**
     * Private constructor to avoid instantiation.
     */
    private OceanusDataConverter() {
    }

    /**
     * format a byte array as a hexadecimal string.
     *
     * @param pBytes the byte array
     * @return the string
     */
    public static String bytesToHexString(final byte[] pBytes) {
        /* Allocate the string builder */
<span class="nc" id="L139">        final StringBuilder myValue = new StringBuilder(2 * pBytes.length);</span>

        /* For each byte in the value */
<span class="nc bnc" id="L142" title="All 2 branches missed.">        for (final byte b : pBytes) {</span>
            /* Access the byte as an unsigned integer */
<span class="nc" id="L144">            int myInt = b;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">            if (myInt &lt; 0) {</span>
<span class="nc" id="L146">                myInt += BYTE_MASK + 1;</span>
            }

            /* Access the high nybble */
<span class="nc" id="L150">            int myDigit = myInt &gt;&gt;&gt; NYBBLE_SHIFT;</span>
<span class="nc" id="L151">            char myChar = Character.forDigit(myDigit, HEX_RADIX);</span>

            /* Add it to the value string */
<span class="nc" id="L154">            myValue.append(myChar);</span>

            /* Access the low digit */
<span class="nc" id="L157">            myDigit = myInt</span>
                    &amp; NYBBLE_MASK;
<span class="nc" id="L159">            myChar = Character.forDigit(myDigit, HEX_RADIX);</span>

            /* Add it to the value string */
<span class="nc" id="L162">            myValue.append(myChar);</span>
        }

        /* Return the string */
<span class="nc" id="L166">        return myValue.toString();</span>
    }

    /**
     * format a long as a hexadecimal string.
     *
     * @param pValue the long value
     * @return the string
     */
    public static String longToHexString(final long pValue) {
        /* Access the long value */
<span class="nc" id="L177">        long myLong = pValue;</span>

        /* Allocate the string builder */
<span class="nc" id="L180">        final StringBuilder myValue = new StringBuilder();</span>

        /* handle negative values */
<span class="nc bnc" id="L183" title="All 2 branches missed.">        final boolean isNegative = myLong &lt; 0;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (isNegative) {</span>
<span class="nc" id="L185">            myLong = -myLong;</span>
        }

        /* Special case for zero */
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (myLong == 0) {</span>
<span class="nc" id="L190">            myValue.append(&quot;00&quot;);</span>

            /* else need to loop through the digits */
        } else {
            /* While we have digits to format */
<span class="nc bnc" id="L195" title="All 2 branches missed.">            while (myLong &gt; 0) {</span>
                /* Access the digit and move to next one */
<span class="nc" id="L197">                final int myDigit = (int) (myLong &amp; NYBBLE_MASK);</span>
<span class="nc" id="L198">                final char myChar = Character.forDigit(myDigit, HEX_RADIX);</span>
<span class="nc" id="L199">                myValue.insert(0, myChar);</span>
<span class="nc" id="L200">                myLong &gt;&gt;&gt;= NYBBLE_SHIFT;</span>
<span class="nc" id="L201">            }</span>

            /* If we are odd length prefix a zero */
<span class="nc bnc" id="L204" title="All 2 branches missed.">            if ((myValue.length() &amp; 1) != 0) {</span>
<span class="nc" id="L205">                myValue.insert(0, '0');</span>
            }

            /* Reinstate negative sign */
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (isNegative) {</span>
<span class="nc" id="L210">                myValue.insert(0, '-');</span>
            }
        }

        /* Return the string */
<span class="nc" id="L215">        return myValue.toString();</span>
    }

    /**
     * parse a byte array from a hexadecimal string.
     *
     * @param pHexString the hex string
     * @return the bytes
     * @throws OceanusException on error
     */
    public static byte[] hexStringToBytes(final String pHexString) throws OceanusException {
        /* Access the length of the hex string */
<span class="nc" id="L227">        final int myLen = pHexString.length();</span>

        /* Check that it has an even length */
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (myLen % 2 != 0) {</span>
<span class="nc" id="L231">            throw new OceanusDataException(ERROR_HEXLEN</span>
                    + pHexString);
        }

        /* Allocate the new bytes array */
<span class="nc" id="L236">        final byte[] myByteValue = new byte[myLen / 2];</span>

        /* Loop through the string */
<span class="nc bnc" id="L239" title="All 2 branches missed.">        for (int i = 0; i &lt; myLen; i += 2) {</span>
            /* Access the top level byte */
<span class="nc" id="L241">            char myChar = pHexString.charAt(i);</span>
<span class="nc" id="L242">            int myDigit = Character.digit(myChar, HEX_RADIX);</span>

            /* Check that the char is a valid hex digit */
<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (myDigit &lt; 0) {</span>
<span class="nc" id="L246">                throw new OceanusDataException(ERROR_HEXDIGIT</span>
                        + pHexString);
            }

            /* Initialise result */
<span class="nc" id="L251">            int myInt = myDigit &lt;&lt; NYBBLE_SHIFT;</span>

            /* Access the second byte */
<span class="nc" id="L254">            myChar = pHexString.charAt(i + 1);</span>
<span class="nc" id="L255">            myDigit = Character.digit(myChar, HEX_RADIX);</span>

            /* Check that the char is a valid hex digit */
<span class="nc bnc" id="L258" title="All 2 branches missed.">            if (myDigit &lt; 0) {</span>
<span class="nc" id="L259">                throw new OceanusDataException(ERROR_HEXDIGIT</span>
                        + pHexString);
            }

            /* Add into result */
<span class="nc" id="L264">            myInt += myDigit;</span>

            /* Convert to byte and store */
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (myInt &gt; Byte.MAX_VALUE) {</span>
<span class="nc" id="L268">                myInt -= BYTE_MASK + 1;</span>
            }
<span class="nc" id="L270">            myByteValue[i / 2] = (byte) myInt;</span>
        }

        /* Return the bytes */
<span class="nc" id="L274">        return myByteValue;</span>
    }

    /**
     * parse a long from a hexadecimal string.
     *
     * @param pHexString the hex string
     * @return the bytes
     * @throws OceanusException on error
     */
    public static long hexStringToLong(final String pHexString) throws OceanusException {
        /* Access the length of the hex string */
<span class="nc" id="L286">        String myHexString = pHexString;</span>
<span class="nc" id="L287">        int myLen = myHexString.length();</span>

        /* handle negative values */
<span class="nc bnc" id="L290" title="All 2 branches missed.">        final boolean isNegative = myLen &gt; 0</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                &amp;&amp; myHexString.charAt(0) == '-';</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (isNegative) {</span>
<span class="nc" id="L293">            myHexString = myHexString.substring(1);</span>
<span class="nc" id="L294">            myLen--;</span>
        }

        /* Check that it has an even length */
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (myLen % 2 != 0) {</span>
<span class="nc" id="L299">            throw new OceanusDataException(ERROR_HEXLEN</span>
                    + pHexString);
        }

        /* Loop through the string */
<span class="nc" id="L304">        long myValue = 0;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        for (int i = 0; i &lt; myLen; i++) {</span>
            /* Access the next character */
<span class="nc" id="L307">            final char myChar = myHexString.charAt(i);</span>
<span class="nc" id="L308">            final int myDigit = Character.digit(myChar, HEX_RADIX);</span>

            /* Check that the char is a valid hex digit */
<span class="nc bnc" id="L311" title="All 2 branches missed.">            if (myDigit &lt; 0) {</span>
<span class="nc" id="L312">                throw new OceanusDataException(ERROR_HEXDIGIT</span>
                        + pHexString);
            }

            /* Add into the value */
<span class="nc" id="L317">            myValue &lt;&lt;= NYBBLE_SHIFT;</span>
<span class="nc" id="L318">            myValue += myDigit;</span>
        }

        /* Reinstate negative values */
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (isNegative) {</span>
<span class="nc" id="L323">            myValue = -myValue;</span>
        }

        /* Return the value */
<span class="nc" id="L327">        return myValue;</span>
    }

    /**
     * Convert character array to byte array.
     *
     * @param pChars the character array
     * @return the byte array
     * @throws OceanusException on error
     */
    public static byte[] charsToByteArray(final char[] pChars) throws OceanusException {
        /* protect against exceptions */
        try {
            /* Transform the character array to a byte array */
<span class="nc" id="L341">            final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L342">            final OutputStreamWriter out = new OutputStreamWriter(baos, StandardCharsets.UTF_8);</span>
<span class="nc" id="L343">            out.write(pChars, 0, pChars.length);</span>
<span class="nc" id="L344">            out.flush();</span>
<span class="nc" id="L345">            return baos.toByteArray();</span>
<span class="nc" id="L346">        } catch (IOException e) {</span>
<span class="nc" id="L347">            throw new OceanusDataException(e.getMessage(), e);</span>
        }
    }

    /**
     * Convert byte array to character array.
     *
     * @param pBytes the byte array
     * @return the character array
     * @throws OceanusException on error
     */
    public static char[] bytesToCharArray(final byte[] pBytes) throws OceanusException {
        /* protect against exceptions */
        try {
            /* Allocate the character array allowing for one character per byte */
<span class="nc" id="L362">            char[] myArray = new char[pBytes.length];</span>

            /* Transform the byte array to a character array */
<span class="nc" id="L365">            final ByteArrayInputStream bais = new ByteArrayInputStream(pBytes);</span>
<span class="nc" id="L366">            final InputStreamReader in = new InputStreamReader(bais, StandardCharsets.UTF_8);</span>
<span class="nc" id="L367">            final int myLen = in.read(myArray);</span>

            /* Cut down the array to the actual length */
<span class="nc" id="L370">            myArray = Arrays.copyOf(myArray, myLen);</span>

            /* Return the array */
<span class="nc" id="L373">            return myArray;</span>
<span class="nc" id="L374">        } catch (IOException e) {</span>
<span class="nc" id="L375">            throw new OceanusDataException(e.getMessage(), e);</span>
        }
    }

    /**
     * parse a long from a byte array.
     *
     * @param pBytes the eight byte array holding the long
     * @return the long value
     */
    public static long byteArrayToLong(final byte[] pBytes) {
        /* Loop through the bytes */
<span class="fc" id="L387">        long myValue = 0;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">        for (int i = 0; i &lt; Long.BYTES; i++) {</span>
            /* Access the next byte as an unsigned integer */
<span class="fc" id="L390">            int myByte = pBytes[i];</span>
<span class="fc" id="L391">            myByte &amp;= BYTE_MASK;</span>

            /* Add in to value */
<span class="fc" id="L394">            myValue &lt;&lt;= BYTE_SHIFT;</span>
<span class="fc" id="L395">            myValue += myByte;</span>
        }

        /* Return the value */
<span class="fc" id="L399">        return myValue;</span>
    }

    /**
     * build a byte array from a long.
     *
     * @param pValue the long value to convert
     * @return the byte array
     */
    public static byte[] longToByteArray(final long pValue) {
        /* Loop through the bytes */
<span class="fc" id="L410">        long myValue = pValue;</span>
<span class="fc" id="L411">        final byte[] myBytes = new byte[Long.BYTES];</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        for (int i = Long.BYTES; i &gt; 0; i--) {</span>
            /* Store the next byte */
<span class="fc" id="L414">            final byte myByte = (byte) (myValue &amp; BYTE_MASK);</span>
<span class="fc" id="L415">            myBytes[i - 1] = myByte;</span>

            /* Adjust value */
<span class="fc" id="L418">            myValue &gt;&gt;= BYTE_SHIFT;</span>
        }

        /* Return the value */
<span class="fc" id="L422">        return myBytes;</span>
    }

    /**
     * parse an integer from a byte array.
     *
     * @param pBytes the four byte array holding the integer
     * @return the integer value
     */
    public static int byteArrayToInteger(final byte[] pBytes) {
        /* Loop through the bytes */
<span class="nc" id="L433">        int myValue = 0;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        for (int i = 0; i &lt; Integer.BYTES; i++) {</span>
            /* Access the next byte as an unsigned integer */
<span class="nc" id="L436">            int myByte = pBytes[i];</span>
<span class="nc" id="L437">            myByte &amp;= BYTE_MASK;</span>

            /* Add in to value */
<span class="nc" id="L440">            myValue &lt;&lt;= BYTE_SHIFT;</span>
<span class="nc" id="L441">            myValue += myByte;</span>
        }

        /* Return the value */
<span class="nc" id="L445">        return myValue;</span>
    }

    /**
     * build a byte array from an integer.
     *
     * @param pValue the integer value to convert
     * @return the byte array
     */
    public static byte[] integerToByteArray(final int pValue) {
        /* Loop through the bytes */
<span class="nc" id="L456">        final byte[] myBytes = new byte[Integer.BYTES];</span>
<span class="nc" id="L457">        int myValue = pValue;</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        for (int i = Integer.BYTES; i &gt; 0; i--) {</span>
            /* Store the next byte */
<span class="nc" id="L460">            final byte myByte = (byte) (myValue &amp; BYTE_MASK);</span>
<span class="nc" id="L461">            myBytes[i - 1] = myByte;</span>

            /* Adjust value */
<span class="nc" id="L464">            myValue &gt;&gt;= BYTE_SHIFT;</span>
        }

        /* Return the value */
<span class="nc" id="L468">        return myBytes;</span>
    }

    /**
     * parse a short from a byte array.
     *
     * @param pBytes the four byte array holding the integer
     * @return the short value
     */
    public static short byteArrayToShort(final byte[] pBytes) {
        /* Loop through the bytes */
<span class="nc" id="L479">        short myValue = 0;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        for (int i = 0; i &lt; Short.BYTES; i++) {</span>
            /* Access the next byte as an unsigned integer */
<span class="nc" id="L482">            short myByte = pBytes[i];</span>
<span class="nc" id="L483">            myByte &amp;= BYTE_MASK;</span>

            /* Add in to value */
<span class="nc" id="L486">            myValue &lt;&lt;= BYTE_SHIFT;</span>
<span class="nc" id="L487">            myValue += myByte;</span>
        }

        /* Return the value */
<span class="nc" id="L491">        return myValue;</span>
    }

    /**
     * build a byte array from a short.
     *
     * @param pValue the short value to convert
     * @return the byte array
     */
    public static byte[] shortToByteArray(final short pValue) {
        /* Loop through the bytes */
<span class="nc" id="L502">        final byte[] myBytes = new byte[Short.BYTES];</span>
<span class="nc" id="L503">        int myValue = pValue;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        for (int i = Short.BYTES; i &gt; 0; i--) {</span>
            /* Store the next byte */
<span class="nc" id="L506">            final byte myByte = (byte) (myValue &amp; BYTE_MASK);</span>
<span class="nc" id="L507">            myBytes[i - 1] = myByte;</span>

            /* Adjust value */
<span class="nc" id="L510">            myValue &gt;&gt;= BYTE_SHIFT;</span>
        }

        /* Return the value */
<span class="nc" id="L514">        return myBytes;</span>
    }

    /**
     * get Bytes from String.
     *
     * @param pInput the bytes to obtain the string from
     * @return the bytes representing the bytes
     */
    public static String byteArrayToString(final byte[] pInput) {
<span class="nc" id="L524">        return new String(pInput, StandardCharsets.UTF_8);</span>
    }

    /**
     * get Bytes from String.
     *
     * @param pInput the string to obtain the bytes from
     * @return the bytes representing the string
     */
    public static byte[] stringToByteArray(final String pInput) {
<span class="nc" id="L534">        return pInput.getBytes(StandardCharsets.UTF_8);</span>
    }

    /**
     * Convert a byte array to a Base64 string.
     *
     * @param pBytes the byte array (not null)
     * @return the translated Base64 string (not null)
     */
    public static String byteArrayToBase64(final byte[] pBytes) {
        /* Determine input length and allocate output buffer */
<span class="nc" id="L545">        final int myLen = pBytes.length;</span>
<span class="nc" id="L546">        final StringBuilder myBuilder = new StringBuilder(myLen &lt;&lt; 1);</span>
<span class="nc" id="L547">        final byte[] myTriplet = new byte[BASE64_TRIPLE];</span>

        /* Loop through the input bytes */
<span class="nc" id="L550">        int myIn = 0;</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">        while (myIn &lt; myLen) {</span>
            /* Access input triplet */
<span class="nc" id="L553">            myTriplet[0] = pBytes[myIn++];</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">            myTriplet[1] = myIn &lt; myLen</span>
<span class="nc" id="L555">                    ? pBytes[myIn++]</span>
<span class="nc" id="L556">                    : 0;</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            myTriplet[2] = myIn &lt; myLen</span>
<span class="nc" id="L558">                    ? pBytes[myIn++]</span>
<span class="nc" id="L559">                    : 0;</span>

            /* Convert to base64 */
<span class="nc" id="L562">            myBuilder.append(BASE64_ENCODE[(myTriplet[0] &gt;&gt; BASE64_SHIFT1)</span>
                    &amp; BASE64_MASK]);
<span class="nc" id="L564">            myBuilder.append(BASE64_ENCODE[((myTriplet[0] &lt;&lt; BASE64_SHIFT2) | ((myTriplet[1] &amp; BYTE_MASK) &gt;&gt; BASE64_SHIFT2))</span>
                    &amp; BASE64_MASK]);
<span class="nc" id="L566">            myBuilder.append(BASE64_ENCODE[((myTriplet[1] &lt;&lt; BASE64_SHIFT1) | ((myTriplet[2] &amp; BYTE_MASK) &gt;&gt; BASE64_SHIFT3))</span>
                    &amp; BASE64_MASK]);
<span class="nc" id="L568">            myBuilder.append(BASE64_ENCODE[myTriplet[2]</span>
                    &amp; BASE64_MASK]);
        }

        /* Handle short input */
<span class="nc" id="L573">        int myXtra = myLen</span>
                % myTriplet.length;
<span class="nc bnc" id="L575" title="All 2 branches missed.">        if (myXtra &gt; 0) {</span>
            /* Determine padding length */
<span class="nc" id="L577">            myXtra = myTriplet.length</span>
                    - myXtra;

            /* Remove redundant characters */
<span class="nc" id="L581">            myBuilder.setLength(myBuilder.length()</span>
                    - myXtra);

            /* Replace with padding character */
<span class="nc bnc" id="L585" title="All 2 branches missed.">            while (myXtra-- &gt; 0) {</span>
<span class="nc" id="L586">                myBuilder.append(BASE64_PAD);</span>
            }
        }

        /* Convert chars to string */
<span class="nc" id="L591">        return myBuilder.toString();</span>
    }

    /**
     * Convert a Base64 string into a byte array.
     *
     * @param pBase64 the Base64 string (not null)
     * @return the byte array (not null)
     */
    public static byte[] base64ToByteArray(final String pBase64) {
        /* Access input as chars */
<span class="nc" id="L602">        final char[] myBase64 = pBase64.toCharArray();</span>
<span class="nc" id="L603">        final int myLen = myBase64.length;</span>

        /* Determine number of padding bytes */
<span class="nc" id="L606">        int myNumPadding = 0;</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (myBase64[myLen - 1] == BASE64_PAD) {</span>
<span class="nc" id="L608">            myNumPadding++;</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">            if (myBase64[myLen - 2] == BASE64_PAD) {</span>
<span class="nc" id="L610">                myNumPadding++;</span>
            }
        }

        /* Allocate the output buffer and index */
<span class="nc" id="L615">        final int myOutLen = ((myLen * BASE64_TRIPLE) &gt;&gt; 2)</span>
                - myNumPadding;
<span class="nc" id="L617">        final byte[] myOutput = new byte[myOutLen];</span>

        /* Loop through the base64 input */
<span class="nc" id="L620">        int myIn = 0;</span>
<span class="nc" id="L621">        int myOut = 0;</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">        while (myOut &lt; myOutLen) {</span>
            /* Build first byte */
<span class="nc" id="L624">            final int c0 = BASE64_DECODE[myBase64[myIn++]];</span>
<span class="nc" id="L625">            final int c1 = BASE64_DECODE[myBase64[myIn++]];</span>
<span class="nc" id="L626">            myOutput[myOut++] = (byte) (((c0 &lt;&lt; BASE64_SHIFT1) | (c1 &gt;&gt; BASE64_SHIFT2)) &amp; BYTE_MASK);</span>

            /* Build second byte */
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (myOut &lt; myOutLen) {</span>
<span class="nc" id="L630">                final int c2 = BASE64_DECODE[myBase64[myIn++]];</span>
<span class="nc" id="L631">                myOutput[myOut++] = (byte) (((c1 &lt;&lt; BASE64_SHIFT2) | (c2 &gt;&gt; BASE64_SHIFT1)) &amp; BYTE_MASK);</span>

                /* Build third byte */
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if (myOut &lt; myOutLen) {</span>
<span class="nc" id="L635">                    final int c3 = BASE64_DECODE[myBase64[myIn++]];</span>
<span class="nc" id="L636">                    myOutput[myOut++] = (byte) (((c2 &lt;&lt; BASE64_SHIFT3) | c3) &amp; BYTE_MASK);</span>
                }
            }
<span class="nc" id="L639">        }</span>
<span class="nc" id="L640">        return myOutput;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
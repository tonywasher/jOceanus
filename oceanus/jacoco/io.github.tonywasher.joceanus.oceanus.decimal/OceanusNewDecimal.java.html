<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OceanusNewDecimal.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Oceanus Java Core Utilities</a> &gt; <a href="index.source.html" class="el_package">io.github.tonywasher.joceanus.oceanus.decimal</a> &gt; <span class="el_source">OceanusNewDecimal.java</span></div><h1>OceanusNewDecimal.java</h1><pre class="source lang-java linenums">/*
 * Oceanus: Java Utilities
 * Copyright 2026. Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

/**
 * Provides classes to represent decimal numbers with fixed numbers of decimal digits
 * {@link #theScale} as Long integers. The decimal value is multiplied by 10 to the power of the
 * number of decimals for the number ({@link #theFactor}). The integral part of the number can be
 * expressed as (Value / Factor) and the fractional part as (Value % Factor). Arithmetic is then
 * performed as whole number arithmetic on these values, with due care taken on multiplication and
 * division to express the result to the correct number of decimals without losing any part of the
 * answer to overflow.
 */
package io.github.tonywasher.joceanus.oceanus.decimal;

import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * Decimal class performing integer arithmetic on large decimals.
 */
public class OceanusNewDecimal {
    /**
     * The Decimal radix.
     */
    private static final int RADIX_TEN = 10;

    /**
     * The Maximum # of Decimals.
     */
    public static final int MAX_DECIMALS = 9;

    /**
     * The Integer boost.
     */
    private static final long INTEGER_BOOST = 0x100000000L;

    /**
     * The Integer mask.
     */
    private static final long INTEGER_MASK = 0xFFFFFFFFL;

    /**
     * Powers of Ten.
     */
<span class="nc" id="L59">    private static final int[] POWERS_OF_TEN = getPowersOfTen(MAX_DECIMALS);</span>

    /**
     * The number of decimal digits.
     */
    private final int theScale;

    /**
     * The Decimal factor, used for rounding fractional parts.
     */
    private final int theFactor;

    /**
     * sign.
     */
    private int theSign;

    /**
     * Positive Integral part.
     */
    private long theIntegral;

    /**
     * Positive Fractional part.
     */
    private int theFractional;

    /**
     * Constructor.
     *
     * @param pScale the number of decimal digits
     */
    public OceanusNewDecimal(final int pScale) {
<span class="nc" id="L92">        this(0, 0, 0, pScale);</span>
<span class="nc" id="L93">    }</span>

    /**
     * Constructor.
     *
     * @param pSource the source BigDecimal
     */
<span class="nc" id="L100">    public OceanusNewDecimal(final BigDecimal pSource) {</span>
        /* Store sign and scale */
<span class="nc" id="L102">        theSign = pSource.signum();</span>
<span class="nc" id="L103">        theScale = pSource.scale();</span>
<span class="nc" id="L104">        checkValidScale(theScale);</span>
<span class="nc" id="L105">        theFactor = getFactor(theScale);</span>

        /* Extract the integral and fractional parts */
<span class="nc" id="L108">        theIntegral = pSource.longValue();</span>
<span class="nc" id="L109">        theIntegral *= theSign;</span>
<span class="nc" id="L110">        long myFractional = pSource.movePointRight(theScale).longValue() * theSign;</span>
<span class="nc" id="L111">        myFractional %= theFactor;</span>
<span class="nc" id="L112">        theFractional = (int) myFractional;</span>
<span class="nc" id="L113">    }</span>

    /**
     * Constructor.
     *
     * @param pIntegral   the integral part of the decimal.
     * @param pFractional the fractional part of the decimal
     * @param pSign       the sign of the decimal
     * @param pScale      the number of decimal digits
     */
    public OceanusNewDecimal(final long pIntegral,
                             final int pFractional,
                             final int pSign,
<span class="nc" id="L126">                             final int pScale) {</span>
        /* Check that scale if valid */
<span class="nc" id="L128">        checkValidScale(pScale);</span>

        /* Store details */
<span class="nc" id="L131">        theIntegral = pIntegral;</span>
<span class="nc" id="L132">        theFractional = pFractional;</span>
<span class="nc" id="L133">        theSign = pSign;</span>
<span class="nc" id="L134">        theScale = pScale;</span>
<span class="nc" id="L135">        theFactor = getFactor(theScale);</span>
<span class="nc" id="L136">    }</span>

    /**
     * Check that the scale is valid.
     *
     * @param pScale the scale
     */
    private static void checkValidScale(final int pScale) {
<span class="nc bnc" id="L144" title="All 4 branches missed.">        if (pScale &lt; 0 || pScale &gt; MAX_DECIMALS) {</span>
<span class="nc" id="L145">            throw new IllegalArgumentException(&quot;Invalid scale - &quot; + pScale);</span>
        }
<span class="nc" id="L147">    }</span>

    /**
     * Obtain the integral part of the decimal.
     *
     * @return the integral part of the decimal
     */
    public long integralValue() {
<span class="nc" id="L155">        return theIntegral * theSign;</span>
    }

    /**
     * Obtain the sign of the decimal.
     *
     * @return -1, 0, or 1 as the value of this Decimal is negative, zero, or positive
     */
    public int signum() {
<span class="nc" id="L164">        return theSign;</span>
    }

    /**
     * Obtain the fractional part of the decimal.
     *
     * @return the fractional part of the decimal
     */
    public int fractionalValue() {
<span class="nc" id="L173">        return theFractional * theSign;</span>
    }

    /**
     * Obtain the scale of the decimal.
     *
     * @return the scale of the decimal
     */
    public int scale() {
<span class="nc" id="L182">        return theScale;</span>
    }

    /**
     * Add a decimal to value.
     *
     * @param pDecimal the decimal to add to this value
     */
    public void add(final OceanusNewDecimal pDecimal) {
        /* Access the integral/fractional part of the second decimal at the same scale */
<span class="nc" id="L192">        long myIntegral = pDecimal.theIntegral;</span>
<span class="nc" id="L193">        long myFractional = adjustDecimals(pDecimal.theFractional, theScale - pDecimal.theScale);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (myFractional &gt;= theFactor) {</span>
<span class="nc" id="L195">            myFractional %= theFactor;</span>
<span class="nc" id="L196">            myIntegral++;</span>
        }
<span class="nc" id="L198">        add(myIntegral, (int) myFractional);</span>
<span class="nc" id="L199">    }</span>

    /**
     * Subtract a decimal from value.
     *
     * @param pDecimal the decimal to subtract from this value
     */
    public void subtract(final OceanusNewDecimal pDecimal) {
        /* Access the integral/fractional part of the second decimal at the same scale */
<span class="nc" id="L208">        long myIntegral = pDecimal.theIntegral;</span>
<span class="nc" id="L209">        long myFractional = adjustDecimals(pDecimal.theFractional, theScale - pDecimal.theScale);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (myFractional &gt;= theFactor) {</span>
<span class="nc" id="L211">            myFractional %= theFactor;</span>
<span class="nc" id="L212">            myIntegral++;</span>
        }
<span class="nc" id="L214">        add(-myIntegral, (int) -myFractional);</span>
<span class="nc" id="L215">    }</span>

    /**
     * Add a decimal to this value.
     *
     * @param pIntegral   the integral part of the decimal.
     * @param pFractional the fractional part of the decimal
     */
    private void add(final long pIntegral,
                     final int pFractional) {
        /* Add the fractional and non-fractional parts of the sum */
<span class="nc" id="L226">        theFractional = pFractional + fractionalValue();</span>
<span class="nc" id="L227">        theIntegral = pIntegral + integralValue();</span>

        /* If we have a positive integral # */
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (theIntegral &gt; 0) {</span>
            /* Handle fractional too small */
<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (theFractional &lt; 0) {</span>
<span class="nc" id="L233">                theFractional += theFactor;</span>
<span class="nc" id="L234">                theIntegral--;</span>

                /* Handle fractional too large */
<span class="nc bnc" id="L237" title="All 2 branches missed.">            } else if (theFractional &gt;= theFactor) {</span>
<span class="nc" id="L238">                theFractional -= theFactor;</span>
<span class="nc" id="L239">                theIntegral++;</span>
            }

            /* Set sign */
<span class="nc" id="L243">            theSign = 1;</span>

            /* If we have a negative integral # */
<span class="nc bnc" id="L246" title="All 2 branches missed.">        } else if (theIntegral &lt; 0) {</span>
            /* Handle fractional too large */
<span class="nc bnc" id="L248" title="All 2 branches missed.">            if (theFractional &gt; 0) {</span>
<span class="nc" id="L249">                theFractional -= theFactor;</span>
<span class="nc" id="L250">                theIntegral++;</span>

                /* Handle fractional too small */
<span class="nc bnc" id="L253" title="All 2 branches missed.">            } else if (theFractional &lt;= -theFactor) {</span>
<span class="nc" id="L254">                theFractional += theFactor;</span>
<span class="nc" id="L255">                theIntegral--;</span>
            }

            /* Set sign */
<span class="nc" id="L259">            theSign = -1;</span>
<span class="nc" id="L260">            theFractional = -theFractional;</span>
<span class="nc" id="L261">            theIntegral = -theIntegral;</span>

            /* else we have a zero integral */
        } else {
            /* Handle fractional too large */
<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (theFractional &gt;= theFactor) {</span>
<span class="nc" id="L267">                theFractional -= theFactor;</span>
<span class="nc" id="L268">                theIntegral = 1;</span>
<span class="nc" id="L269">                theSign = 1;</span>

                /* Handle Fractional too small */
<span class="nc bnc" id="L272" title="All 2 branches missed.">            } else if (theFractional &lt;= -theFactor) {</span>
<span class="nc" id="L273">                theFractional += theFactor;</span>
<span class="nc" id="L274">                theSign = -1;</span>
<span class="nc" id="L275">                theIntegral = 1;</span>
<span class="nc" id="L276">                theFractional = -theFractional;</span>

                /* Handle positive fractional */
<span class="nc bnc" id="L279" title="All 2 branches missed.">            } else if (theFractional &gt; 0) {</span>
<span class="nc" id="L280">                theSign = 1;</span>

                /* Handle negative fractional */
<span class="nc bnc" id="L283" title="All 2 branches missed.">            } else if (theFractional &lt; 0) {</span>
<span class="nc" id="L284">                theSign = -1;</span>
<span class="nc" id="L285">                theFractional = -theFractional;</span>

                /* Handle zero fractional */
            } else {
<span class="nc" id="L289">                theSign = 0;</span>
            }
        }
<span class="nc" id="L292">    }</span>

    /**
     * Multiply by another decimal
     * &lt;p&gt;
     * This function splits the values into three separate integers and then performs long arithmetic to
     * prevent loss of precision. The value is represented as (x,y,z,s) where the decimal may be written as
     * x*2&lt;sup&gt;32&lt;/sup&gt; + y + z*10&lt;sup&gt;-s&lt;/sup&gt; and x,y,z,s are all integers.
     * &lt;p&gt;
     * The product of (x&lt;sub&gt;1&lt;/sub&gt;, y&lt;sub&gt;1&lt;/sub&gt;, z&lt;sub&gt;1&lt;/sub&gt;, s) by
     * (x&lt;sub&gt;2&lt;/sub&gt;, y&lt;sub&gt;2&lt;/sub&gt;, z&lt;sub&gt;2&lt;/sub&gt;, t)
     * is therefore x&lt;sub&gt;1&lt;/sub&gt;*x&lt;sub&gt;2&lt;/sub&gt;*2&lt;sup&gt;64&lt;/sup&gt; (discardable)
     * + (x&lt;sub&gt;1&lt;/sub&gt;*y&lt;sub&gt;2&lt;/sub&gt; + x&lt;sub&gt;2&lt;/sub&gt;*y&lt;sub&gt;1&lt;/sub&gt;)*2&lt;sup&gt;32&lt;/sup&gt;
     * + x&lt;sub&gt;2&lt;/sub&gt;*y&lt;sub&gt;2&lt;/sub&gt;
     * + x&lt;sub&gt;1&lt;/sub&gt;*z&lt;sub&gt;2&lt;/sub&gt;*2&lt;sup&gt;32&lt;/sup&gt;*10&lt;sup&gt;-t&lt;/sup&gt;
     * + x&lt;sub&gt;2&lt;/sub&gt;*z&lt;sub&gt;1&lt;/sub&gt;*2&lt;sup&gt;32&lt;/sup&gt;*10&lt;sup&gt;-s&lt;/sup&gt;
     * + y&lt;sub&gt;1&lt;/sub&gt;*z&lt;sub&gt;2&lt;/sub&gt;*10&lt;sup&gt;-t&lt;/sup&gt;
     * + y&lt;sub&gt;2&lt;/sub&gt;*z&lt;sub&gt;1&lt;/sub&gt;*10&lt;sup&gt;-s&lt;/sup&gt;
     * + z&lt;sub&gt;1&lt;/sub&gt;*z&lt;sub&gt;2&lt;/sub&gt;*10&lt;sup&gt;-s-t&lt;/sup&gt;
     *
     * @param pMultiplicand the decimal to multiply by
     */
    public void multiply(final OceanusNewDecimal pMultiplicand) {
        /* Access the parts of this value */
<span class="nc" id="L316">        final long myX1 = theIntegral &gt;&gt;&gt; Integer.SIZE;</span>
<span class="nc" id="L317">        final long myY1 = theIntegral &amp; INTEGER_MASK;</span>
<span class="nc" id="L318">        final long myZ1 = theFractional;</span>
<span class="nc" id="L319">        final int myS = theScale;</span>
<span class="nc" id="L320">        final int mySFactor = theFactor;</span>

        /* Access the parts of the multiplicand */
<span class="nc" id="L323">        final long myX2 = pMultiplicand.theIntegral &gt;&gt;&gt; Integer.SIZE;</span>
<span class="nc" id="L324">        final long myY2 = pMultiplicand.theIntegral &amp; INTEGER_MASK;</span>
<span class="nc" id="L325">        final long myZ2 = pMultiplicand.theFractional;</span>
<span class="nc" id="L326">        final int myT = pMultiplicand.theScale;</span>
<span class="nc" id="L327">        final int myTFactor = pMultiplicand.theFactor;</span>
<span class="nc" id="L328">        final long mySTFactor = mySFactor * (long) myTFactor;</span>

        /* Calculate integral products */
<span class="nc" id="L331">        long myIntegral = ((myX1 * myY2) + (myY1 * myX2)) &lt;&lt; Integer.SIZE;</span>
<span class="nc" id="L332">        myIntegral += myY2 * myX2;</span>

        /* Calculate product of X2 and Z1 and multiply by 2^32 */
<span class="nc" id="L335">        long myProduct = myX2 * myZ1;</span>
<span class="nc" id="L336">        long myIntPart = myProduct / mySFactor;</span>
<span class="nc" id="L337">        long myFracPart = myProduct % mySFactor;</span>
<span class="nc" id="L338">        myIntegral += myIntPart &lt;&lt; Integer.SIZE;</span>
<span class="nc" id="L339">        myFracPart *= INTEGER_BOOST;</span>
<span class="nc" id="L340">        myIntegral += myFracPart / mySFactor;</span>
<span class="nc" id="L341">        long myFractional = adjustDecimals(myFracPart % mySFactor, myT);</span>

        /* Calculate products of Y2 and Z1 */
<span class="nc" id="L344">        myProduct = myY2 * myZ1;</span>
<span class="nc" id="L345">        myIntegral += myProduct / mySFactor;</span>
<span class="nc" id="L346">        myFractional += adjustDecimals(myProduct % mySFactor, myT);</span>

        /* Calculate product of X1 and Z2 and multiply by 2^32 */
<span class="nc" id="L349">        myProduct = myX1 * myZ2;</span>
<span class="nc" id="L350">        myIntPart = myProduct / myTFactor;</span>
<span class="nc" id="L351">        myFracPart = myProduct % myTFactor;</span>
<span class="nc" id="L352">        myIntegral += myIntPart &lt;&lt; Integer.SIZE;</span>
<span class="nc" id="L353">        myFracPart *= INTEGER_BOOST;</span>
<span class="nc" id="L354">        myIntegral += myFracPart / myTFactor;</span>
<span class="nc" id="L355">        myFractional += adjustDecimals(myFracPart % myTFactor, myS);</span>

        /* Calculate products of Y1 and Z2 */
<span class="nc" id="L358">        myProduct = myY1 * myZ2;</span>
<span class="nc" id="L359">        myIntegral += myProduct / myTFactor;</span>
<span class="nc" id="L360">        myFractional += adjustDecimals(myProduct % myTFactor, myS);</span>

        /* Calculate products of Z1 and Z2 */
<span class="nc" id="L363">        myFractional += myZ1 * myZ2;</span>

        /* Handle wrap of fractional */
<span class="nc" id="L366">        myIntegral += myFracPart / mySTFactor;</span>
<span class="nc" id="L367">        myFractional %= mySTFactor;</span>

        /* Adjust decimals */
<span class="nc" id="L370">        myFractional = adjustDecimals(myFractional, -myT);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (myFractional &gt;= mySFactor) {</span>
<span class="nc" id="L372">            myFractional %= mySFactor;</span>
<span class="nc" id="L373">            myIntegral++;</span>
        }

        /* Store the result */
<span class="nc" id="L377">        theIntegral = myIntegral;</span>
<span class="nc" id="L378">        theFractional = (int) myFractional;</span>
<span class="nc" id="L379">        theSign *= pMultiplicand.theSign;</span>
<span class="nc" id="L380">    }</span>

    /**
     * Divide by another decimal.
     * &lt;p&gt;
     * This function uses BigDecimal to perform the calculation
     *
     * @param pDivisor the decimal to divide by
     */
    public void divide(final OceanusNewDecimal pDivisor) {
        /* Calculate the result */
<span class="nc" id="L391">        final BigDecimal myNumerator = toBigDecimal();</span>
<span class="nc" id="L392">        final BigDecimal myDenominator = pDivisor.toBigDecimal();</span>
<span class="nc" id="L393">        final BigDecimal myResult = myNumerator.divide(myDenominator, theScale, RoundingMode.HALF_UP);</span>

        /* Extract the integral and fractional parts */
<span class="nc" id="L396">        theSign = myResult.signum();</span>
<span class="nc" id="L397">        theIntegral = myResult.longValue();</span>
<span class="nc" id="L398">        theIntegral *= theSign;</span>
<span class="nc" id="L399">        long myFractional = myResult.movePointRight(theScale).longValue() * theSign;</span>
<span class="nc" id="L400">        myFractional %= theFactor;</span>
<span class="nc" id="L401">        theFractional = (int) myFractional;</span>
<span class="nc" id="L402">    }</span>

    /**
     * Convert to BigDecimal.
     *
     * @return the BigDecimal equivalent
     */
    public BigDecimal toBigDecimal() {
<span class="nc" id="L410">        final BigDecimal myIntegral = new BigDecimal(theIntegral);</span>
<span class="nc" id="L411">        final BigDecimal myFractional = new BigDecimal(theFractional).movePointLeft(theScale);</span>
<span class="nc" id="L412">        final BigDecimal myResult = myIntegral.add(myFractional);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        return theSign == -1 ? myResult.negate() : myResult;</span>
    }

    @Override
    public String toString() {
        /* Format the string */
<span class="nc" id="L419">        final StringBuilder myString = new StringBuilder(100);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (theSign == -1) {</span>
<span class="nc" id="L421">            myString.append('-');</span>
        }
<span class="nc" id="L423">        myString.append(theIntegral);</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (theScale &gt; 0) {</span>
<span class="nc" id="L425">            final int myLen = myString.length();</span>
<span class="nc" id="L426">            myString.append(theFractional + theFactor);</span>
<span class="nc" id="L427">            myString.setCharAt(myLen, '.');</span>
        }

        /* Return the string */
<span class="nc" id="L431">        return myString.toString();</span>
    }

    /**
     * Build powers of ten.
     *
     * @param pMax maximum power of ten
     * @return array of powers of ten
     */
    private static int[] getPowersOfTen(final int pMax) {
        /* Allocate the array */
<span class="nc" id="L442">        final int[] myArray = new int[pMax + 1];</span>

        /* Initialise array */
<span class="nc" id="L445">        int myValue = 1;</span>
<span class="nc" id="L446">        myArray[0] = myValue;</span>

        /* Loop through array */
<span class="nc bnc" id="L449" title="All 2 branches missed.">        for (int i = 1; i &lt; pMax + 1; i++) {</span>
            /* Adjust value and record it */
<span class="nc" id="L451">            myValue *= RADIX_TEN;</span>
<span class="nc" id="L452">            myArray[i] = myValue;</span>
        }

        /* Return the array */
<span class="nc" id="L456">        return myArray;</span>
    }

    /**
     * Obtain factor.
     *
     * @param pDecimals the number of decimals
     * @return the decimal part of the number
     */
    private static int getFactor(final int pDecimals) {
<span class="nc" id="L466">        return POWERS_OF_TEN[pDecimals];</span>
    }

    /**
     * Adjust a value to a different number of decimals.
     * &lt;p&gt;
     * If the adjustment is to reduce the number of decimals, the most significant digit of the
     * discarded digits is examined to determine whether to round up. If the number of decimals is
     * to be increased, zeros are simply added to the end.
     *
     * @param pValue  the value to adjust
     * @param iAdjust the adjustment (positive if # of decimals are to increase, negative if they
     *                are to decrease)
     * @return the adjusted value
     */
    private static long adjustDecimals(final long pValue,
                                       final int iAdjust) {
        /* Take a copy of the value */
<span class="nc" id="L484">        long myValue = pValue;</span>

        /* If we need to reduce decimals */
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (iAdjust &lt; 0) {</span>
            /* If we have more than one decimal to remove */
<span class="nc bnc" id="L489" title="All 2 branches missed.">            if (iAdjust + 1 &lt; 0) {</span>
                /* Calculate division factor (minus one) */
<span class="nc" id="L491">                final long myFactor = getFactor(-(iAdjust + 1));</span>

                /* Reduce to 10 times required value */
<span class="nc" id="L494">                myValue /= myFactor;</span>
            }

            /* Access last digit */
<span class="nc" id="L498">            long myDigit = myValue</span>
                    % RADIX_TEN;

            /* Handle negative values */
<span class="nc" id="L502">            int myAdjust = 1;</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (myDigit &lt; 0) {</span>
<span class="nc" id="L504">                myAdjust = -1;</span>
<span class="nc" id="L505">                myDigit = -myDigit;</span>
            }

            /* Reduce final decimal and round up if required */
<span class="nc" id="L509">            myValue /= RADIX_TEN;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">            if (myDigit &gt;= (RADIX_TEN &gt;&gt; 1)) {</span>
<span class="nc" id="L511">                myValue += myAdjust;</span>
            }

            /* else if we need to expand fractional product */
<span class="nc bnc" id="L515" title="All 2 branches missed.">        } else if (iAdjust &gt; 0) {</span>
<span class="nc" id="L516">            myValue *= getFactor(iAdjust);</span>
        }

        /* Return the adjusted value */
<span class="nc" id="L520">        return myValue;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
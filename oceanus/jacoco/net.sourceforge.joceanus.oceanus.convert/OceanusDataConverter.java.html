<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OceanusDataConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Oceanus Java Core Utilities</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.oceanus.convert</a> &gt; <span class="el_source">OceanusDataConverter.java</span></div><h1>OceanusDataConverter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Oceanus: Java Utilities
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package net.sourceforge.joceanus.oceanus.convert;

import net.sourceforge.joceanus.oceanus.base.OceanusException;
import net.sourceforge.joceanus.oceanus.exc.OceanusDataException;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

/**
 * Data Conversion utility functions.
 */
public final class OceanusDataConverter {
    /**
     * Invalid hexadecimal length string.
     */
    private static final String ERROR_HEXLEN = &quot;Invalid HexString Length: &quot;;

    /**
     * Invalid hexadecimal error string.
     */
    private static final String ERROR_HEXDIGIT = &quot;Non Hexadecimal Value: &quot;;

    /**
     * Base64 Encoding array.
     */
<span class="fc" id="L47">    private static final char[] BASE64_ENCODE = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;.toCharArray();</span>

    /**
     * Base64 Decoding array.
     */
<span class="fc" id="L52">    private static final int[] BASE64_DECODE = new int[BASE64_ENCODE.length &lt;&lt; 1];</span>

    static {
<span class="fc bfc" id="L55" title="All 2 branches covered.">        for (int i = 0; i &lt; BASE64_ENCODE.length; i++) {</span>
<span class="fc" id="L56">            BASE64_DECODE[BASE64_ENCODE[i]] = i;</span>
        }
<span class="fc" id="L58">    }</span>

    /**
     * Base64 triplet size.
     */
    private static final int BASE64_TRIPLE = 3;

    /**
     * Base64 padding character.
     */
    private static final char BASE64_PAD = '=';

    /**
     * Base64 shift 1.
     */
    private static final int BASE64_SHIFT1 = 2;

    /**
     * Base64 shift 2.
     */
    private static final int BASE64_SHIFT2 = 4;

    /**
     * Base64 shift 3.
     */
    private static final int BASE64_SHIFT3 = 6;

    /**
     * Hexadecimal Radix.
     */
    public static final int HEX_RADIX = 16;

    /**
     * Byte shift.
     */
    public static final int BYTE_SHIFT = Byte.SIZE;

    /**
     * Byte mask.
     */
    public static final int BYTE_MASK = 0xFF;

    /**
     * Base64 mask.
     */
    public static final int BASE64_MASK = 0x3F;

    /**
     * Color mask.
     */
    public static final int COLOR_MASK = 0x00FFFFFF;

    /**
     * Nybble shift.
     */
    public static final int NYBBLE_SHIFT = Byte.SIZE &gt;&gt; 1;

    /**
     * Nybble mask.
     */
    public static final int NYBBLE_MASK = 0xF;

    /**
     * RGB colour length.
     */
    public static final int RGB_LENGTH = 6;

    /**
     * Private constructor to avoid instantiation.
     */
    private OceanusDataConverter() {
    }

    /**
     * format a byte array as a hexadecimal string.
     * @param pBytes the byte array
     * @return the string
     */
    public static String bytesToHexString(final byte[] pBytes) {
        /* Allocate the string builder */
<span class="nc" id="L138">        final StringBuilder myValue = new StringBuilder(2 * pBytes.length);</span>

        /* For each byte in the value */
<span class="nc bnc" id="L141" title="All 2 branches missed.">        for (final byte b : pBytes) {</span>
            /* Access the byte as an unsigned integer */
<span class="nc" id="L143">            int myInt = b;</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (myInt &lt; 0) {</span>
<span class="nc" id="L145">                myInt += BYTE_MASK + 1;</span>
            }

            /* Access the high nybble */
<span class="nc" id="L149">            int myDigit = myInt &gt;&gt;&gt; NYBBLE_SHIFT;</span>
<span class="nc" id="L150">            char myChar = Character.forDigit(myDigit, HEX_RADIX);</span>

            /* Add it to the value string */
<span class="nc" id="L153">            myValue.append(myChar);</span>

            /* Access the low digit */
<span class="nc" id="L156">            myDigit = myInt</span>
                      &amp; NYBBLE_MASK;
<span class="nc" id="L158">            myChar = Character.forDigit(myDigit, HEX_RADIX);</span>

            /* Add it to the value string */
<span class="nc" id="L161">            myValue.append(myChar);</span>
        }

        /* Return the string */
<span class="nc" id="L165">        return myValue.toString();</span>
    }

    /**
     * format a long as a hexadecimal string.
     * @param pValue the long value
     * @return the string
     */
    public static String longToHexString(final long pValue) {
        /* Access the long value */
<span class="nc" id="L175">        long myLong = pValue;</span>

        /* Allocate the string builder */
<span class="nc" id="L178">        final StringBuilder myValue = new StringBuilder();</span>

        /* handle negative values */
<span class="nc bnc" id="L181" title="All 2 branches missed.">        final boolean isNegative = myLong &lt; 0;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (isNegative) {</span>
<span class="nc" id="L183">            myLong = -myLong;</span>
        }

        /* Special case for zero */
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (myLong == 0) {</span>
<span class="nc" id="L188">            myValue.append(&quot;00&quot;);</span>

            /* else need to loop through the digits */
        } else {
            /* While we have digits to format */
<span class="nc bnc" id="L193" title="All 2 branches missed.">            while (myLong &gt; 0) {</span>
                /* Access the digit and move to next one */
<span class="nc" id="L195">                final int myDigit = (int) (myLong &amp; NYBBLE_MASK);</span>
<span class="nc" id="L196">                final char myChar = Character.forDigit(myDigit, HEX_RADIX);</span>
<span class="nc" id="L197">                myValue.insert(0, myChar);</span>
<span class="nc" id="L198">                myLong &gt;&gt;&gt;= NYBBLE_SHIFT;</span>
<span class="nc" id="L199">            }</span>

            /* If we are odd length prefix a zero */
<span class="nc bnc" id="L202" title="All 2 branches missed.">            if ((myValue.length() &amp; 1) != 0) {</span>
<span class="nc" id="L203">                myValue.insert(0, '0');</span>
            }

            /* Reinstate negative sign */
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (isNegative) {</span>
<span class="nc" id="L208">                myValue.insert(0, '-');</span>
            }
        }

        /* Return the string */
<span class="nc" id="L213">        return myValue.toString();</span>
    }

    /**
     * parse a byte array from a hexadecimal string.
     * @param pHexString the hex string
     * @return the bytes
     * @throws OceanusException on error
     */
    public static byte[] hexStringToBytes(final String pHexString) throws OceanusException {
        /* Access the length of the hex string */
<span class="nc" id="L224">        final int myLen = pHexString.length();</span>

        /* Check that it has an even length */
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (myLen % 2 != 0) {</span>
<span class="nc" id="L228">            throw new OceanusDataException(ERROR_HEXLEN</span>
                                          + pHexString);
        }

        /* Allocate the new bytes array */
<span class="nc" id="L233">        final byte[] myByteValue = new byte[myLen / 2];</span>

        /* Loop through the string */
<span class="nc bnc" id="L236" title="All 2 branches missed.">        for (int i = 0; i &lt; myLen; i += 2) {</span>
            /* Access the top level byte */
<span class="nc" id="L238">            char myChar = pHexString.charAt(i);</span>
<span class="nc" id="L239">            int myDigit = Character.digit(myChar, HEX_RADIX);</span>

            /* Check that the char is a valid hex digit */
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (myDigit &lt; 0) {</span>
<span class="nc" id="L243">                throw new OceanusDataException(ERROR_HEXDIGIT</span>
                                              + pHexString);
            }

            /* Initialise result */
<span class="nc" id="L248">            int myInt = myDigit &lt;&lt; NYBBLE_SHIFT;</span>

            /* Access the second byte */
<span class="nc" id="L251">            myChar = pHexString.charAt(i + 1);</span>
<span class="nc" id="L252">            myDigit = Character.digit(myChar, HEX_RADIX);</span>

            /* Check that the char is a valid hex digit */
<span class="nc bnc" id="L255" title="All 2 branches missed.">            if (myDigit &lt; 0) {</span>
<span class="nc" id="L256">                throw new OceanusDataException(ERROR_HEXDIGIT</span>
                                              + pHexString);
            }

            /* Add into result */
<span class="nc" id="L261">            myInt += myDigit;</span>

            /* Convert to byte and store */
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (myInt &gt; Byte.MAX_VALUE) {</span>
<span class="nc" id="L265">                myInt -= BYTE_MASK + 1;</span>
            }
<span class="nc" id="L267">            myByteValue[i / 2] = (byte) myInt;</span>
        }

        /* Return the bytes */
<span class="nc" id="L271">        return myByteValue;</span>
    }

    /**
     * parse a long from a hexadecimal string.
     * @param pHexString the hex string
     * @return the bytes
     * @throws OceanusException on error
     */
    public static long hexStringToLong(final String pHexString) throws OceanusException {
        /* Access the length of the hex string */
<span class="nc" id="L282">        String myHexString = pHexString;</span>
<span class="nc" id="L283">        int myLen = myHexString.length();</span>

        /* handle negative values */
<span class="nc bnc" id="L286" title="All 2 branches missed.">        final boolean isNegative = myLen &gt; 0</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                                   &amp;&amp; myHexString.charAt(0) == '-';</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (isNegative) {</span>
<span class="nc" id="L289">            myHexString = myHexString.substring(1);</span>
<span class="nc" id="L290">            myLen--;</span>
        }

        /* Check that it has an even length */
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (myLen % 2 != 0) {</span>
<span class="nc" id="L295">            throw new OceanusDataException(ERROR_HEXLEN</span>
                                          + pHexString);
        }

        /* Loop through the string */
<span class="nc" id="L300">        long myValue = 0;</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        for (int i = 0; i &lt; myLen; i++) {</span>
            /* Access the next character */
<span class="nc" id="L303">            final char myChar = myHexString.charAt(i);</span>
<span class="nc" id="L304">            final int myDigit = Character.digit(myChar, HEX_RADIX);</span>

            /* Check that the char is a valid hex digit */
<span class="nc bnc" id="L307" title="All 2 branches missed.">            if (myDigit &lt; 0) {</span>
<span class="nc" id="L308">                throw new OceanusDataException(ERROR_HEXDIGIT</span>
                                              + pHexString);
            }

            /* Add into the value */
<span class="nc" id="L313">            myValue &lt;&lt;= NYBBLE_SHIFT;</span>
<span class="nc" id="L314">            myValue += myDigit;</span>
        }

        /* Reinstate negative values */
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (isNegative) {</span>
<span class="nc" id="L319">            myValue = -myValue;</span>
        }

        /* Return the value */
<span class="nc" id="L323">        return myValue;</span>
    }

    /**
     * Convert character array to byte array.
     * @param pChars the character array
     * @return the byte array
     * @throws OceanusException on error
     */
    public static byte[] charsToByteArray(final char[] pChars) throws OceanusException {
        /* protect against exceptions */
        try {
            /* Transform the character array to a byte array */
<span class="nc" id="L336">            final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L337">            final OutputStreamWriter out = new OutputStreamWriter(baos, StandardCharsets.UTF_8);</span>
<span class="nc" id="L338">            out.write(pChars, 0, pChars.length);</span>
<span class="nc" id="L339">            out.flush();</span>
<span class="nc" id="L340">            return baos.toByteArray();</span>
<span class="nc" id="L341">        } catch (IOException e) {</span>
<span class="nc" id="L342">            throw new OceanusDataException(e.getMessage(), e);</span>
        }
    }

    /**
     * Convert byte array to character array.
     * @param pBytes the byte array
     * @return the character array
     * @throws OceanusException on error
     */
    public static char[] bytesToCharArray(final byte[] pBytes) throws OceanusException {
        /* protect against exceptions */
        try {
            /* Allocate the character array allowing for one character per byte */
<span class="nc" id="L356">            char[] myArray = new char[pBytes.length];</span>

            /* Transform the byte array to a character array */
<span class="nc" id="L359">            final ByteArrayInputStream bais = new ByteArrayInputStream(pBytes);</span>
<span class="nc" id="L360">            final InputStreamReader in = new InputStreamReader(bais, StandardCharsets.UTF_8);</span>
<span class="nc" id="L361">            final int myLen = in.read(myArray);</span>

            /* Cut down the array to the actual length */
<span class="nc" id="L364">            myArray = Arrays.copyOf(myArray, myLen);</span>

            /* Return the array */
<span class="nc" id="L367">            return myArray;</span>
<span class="nc" id="L368">        } catch (IOException e) {</span>
<span class="nc" id="L369">            throw new OceanusDataException(e.getMessage(), e);</span>
        }
    }

    /**
     * parse a long from a byte array.
     * @param pBytes the eight byte array holding the long
     * @return the long value
     */
    public static long byteArrayToLong(final byte[] pBytes) {
        /* Loop through the bytes */
<span class="fc" id="L380">        long myValue = 0;</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        for (int i = 0; i &lt; Long.BYTES; i++) {</span>
            /* Access the next byte as an unsigned integer */
<span class="fc" id="L383">            int myByte = pBytes[i];</span>
<span class="fc" id="L384">            myByte &amp;= BYTE_MASK;</span>

            /* Add in to value */
<span class="fc" id="L387">            myValue &lt;&lt;= BYTE_SHIFT;</span>
<span class="fc" id="L388">            myValue += myByte;</span>
        }

        /* Return the value */
<span class="fc" id="L392">        return myValue;</span>
    }

    /**
     * build a byte array from a long.
     * @param pValue the long value to convert
     * @return the byte array
     */
    public static byte[] longToByteArray(final long pValue) {
        /* Loop through the bytes */
<span class="fc" id="L402">        long myValue = pValue;</span>
<span class="fc" id="L403">        final byte[] myBytes = new byte[Long.BYTES];</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        for (int i = Long.BYTES; i &gt; 0; i--) {</span>
            /* Store the next byte */
<span class="fc" id="L406">            final byte myByte = (byte) (myValue &amp; BYTE_MASK);</span>
<span class="fc" id="L407">            myBytes[i - 1] = myByte;</span>

            /* Adjust value */
<span class="fc" id="L410">            myValue &gt;&gt;= BYTE_SHIFT;</span>
        }

        /* Return the value */
<span class="fc" id="L414">        return myBytes;</span>
    }

    /**
     * parse an integer from a byte array.
     * @param pBytes the four byte array holding the integer
     * @return the integer value
     */
    public static int byteArrayToInteger(final byte[] pBytes) {
        /* Loop through the bytes */
<span class="nc" id="L424">        int myValue = 0;</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        for (int i = 0; i &lt; Integer.BYTES; i++) {</span>
            /* Access the next byte as an unsigned integer */
<span class="nc" id="L427">            int myByte = pBytes[i];</span>
<span class="nc" id="L428">            myByte &amp;= BYTE_MASK;</span>

            /* Add in to value */
<span class="nc" id="L431">            myValue &lt;&lt;= BYTE_SHIFT;</span>
<span class="nc" id="L432">            myValue += myByte;</span>
        }

        /* Return the value */
<span class="nc" id="L436">        return myValue;</span>
    }

    /**
     * build a byte array from an integer.
     * @param pValue the integer value to convert
     * @return the byte array
     */
    public static byte[] integerToByteArray(final int pValue) {
        /* Loop through the bytes */
<span class="nc" id="L446">        final byte[] myBytes = new byte[Integer.BYTES];</span>
<span class="nc" id="L447">        int myValue = pValue;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">        for (int i = Integer.BYTES; i &gt; 0; i--) {</span>
            /* Store the next byte */
<span class="nc" id="L450">            final byte myByte = (byte) (myValue &amp; BYTE_MASK);</span>
<span class="nc" id="L451">            myBytes[i - 1] = myByte;</span>

            /* Adjust value */
<span class="nc" id="L454">            myValue &gt;&gt;= BYTE_SHIFT;</span>
        }

        /* Return the value */
<span class="nc" id="L458">        return myBytes;</span>
    }

    /**
     * parse a short from a byte array.
     * @param pBytes the four byte array holding the integer
     * @return the short value
     */
    public static short byteArrayToShort(final byte[] pBytes) {
        /* Loop through the bytes */
<span class="nc" id="L468">        short myValue = 0;</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        for (int i = 0; i &lt; Short.BYTES; i++) {</span>
            /* Access the next byte as an unsigned integer */
<span class="nc" id="L471">            short myByte = pBytes[i];</span>
<span class="nc" id="L472">            myByte &amp;= BYTE_MASK;</span>

            /* Add in to value */
<span class="nc" id="L475">            myValue &lt;&lt;= BYTE_SHIFT;</span>
<span class="nc" id="L476">            myValue += myByte;</span>
        }

        /* Return the value */
<span class="nc" id="L480">        return myValue;</span>
    }

    /**
     * build a byte array from a short.
     * @param pValue the short value to convert
     * @return the byte array
     */
    public static byte[] shortToByteArray(final short pValue) {
        /* Loop through the bytes */
<span class="nc" id="L490">        final byte[] myBytes = new byte[Short.BYTES];</span>
<span class="nc" id="L491">        int myValue = pValue;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        for (int i = Short.BYTES; i &gt; 0; i--) {</span>
            /* Store the next byte */
<span class="nc" id="L494">            final byte myByte = (byte) (myValue &amp; BYTE_MASK);</span>
<span class="nc" id="L495">            myBytes[i - 1] = myByte;</span>

            /* Adjust value */
<span class="nc" id="L498">            myValue &gt;&gt;= BYTE_SHIFT;</span>
        }

        /* Return the value */
<span class="nc" id="L502">        return myBytes;</span>
    }

    /**
     * get Bytes from String.
     * @param pInput the bytes to obtain the string from
     * @return the bytes representing the bytes
     */
    public static String byteArrayToString(final byte[] pInput) {
<span class="nc" id="L511">        return new String(pInput, StandardCharsets.UTF_8);</span>
    }

    /**
     * get Bytes from String.
     * @param pInput the string to obtain the bytes from
     * @return the bytes representing the string
     */
    public static byte[] stringToByteArray(final String pInput) {
<span class="nc" id="L520">        return pInput.getBytes(StandardCharsets.UTF_8);</span>
    }

    /**
     * Convert a byte array to a Base64 string.
     * @param pBytes the byte array (not null)
     * @return the translated Base64 string (not null)
     */
    public static String byteArrayToBase64(final byte[] pBytes) {
        /* Determine input length and allocate output buffer */
<span class="nc" id="L530">        final int myLen = pBytes.length;</span>
<span class="nc" id="L531">        final StringBuilder myBuilder = new StringBuilder(myLen &lt;&lt; 1);</span>
<span class="nc" id="L532">        final byte[] myTriplet = new byte[BASE64_TRIPLE];</span>

        /* Loop through the input bytes */
<span class="nc" id="L535">        int myIn = 0;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        while (myIn &lt; myLen) {</span>
            /* Access input triplet */
<span class="nc" id="L538">            myTriplet[0] = pBytes[myIn++];</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">            myTriplet[1] = myIn &lt; myLen</span>
<span class="nc" id="L540">                                        ? pBytes[myIn++]</span>
<span class="nc" id="L541">                                        : 0;</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            myTriplet[2] = myIn &lt; myLen</span>
<span class="nc" id="L543">                                        ? pBytes[myIn++]</span>
<span class="nc" id="L544">                                        : 0;</span>

            /* Convert to base64 */
<span class="nc" id="L547">            myBuilder.append(BASE64_ENCODE[(myTriplet[0] &gt;&gt; BASE64_SHIFT1)</span>
                                           &amp; BASE64_MASK]);
<span class="nc" id="L549">            myBuilder.append(BASE64_ENCODE[((myTriplet[0] &lt;&lt; BASE64_SHIFT2) | ((myTriplet[1] &amp; BYTE_MASK) &gt;&gt; BASE64_SHIFT2))</span>
                                           &amp; BASE64_MASK]);
<span class="nc" id="L551">            myBuilder.append(BASE64_ENCODE[((myTriplet[1] &lt;&lt; BASE64_SHIFT1) | ((myTriplet[2] &amp; BYTE_MASK) &gt;&gt; BASE64_SHIFT3))</span>
                                           &amp; BASE64_MASK]);
<span class="nc" id="L553">            myBuilder.append(BASE64_ENCODE[myTriplet[2]</span>
                                           &amp; BASE64_MASK]);
        }

        /* Handle short input */
<span class="nc" id="L558">        int myXtra = myLen</span>
                     % myTriplet.length;
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (myXtra &gt; 0) {</span>
            /* Determine padding length */
<span class="nc" id="L562">            myXtra = myTriplet.length</span>
                     - myXtra;

            /* Remove redundant characters */
<span class="nc" id="L566">            myBuilder.setLength(myBuilder.length()</span>
                                - myXtra);

            /* Replace with padding character */
<span class="nc bnc" id="L570" title="All 2 branches missed.">            while (myXtra-- &gt; 0) {</span>
<span class="nc" id="L571">                myBuilder.append(BASE64_PAD);</span>
            }
        }

        /* Convert chars to string */
<span class="nc" id="L576">        return myBuilder.toString();</span>
    }

    /**
     * Convert a Base64 string into a byte array.
     * @param pBase64 the Base64 string (not null)
     * @return the byte array (not null)
     */
    public static byte[] base64ToByteArray(final String pBase64) {
        /* Access input as chars */
<span class="nc" id="L586">        final char[] myBase64 = pBase64.toCharArray();</span>
<span class="nc" id="L587">        final int myLen = myBase64.length;</span>

        /* Determine number of padding bytes */
<span class="nc" id="L590">        int myNumPadding = 0;</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">        if (myBase64[myLen - 1] == BASE64_PAD) {</span>
<span class="nc" id="L592">            myNumPadding++;</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">            if (myBase64[myLen - 2] == BASE64_PAD) {</span>
<span class="nc" id="L594">                myNumPadding++;</span>
            }
        }

        /* Allocate the output buffer and index */
<span class="nc" id="L599">        final int myOutLen = ((myLen * BASE64_TRIPLE) &gt;&gt; 2)</span>
                             - myNumPadding;
<span class="nc" id="L601">        final byte[] myOutput = new byte[myOutLen];</span>

        /* Loop through the base64 input */
<span class="nc" id="L604">        int myIn = 0;</span>
<span class="nc" id="L605">        int myOut = 0;</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        while (myOut &lt; myOutLen) {</span>
            /* Build first byte */
<span class="nc" id="L608">            final int c0 = BASE64_DECODE[myBase64[myIn++]];</span>
<span class="nc" id="L609">            final int c1 = BASE64_DECODE[myBase64[myIn++]];</span>
<span class="nc" id="L610">            myOutput[myOut++] = (byte) (((c0 &lt;&lt; BASE64_SHIFT1) | (c1 &gt;&gt; BASE64_SHIFT2)) &amp; BYTE_MASK);</span>

            /* Build second byte */
<span class="nc bnc" id="L613" title="All 2 branches missed.">            if (myOut &lt; myOutLen) {</span>
<span class="nc" id="L614">                final int c2 = BASE64_DECODE[myBase64[myIn++]];</span>
<span class="nc" id="L615">                myOutput[myOut++] = (byte) (((c1 &lt;&lt; BASE64_SHIFT2) | (c2 &gt;&gt; BASE64_SHIFT1)) &amp; BYTE_MASK);</span>

                /* Build third byte */
<span class="nc bnc" id="L618" title="All 2 branches missed.">                if (myOut &lt; myOutLen) {</span>
<span class="nc" id="L619">                    final int c3 = BASE64_DECODE[myBase64[myIn++]];</span>
<span class="nc" id="L620">                    myOutput[myOut++] = (byte) (((c2 &lt;&lt; BASE64_SHIFT3) | c3) &amp; BYTE_MASK);</span>
                }
            }
<span class="nc" id="L623">        }</span>
<span class="nc" id="L624">        return myOutput;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
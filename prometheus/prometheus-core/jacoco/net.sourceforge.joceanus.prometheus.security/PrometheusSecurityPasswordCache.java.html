<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PrometheusSecurityPasswordCache.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Prometheus Core Application Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.prometheus.security</a> &gt; <span class="el_source">PrometheusSecurityPasswordCache.java</span></div><h1>PrometheusSecurityPasswordCache.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Prometheus: Application Framework
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.prometheus.security;

import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.factory.GordianFactory;
import net.sourceforge.joceanus.gordianknot.api.factory.GordianFactory.GordianFactoryLock;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPair;
import net.sourceforge.joceanus.gordianknot.api.keyset.GordianBadCredentialsException;
import net.sourceforge.joceanus.gordianknot.api.keyset.GordianKeySet;
import net.sourceforge.joceanus.gordianknot.api.keyset.GordianKeySetFactory;
import net.sourceforge.joceanus.gordianknot.api.lock.GordianKeyPairLock;
import net.sourceforge.joceanus.gordianknot.api.lock.GordianKeySetLock;
import net.sourceforge.joceanus.gordianknot.api.lock.GordianLock;
import net.sourceforge.joceanus.gordianknot.api.lock.GordianLockFactory;
import net.sourceforge.joceanus.gordianknot.api.lock.GordianPasswordLockSpec;
import net.sourceforge.joceanus.oceanus.base.OceanusException;
import net.sourceforge.joceanus.oceanus.convert.OceanusDataConverter;
import net.sourceforge.joceanus.oceanus.logger.OceanusLogManager;
import net.sourceforge.joceanus.oceanus.logger.OceanusLogger;
import net.sourceforge.joceanus.prometheus.exc.PrometheusDataException;
import net.sourceforge.joceanus.prometheus.exc.PrometheusSecurityException;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

/**
 * Password Cache.
 */
public class PrometheusSecurityPasswordCache {
    /**
     * Logger.
     */
<span class="fc" id="L51">    private static final OceanusLogger LOGGER = OceanusLogManager.getLogger(PrometheusSecurityPasswordCache.class);</span>

    /**
     * Password failed message.
     */
    private static final String PASSWORD_FAIL = &quot;Password attempt failed&quot;;

    /**
     * List of resolved Locks.
     */
    private final List&lt;PrometheusLockCache&lt;?&gt;&gt; theLocks;

    /**
     * List of successful passwords.
     */
    private final List&lt;ByteBuffer&gt; thePasswords;

    /**
     * The Factory.
     */
    private final GordianFactory theFactory;

    /**
     * The KeySet Factory.
     */
    private final GordianKeySetFactory theKeySetFactory;

    /**
     * The lockFactory.
     */
    private final GordianLockFactory theLockFactory;

    /**
     * PasswordLockSpec.
     */
    private final GordianPasswordLockSpec theLockSpec;

    /**
     * Local keySet.
     */
    private final GordianKeySet theKeySet;

    /**
     * Constructor.
     * @param pManager the password manager
     * @param pLockSpec the passwordLockSpec
     * @throws OceanusException on error
     */
    PrometheusSecurityPasswordCache(final PrometheusSecurityPasswordManager pManager,
<span class="fc" id="L100">                                    final GordianPasswordLockSpec pLockSpec) throws OceanusException {</span>
        /* Protect against exceptions */
        try {
            /* Store factory and lockSpec*/
<span class="fc" id="L104">            theFactory = pManager.getSecurityFactory();</span>
<span class="fc" id="L105">            theKeySetFactory = theFactory.getKeySetFactory();</span>
<span class="fc" id="L106">            theLockFactory = theFactory.getLockFactory();</span>
<span class="fc" id="L107">            theLockSpec = pLockSpec;</span>

            /* Create a keySet */
<span class="fc" id="L110">            theKeySet = theKeySetFactory.generateKeySet(pLockSpec.getKeySetSpec());</span>

            /* Create the lists */
<span class="fc" id="L113">            theLocks = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L114">            thePasswords = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L116">        } catch (GordianException e) {</span>
<span class="nc" id="L117">            throw new PrometheusSecurityException(e);</span>
<span class="fc" id="L118">        }</span>
<span class="fc" id="L119">    }</span>

    /**
     * Add resolved factoryLock to cache.
     * @param pFactory the resolved FactoryLock
     * @param pPassword the password
     * @throws OceanusException on error
     */
    void addResolvedFactory(final GordianFactoryLock pFactory,
                            final char[] pPassword) throws OceanusException {
<span class="fc" id="L129">        byte[] myPasswordBytes = null;</span>
        try {
            /* Encrypt the password */
<span class="fc" id="L132">            myPasswordBytes = OceanusDataConverter.charsToByteArray(pPassword);</span>
<span class="fc" id="L133">            final byte[] myEncrypted = theKeySet.encryptBytes(myPasswordBytes);</span>

            /* Add the entry to the lists */
<span class="fc" id="L136">            final ByteBuffer myBuffer = ByteBuffer.wrap(myEncrypted);</span>
<span class="fc" id="L137">            theLocks.add(new PrometheusLockCache&lt;&gt;(pFactory, myBuffer));</span>
<span class="fc" id="L138">            thePasswords.add(myBuffer);</span>


<span class="nc" id="L141">        } catch (GordianException e) {</span>
<span class="nc" id="L142">            throw new PrometheusSecurityException(e);</span>

        } finally {
            /* Clear out password */
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">            if (myPasswordBytes != null) {</span>
<span class="fc" id="L147">                Arrays.fill(myPasswordBytes, (byte) 0);</span>
            }
        }
<span class="fc" id="L150">    }</span>

    /**
     * Add resolved keySetLock to cache.
     * @param pKeySet the resolved keySetLock
     * @param pPassword the password
     * @throws OceanusException on error
     */
    void addResolvedKeySet(final GordianKeySetLock pKeySet,
                           final char[] pPassword) throws OceanusException {
<span class="fc" id="L160">        byte[] myPasswordBytes = null;</span>
        try {
            /* Encrypt the password */
<span class="fc" id="L163">            myPasswordBytes = OceanusDataConverter.charsToByteArray(pPassword);</span>
<span class="fc" id="L164">            final byte[] myEncrypted = theKeySet.encryptBytes(myPasswordBytes);</span>

            /* Add the entry to the lists */
<span class="fc" id="L167">            final ByteBuffer myBuffer = ByteBuffer.wrap(myEncrypted);</span>
<span class="fc" id="L168">            theLocks.add(new PrometheusLockCache&lt;&gt;(pKeySet, myBuffer));</span>
<span class="fc" id="L169">            thePasswords.add(myBuffer);</span>

<span class="nc" id="L171">        } catch (GordianException e) {</span>
<span class="nc" id="L172">            throw new PrometheusSecurityException(e);</span>

        } finally {
            /* Clear out password */
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">            if (myPasswordBytes != null) {</span>
<span class="fc" id="L177">                Arrays.fill(myPasswordBytes, (byte) 0);</span>
            }
        }
<span class="fc" id="L180">    }</span>

    /**
     * Add resolved keyPairLock to cache.
     * @param pKeyPair the resolved keyPairLock
     * @param pPassword the password
     * @throws OceanusException on error
     */
    void addResolvedKeyPair(final GordianKeyPairLock pKeyPair,
                            final char[] pPassword) throws OceanusException {
<span class="nc" id="L190">        byte[] myPasswordBytes = null;</span>
        try {
            /* Encrypt the password */
<span class="nc" id="L193">            myPasswordBytes = OceanusDataConverter.charsToByteArray(pPassword);</span>
<span class="nc" id="L194">            final byte[] myEncrypted = theKeySet.encryptBytes(myPasswordBytes);</span>

            /* Add the entry to the lists */
<span class="nc" id="L197">            final ByteBuffer myBuffer = ByteBuffer.wrap(myEncrypted);</span>
<span class="nc" id="L198">            theLocks.add(new PrometheusLockCache&lt;&gt;(pKeyPair, myBuffer));</span>
<span class="nc" id="L199">            thePasswords.add(myBuffer);</span>

<span class="nc" id="L201">        } catch (GordianException e) {</span>
<span class="nc" id="L202">            throw new PrometheusSecurityException(e);</span>

        } finally {
            /* Clear out password */
<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (myPasswordBytes != null) {</span>
<span class="nc" id="L207">                Arrays.fill(myPasswordBytes, (byte) 0);</span>
            }
        }
<span class="nc" id="L210">    }</span>

    /**
     * LookUp previously resolved Factory.
     * @param pLockBytes the LockBytes to search for
     * @return the previous factoryLock if found, otherwise null
     */
    GordianFactoryLock lookUpResolvedFactoryLock(final byte[] pLockBytes) {
        /* Look for the factory in the list */
<span class="fc bfc" id="L219" title="All 2 branches covered.">        for (PrometheusLockCache&lt;?&gt; myCurr : theLocks) {</span>
            /* If this is the factoryLock we are looking for, return it */
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">            if (myCurr.getLock() instanceof GordianFactoryLock</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">                    &amp;&amp; Arrays.equals(pLockBytes, myCurr.getLock().getLockBytes())) {</span>
<span class="nc" id="L223">                return (GordianFactoryLock) myCurr.getLock();</span>
            }
<span class="fc" id="L225">        }</span>

        /* Return not found */
<span class="fc" id="L228">        return null;</span>
    }

    /**
     * LookUp previously resolved keySet.
     * @param pLockBytes the LockBytes to search for
     * @return the previous keySetLock if found, otherwise null
     */
    GordianKeySetLock lookUpResolvedKeySetLock(final byte[] pLockBytes) {
        /* Look for the keySet in the list */
<span class="fc bfc" id="L238" title="All 2 branches covered.">        for (PrometheusLockCache&lt;?&gt; myCurr : theLocks) {</span>
            /* If this is the keySetLock we are looking for, return it */
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            if (myCurr.getLock() instanceof GordianKeySetLock</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">                    &amp;&amp; Arrays.equals(pLockBytes, myCurr.getLock().getLockBytes())) {</span>
<span class="nc" id="L242">                return (GordianKeySetLock) myCurr.getLock();</span>
            }
<span class="fc" id="L244">        }</span>

        /* Return not found */
<span class="fc" id="L247">        return null;</span>
    }

    /**
     * LookUp previously resolved keyPair.
     * @param pLockBytes the LockBytes to search for
     * @param pKeyPair the keyPair
     * @return the previous keySetLock if found, otherwise null
     */
    GordianKeyPairLock lookUpResolvedKeyPairLock(final byte[] pLockBytes,
                                                 final GordianKeyPair pKeyPair) {
        /* Look for the keyPair in the list */
<span class="nc bnc" id="L259" title="All 2 branches missed.">        for (PrometheusLockCache&lt;?&gt; myCurr : theLocks) {</span>
            /* If this is the keyPairLock we are looking for, return it */
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (myCurr.getLock() instanceof GordianKeyPairLock</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                    &amp;&amp; Arrays.equals(pLockBytes, myCurr.getLock().getLockBytes())</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                    &amp;&amp; pKeyPair.equals(((GordianKeyPairLock) myCurr.getLock()).getKeyPair())) {</span>
<span class="nc" id="L264">                return (GordianKeyPairLock) myCurr.getLock();</span>
            }
<span class="nc" id="L266">        }</span>

        /* Return not found */
<span class="nc" id="L269">        return null;</span>
    }

    /**
     * LookUp previously resolved Password.
     * @param pReference the Reference to search for
     * @return the encrypted password
     * @throws OceanusException on error
     */
    ByteBuffer lookUpResolvedPassword(final Object pReference) throws OceanusException {
        /* If the reference is a lock */
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (pReference instanceof GordianLock) {</span>
            /* Look for the lock in the list */
<span class="fc" id="L282">            final GordianLock&lt;?&gt; myReference = (GordianLock&lt;?&gt;) pReference;</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            for (PrometheusLockCache&lt;?&gt; myCurr : theLocks) {</span>
                /* If this is the lock are looking for, return it */
<span class="fc bfc" id="L285" title="All 2 branches covered.">                if (Objects.equals(myReference, myCurr.getLock())) {</span>
<span class="fc" id="L286">                    return myCurr.getPassword();</span>
                }
<span class="fc" id="L288">            }</span>
        }

        /* Throw error */
<span class="nc" id="L292">        throw new PrometheusDataException(&quot;Referenced Object not known&quot;);</span>
    }

    /**
     * Attempt known passwords for factory lock.
     * @param pLockBytes the lockBytes to attempt passwords for
     * @return the new FactoryLock if successful, otherwise null
     */
    GordianFactoryLock attemptKnownPasswordsForFactoryLock(final byte[] pLockBytes) {
        /* Loop through the passwords */
<span class="fc bfc" id="L302" title="All 2 branches covered.">        for (ByteBuffer myCurr : thePasswords) {</span>
            /* Attempt the password */
<span class="fc" id="L304">            final GordianFactoryLock myFactory = attemptPasswordForFactoryLock(pLockBytes, myCurr.array());</span>

            /* If we succeeded */
<span class="fc bfc" id="L307" title="All 2 branches covered.">            if (myFactory != null) {</span>
                /* Add the factory to the list and return it */
<span class="fc" id="L309">                theLocks.add(new PrometheusLockCache&lt;&gt;(myFactory, myCurr));</span>
<span class="fc" id="L310">                return myFactory;</span>
            }
<span class="fc" id="L312">        }</span>

        /* Return null */
<span class="fc" id="L315">        return null;</span>
    }

    /**
     * Attempt the cached password against the passed lock.
     * @param pLockBytes the Lock to test against
     * @param pPassword the encrypted password
     * @return the new FactoryLock if successful, otherwise null
     */
    private GordianFactoryLock attemptPasswordForFactoryLock(final byte[] pLockBytes,
                                                             final byte[] pPassword) {
        /* Protect against exceptions */
<span class="fc" id="L327">        byte[] myPasswordBytes = null;</span>
<span class="fc" id="L328">        char[] myPasswordChars = null;</span>
        try {
            /* Access the original password */
<span class="fc" id="L331">            myPasswordBytes = theKeySet.decryptBytes(pPassword);</span>
<span class="fc" id="L332">            myPasswordChars = OceanusDataConverter.bytesToCharArray(myPasswordBytes);</span>

            /* Try to resolve the lock and return it */
<span class="fc" id="L335">            return theFactory.resolveFactoryLock(pLockBytes, myPasswordChars);</span>

            /* Catch Exceptions */
<span class="nc" id="L338">        } catch (GordianException</span>
                | OceanusException e) {
<span class="nc" id="L340">            LOGGER.error(PASSWORD_FAIL, e);</span>
<span class="nc" id="L341">            return null;</span>

<span class="fc" id="L343">        } catch (GordianBadCredentialsException e) {</span>
<span class="fc" id="L344">            return null;</span>

        } finally {
            /* Clear out password */
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">            if (myPasswordBytes != null) {</span>
<span class="fc" id="L349">                Arrays.fill(myPasswordBytes, (byte) 0);</span>
            }
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">            if (myPasswordChars != null) {</span>
<span class="fc" id="L352">                Arrays.fill(myPasswordChars, (char) 0);</span>
            }
        }
    }

    /**
     * Attempt known passwords for keySet lock.
     * @param pLockBytes the lockBytes to attempt passwords for
     * @return the new keySetLock if successful, otherwise null
     */
    GordianKeySetLock attemptKnownPasswordsForKeySetLock(final byte[] pLockBytes) {
        /* Loop through the passwords */
<span class="fc bfc" id="L364" title="All 2 branches covered.">        for (ByteBuffer myCurr : thePasswords) {</span>
            /* Attempt the password */
<span class="fc" id="L366">            final GordianKeySetLock myKeySet = attemptPasswordForKeySetLock(pLockBytes, myCurr.array());</span>

            /* If we succeeded */
<span class="fc bfc" id="L369" title="All 2 branches covered.">            if (myKeySet != null) {</span>
                /* Add the factory to the list and return it */
<span class="fc" id="L371">                theLocks.add(new PrometheusLockCache&lt;&gt;(myKeySet, myCurr));</span>
<span class="fc" id="L372">                return myKeySet;</span>
            }
<span class="fc" id="L374">        }</span>

        /* Return null */
<span class="fc" id="L377">        return null;</span>
    }

    /**
     * Attempt the cached password against the passed lock.
     * @param pLockBytes the Lock to test against
     * @param pPassword the encrypted password
     * @return the new keySetLock if successful, otherwise null
     */
    private GordianKeySetLock attemptPasswordForKeySetLock(final byte[] pLockBytes,
                                                           final byte[] pPassword) {
        /* Protect against exceptions */
<span class="fc" id="L389">        byte[] myPasswordBytes = null;</span>
<span class="fc" id="L390">        char[] myPasswordChars = null;</span>
        try {
            /* Access the original password */
<span class="fc" id="L393">            myPasswordBytes = theKeySet.decryptBytes(pPassword);</span>
<span class="fc" id="L394">            myPasswordChars = OceanusDataConverter.bytesToCharArray(myPasswordBytes);</span>

            /* Try to resolve the lock and return it */
<span class="fc" id="L397">            return theLockFactory.resolveKeySetLock(pLockBytes, myPasswordChars);</span>

            /* Catch Exceptions */
<span class="nc" id="L400">        } catch (GordianException</span>
                | OceanusException e) {
<span class="nc" id="L402">            LOGGER.error(PASSWORD_FAIL, e);</span>
<span class="nc" id="L403">            return null;</span>

<span class="fc" id="L405">        } catch (GordianBadCredentialsException e) {</span>
<span class="fc" id="L406">            return null;</span>

        } finally {
            /* Clear out password */
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">            if (myPasswordBytes != null) {</span>
<span class="fc" id="L411">                Arrays.fill(myPasswordBytes, (byte) 0);</span>
            }
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">            if (myPasswordChars != null) {</span>
<span class="fc" id="L414">                Arrays.fill(myPasswordChars, (char) 0);</span>
            }
        }
    }

    /**
     * Attempt known passwords for keyPair lock.
     * @param pLockBytes the lockBytes to attempt passwords for
     * @param pKeyPair the keyPair
     * @return the new keyPairLock if successful, otherwise null
     */
    GordianKeyPairLock attemptKnownPasswordsForKeyPairLock(final byte[] pLockBytes,
                                                           final GordianKeyPair pKeyPair) {
        /* Loop through the passwords */
<span class="nc bnc" id="L428" title="All 2 branches missed.">        for (ByteBuffer myCurr : thePasswords) {</span>
            /* Attempt the password */
<span class="nc" id="L430">            final GordianKeyPairLock myKeyPair = attemptPasswordForKeyPairLock(pLockBytes, pKeyPair, myCurr.array());</span>

            /* If we succeeded */
<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (myKeyPair != null) {</span>
                /* Add the factory to the list and return it */
<span class="nc" id="L435">                theLocks.add(new PrometheusLockCache&lt;&gt;(myKeyPair, myCurr));</span>
<span class="nc" id="L436">                return myKeyPair;</span>
            }
<span class="nc" id="L438">        }</span>

        /* Return null */
<span class="nc" id="L441">        return null;</span>
    }

    /**
     * Attempt the cached password against the passed lock.
     * @param pLockBytes the Lock to test against
     * @param pKeyPair the keyPair
     * @param pPassword the encrypted password
     * @return the new keyPairLock if successful, otherwise null
     */
    private GordianKeyPairLock attemptPasswordForKeyPairLock(final byte[] pLockBytes,
                                                             final GordianKeyPair pKeyPair,
                                                             final byte[] pPassword) {
        /* Protect against exceptions */
<span class="nc" id="L455">        byte[] myPasswordBytes = null;</span>
<span class="nc" id="L456">        char[] myPasswordChars = null;</span>
        try {
            /* Access the original password */
<span class="nc" id="L459">            myPasswordBytes = theKeySet.decryptBytes(pPassword);</span>
<span class="nc" id="L460">            myPasswordChars = OceanusDataConverter.bytesToCharArray(myPasswordBytes);</span>

            /* Try to resolve the lock and return it */
<span class="nc" id="L463">            return theLockFactory.resolveKeyPairLock(pLockBytes, pKeyPair, myPasswordChars);</span>

            /* Catch Exceptions */
<span class="nc" id="L466">        } catch (GordianException</span>
                | OceanusException e) {
<span class="nc" id="L468">            LOGGER.error(PASSWORD_FAIL, e);</span>
<span class="nc" id="L469">            return null;</span>

<span class="nc" id="L471">        } catch (GordianBadCredentialsException e) {</span>
<span class="nc" id="L472">            return null;</span>

        } finally {
            /* Clear out password */
<span class="nc bnc" id="L476" title="All 2 branches missed.">            if (myPasswordBytes != null) {</span>
<span class="nc" id="L477">                Arrays.fill(myPasswordBytes, (byte) 0);</span>
            }
<span class="nc bnc" id="L479" title="All 2 branches missed.">            if (myPasswordChars != null) {</span>
<span class="nc" id="L480">                Arrays.fill(myPasswordChars, (char) 0);</span>
            }
        }
    }

    /**
     * Create a factoryLock with a previously used password.
     * @param pFactory the new factory
     * @param pPassword the encrypted password
     * @return the new factoryLock
     * @throws OceanusException on error
     */
    GordianFactoryLock createSimilarFactoryLock(final GordianFactory pFactory,
                                                final ByteBuffer pPassword) throws OceanusException {
        /* Protect against exceptions */
<span class="fc" id="L495">        byte[] myPasswordBytes = null;</span>
<span class="fc" id="L496">        char[] myPasswordChars = null;</span>
        try {
            /* Access the original password */
<span class="fc" id="L499">            myPasswordBytes = theKeySet.decryptBytes(pPassword.array());</span>
<span class="fc" id="L500">            myPasswordChars = OceanusDataConverter.bytesToCharArray(myPasswordBytes);</span>

            /* Create the new lock */
<span class="fc" id="L503">            final GordianFactoryLock myLock = theFactory.newFactoryLock(pFactory, theLockSpec, myPasswordChars);</span>

            /* Add the entry to the list and return the hash */
<span class="fc" id="L506">            theLocks.add(new PrometheusLockCache&lt;&gt;(myLock, pPassword));</span>
<span class="fc" id="L507">            return myLock;</span>

<span class="nc" id="L509">        } catch (GordianException e) {</span>
<span class="nc" id="L510">            throw new PrometheusSecurityException(e);</span>

        } finally {
            /* Clear out password */
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">            if (myPasswordBytes != null) {</span>
<span class="fc" id="L515">                Arrays.fill(myPasswordBytes, (byte) 0);</span>
            }
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">            if (myPasswordChars != null) {</span>
<span class="fc" id="L518">                Arrays.fill(myPasswordChars, (char) 0);</span>
            }
        }
    }

    /**
     * Create a keySetLock with a previously used password.
     * @param pKeySet the new keySet
     * @param pPassword the encrypted password
     * @return the new factoryLock
     * @throws OceanusException on error
     */
    GordianKeySetLock createSimilarKeySetLock(final GordianKeySet pKeySet,
                                              final ByteBuffer pPassword) throws OceanusException {
        /* Protect against exceptions */
<span class="fc" id="L533">        byte[] myPasswordBytes = null;</span>
<span class="fc" id="L534">        char[] myPasswordChars = null;</span>
        try {
            /* Access the original password */
<span class="fc" id="L537">            myPasswordBytes = theKeySet.decryptBytes(pPassword.array());</span>
<span class="fc" id="L538">            myPasswordChars = OceanusDataConverter.bytesToCharArray(myPasswordBytes);</span>

            /* Create the new lock */
<span class="fc" id="L541">            final GordianKeySetLock myLock = theLockFactory.newKeySetLock(pKeySet, theLockSpec, myPasswordChars);</span>

            /* Add the entry to the list and return the hash */
<span class="fc" id="L544">            theLocks.add(new PrometheusLockCache&lt;&gt;(myLock, pPassword));</span>
<span class="fc" id="L545">            return myLock;</span>

<span class="nc" id="L547">        } catch (GordianException e) {</span>
<span class="nc" id="L548">            throw new PrometheusSecurityException(e);</span>

        } finally {
            /* Clear out password */
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">            if (myPasswordBytes != null) {</span>
<span class="fc" id="L553">                Arrays.fill(myPasswordBytes, (byte) 0);</span>
            }
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">            if (myPasswordChars != null) {</span>
<span class="fc" id="L556">                Arrays.fill(myPasswordChars, (char) 0);</span>
            }
        }
    }

    /**
     * Create a zipLock with a previously used password.
     * @param pKeyPair the keyPair
     * @param pPassword the encrypted password
     * @return the new PasswordHash
     * @throws OceanusException on error
     */
    GordianKeyPairLock createSimilarKeyPairLock(final GordianKeyPair pKeyPair,
                                                final ByteBuffer pPassword) throws OceanusException {
        /* Protect against exceptions */
<span class="nc" id="L571">        byte[] myPasswordBytes = null;</span>
<span class="nc" id="L572">        char[] myPasswordChars = null;</span>
        try {
            /* Access the original password */
<span class="nc" id="L575">            myPasswordBytes = theKeySet.decryptBytes(pPassword.array());</span>
<span class="nc" id="L576">            myPasswordChars = OceanusDataConverter.bytesToCharArray(myPasswordBytes);</span>

            /* Create the similar passwordLock and return it */
<span class="nc" id="L579">            return theLockFactory.newKeyPairLock(theLockSpec, pKeyPair, myPasswordChars);</span>

<span class="nc" id="L581">        } catch (GordianException e) {</span>
<span class="nc" id="L582">            throw new PrometheusSecurityException(e);</span>

        } finally {
            /* Clear out password */
<span class="nc bnc" id="L586" title="All 2 branches missed.">            if (myPasswordBytes != null) {</span>
<span class="nc" id="L587">                Arrays.fill(myPasswordBytes, (byte) 0);</span>
            }
<span class="nc bnc" id="L589" title="All 2 branches missed.">            if (myPasswordChars != null) {</span>
<span class="nc" id="L590">                Arrays.fill(myPasswordChars, (char) 0);</span>
            }
        }
    }

    /**
     * The lockCache.
     * @param &lt;T&gt; the locked object
     *
     */
    static class PrometheusLockCache&lt;T&gt; {
        /**
         * The FactoryLock.
         */
        private final GordianLock&lt;T&gt; theLock;

        /**
         * The Encrypted password.
         */
        private final ByteBuffer thePassword;

        /**
         * Constructor.
         * @param pLock the Lock
         * @param pPassword the encrypted password
         */
        PrometheusLockCache(final GordianLock&lt;T&gt; pLock,
<span class="fc" id="L617">                            final ByteBuffer pPassword) {</span>
<span class="fc" id="L618">            theLock = pLock;</span>
<span class="fc" id="L619">            thePassword = pPassword;</span>
<span class="fc" id="L620">        }</span>

        /**
         * Obtain the lock.
         * @return the Lock
         */
        GordianLock&lt;T&gt; getLock() {
<span class="fc" id="L627">            return theLock;</span>
        }

        /**
         * Obtain the encrypted password.
         * @return the password
         */
        ByteBuffer getPassword() {
<span class="fc" id="L635">            return thePassword;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
# GordianKnot Symmetric Block Ciphers

## Overview
Block Ciphers are supported via the **GordianCipherFactory** interface.

GordianKnot supports most Symmetric Block Ciphers available from BouncyCastle plus some additional ciphers.

A cipher for block encryption/decryption is created by specifying a **GordianSymCipherSpec** which comprises
the **GordianSymKeySpec** (algorithm/blockSize/keySize) with the cipherMode and padding (if required).
The cipher can be used in much the same way as a JCA Cipher, allowing init, update and finalise methods.

A cipher for blockCipher keyWrapping is created by specifying the symKey. The cipher allows init, secure and derive methods.
A keyGenerator for a **GordianSymKeySpec** can be created, which can be used to generate random keys for the keySpec.
JCA provides a subset of available algorithms as indicated

## Key Generation
Algorithms are represented by **GordianSymKeySpec**. A **GordianKeyGenerator** is obtained via the keySpec,
and then keys are generated by the generator.

### Sample
```
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

/* Access keyGenerator */
final GordianSymKeySpec mySpec = GordianSymKeySpecBuilder.aes(GordianLength.LEN_256);
final GordianKeyGenerator<GordianSymKeySpec> myGenerator = myCipherFactory.getKeyGenerator(mySpec);
final GordianKey<GordianSymKeySpec> myKey = myGenerator.generateKey();
```

## Algorithms
The following symKey algorithms are supported.

<table class="defTable">
  <tr><th class="defHdr" rowspan="2">Algorithm</th><th class="defHdr" rowspan="2">BlockSize</th><th class="defHdr" rowspan="2">JCA</th><th class="defHdr" colspan="5">KeySize</th></tr>
  <tr><th class="defHdr">128</th><th class="defHdr">192</th><th class="defHdr">256</th><th class="defHdr">512</th><th class="defHdr">1024</th></tr>
  <!--<tr><th class="defHdr">Algorithm</th><th class="defHdr">BlockSize</th><th class="defHdr">JCA</th>
      <th class="defHdr">128</th><th class="defHdr">192</th><th class="defHdr">256</th><th class="defHdr">512</th><th class="defHdr">1024</th></tr>-->
  <tr><td>AES</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>Serpent</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>TwoFish</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>Camellia</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>CAST6</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>RC6</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>ARIA</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td rowspan="2">Kalyna</td><td>128</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/></tr>
  <tr><td>256</td><td>Y</td><td/><td/><td>Y</td><td>Y</td><td/></tr>
  <tr><td>Kuznyechik</td><td>128</td><td>Y</td><td/><td/><td>Y</td><td/><td/></tr>
  <tr><td>ThreeFish</td><td>256</td><td>Y</td><td/><td/><td>Y</td><td>Y</td><td>Y</td></tr>
  <tr><td>NoeKeon</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td>SM4</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td>SEED</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td>SKIPJACK</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td>BlowFish</td><td>64</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>RC2</td><td>64</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
  <tr><td>DESede</td><td>64</td><td>Y</td><td>Y</td><td>Y</td><td/><td/><td/></tr>
  <tr><td>CAST5</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td rowspan="2">RC5</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td>128</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td>IDEA</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td>TEA</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td>XTEA</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td>Magma</td><td>64</td><td>Y</td><td/><td/><td>Y</td><td/><td/></tr>
  <tr><td>SHACAL2</td><td>256</td><td>Y</td><td/><td/><td>Y</td><td>Y</td><td/></tr>
  <tr><td>Speck</td><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>Simon</td><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>MARS</td><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>Anubis</td><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>LEA</td><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
</table>
             
## Cipher Usage
Cipher Algorithms are represented by **GordianSymCipherSpec**. A **GordianSymCipher** is obtained via the cipherSpec,
and then messages are encrypted/decrypted by the cipher.

### Sample
```
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

/* Create key */
final GordianSymKeySpec myKeySpec = GordianSymKeySpecBuilder.aes(GordianLength.LEN_256);
final GordianKeyGenerator<GordianSymKeySpec> myGenerator = myCipherFactory.getKeyGenerator(myKeySpec);
final GordianKey<GordianSymKeySpec> myKey = myGenerator.generateKey();

/* Create cipher */
final GordianSymCipherSpec myCipherSpec = GordianSymCipherSpecBuilder.cbc(myKeySpec, GordianPadding.PKCS7);
final GordianSymCipher myCipher = myCipherFactory.createSymKeyCipher(myCipherSpec);

/* Encrypt message with random nonce */
GordianCipherParameters myParams = GordianCipherParameters.keyWithRandomNonce(myKey);
myCipher.initForEncrypt(myParams);
final byte[] myMessage = ...
int myOutLen = myCipher.getOutputLength(myMessage.length);
final byte[] myEncrypted = new byte[myOutLen];
int myProcessed = myCipher.update(myMessage, 0, myMessage.length, myEncrypted);
myCipher.finish(myEncrypted, myProcessed);

/* Decrypt message */
myParams = GordianCipherParameters.keyWithNonce(myKey, myCipher.getNonce());
myCipher.initForDecrypt(myParams);
myOutLen = myCipher.getOutputLength(myEncrypted.length);
final byte[] myResult = new byte[myOutLen];
myProcessed = myCipher.update(myEncrypted, 0, myEncrypted.length, myResult);
myCipher.finish(myResult, myProcessed);
```                

### Cipher Modes
The following modes can be used
<table class="defTable">
  <tr><th class="defHdr">Mode</th><th class="defHdr">JCA</th><th class="defHdr">Notes</th></tr>
  <tr><td>ECB</td><td>Y</td><td/></tr>
  <tr><td>CBC</td><td>Y</td><td>JCA does not support for Kuznyechik</td></tr>
  <tr><td>G3413CBC</td><td>Y</td><td>Only available for Kuznyechik</td></tr>
  <tr><td>SIC</td><td>Y</td><td/></tr>
  <tr><td>KCTR</td><td>Y</td><td>Only available for Kalyna</td></tr>
  <tr><td>G3413CTR</td><td>Y</td><td>Only available for Kuznyechik</td></tr>
  <tr><td>OFB</td><td>Y</td><td>Jca does not support for Magma and Kuznyechik</td></tr>
  <tr><td>GOFB</td><td/><td>Only available for Magma</td></tr>
  <tr><td>G3413OFB</td><td>Y</td><td>Only available for Kuznyechik</td></tr>
  <tr><td>CFB</td><td>Y</td><td>Jca does not support for Magma and Kuznyechik</td></tr>
  <tr><td>GCFB</td><td/><td>Only available for Magma</td></tr>
  <tr><td>G3413CFB</td><td>Y</td><td>Only available for Kuznyechik</td></tr>
  <tr><td>CCM</td><td>Y</td><td>Jca does not support for Kalyna</td></tr>
  <tr><td>KCCM</td><td/><td>Only available for Kalyna</td></tr>
  <tr><td>GCM</td><td>Y</td><td>Jca does not support for Kalyna</td></tr>
  <tr><td>KGCM</td><td/><td>Only available for Kalyna</td></tr>
  <tr><td>EAX</td><td>Y</td><td/></tr>
  <tr><td>OCB</td><td>Y</td><td>JCA does not support for Kuznyechik or Kalyna</td></tr>
  <tr><td>GCMSIV</td><td/><td>Only available for 128-bit/256-bit keys and 128-bit blocks</td></tr>
</table>

### Padding
The following paddings can be used for ECB and CBC modes
<table class="defTable">
  <tr><th class="defHdr">Padding</th><th class="defHdr">JCA</th><th class="defHdr">Notes</th></tr>
  <tr><td>CTS</td><td>Y</td><td/></tr>
  <tr><td>ISO7816-4</td><td>Y</td><td/></tr>
  <tr><td>PKCS7</td><td>Y</td><td/></tr>
  <tr><td>X9.63</td><td>Y</td><td/></tr>
  <tr><td>TBC</td><td>Y</td><td/></tr>
  <tr><td>NONE</td><td>Y</td><td>Implicitly used for modes other than ECB/CBC</td></tr>
</table>
 
## Key Wrapping
Key Wrapping is performed by GordianKnot using a variant of the AES Key Wrapping algorithm specified in <a href="https://tools.ietf.org/html/rfc5649">RFC 5649</a>
The differences are necessary to enable support of ciphers that do not have the standard blockSize of 128 bits, since RFC 5649 assumes a 128 bit blockSize.
1. For blockSizes of 256 bits, the 32-bit Integrity Vector of **0xA65959A6** is expanded to the 96-bit **0xA65959A6A65959A6A65959A6** 
so that when combined with the 32-bit dataLen of the wrapped data it comprises the half-block needed for the wrapping algorithm.
This method can be extended to support any block size >= 128.
2. For blockSizes of 64, the Integrity Vector using the above adjustment becomes zero length, which is not very useful. In this case, we retain the
standard 32-bit	Integrity Vector of **0xA65959A6** and prefix the 32-bit dataLen to the data to be wrapped.
            
In addition, a block of random data is inserted immediately prior to the data to be wrapped.
### Sample
```
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

/* Create keys */
final GordianSymKeySpec myKeySpec = GordianSymKeySpecBuilder.aes(GordianLength.LEN_256);
final GordianKeyGenerator<GordianSymKeySpec> myGenerator = myCipherFactory.getKeyGenerator(myKeySpec);
final GordianKey<GordianSymKeySpec> myKey = myGenerator.generateKey();
final GordianKey<GordianSymKeySpec> myKeyToWrap = myGenerator.generateKey();

/* Create keyWrapper */
final GordianKeyWrapper myWrapper = myCipherFactory.createKeyWrapper(myKey);

/* Secure key */
final byte[] myWrapped = myWrapper.secureKey(myKeyToWrap);

/* Derive Key */
final GordianKey<GordianSymKeySpec> myResult = myWrapper.deriveKey(myWrapped, myKeySpec);
```


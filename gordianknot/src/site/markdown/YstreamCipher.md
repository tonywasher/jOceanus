# GordianKnot Symmetric Stream Ciphers

## Overview
Stream Ciphers are supported via the **GordianCipherFactory** interface.

GordianKnot supports most Symmetric Stream Ciphers available from BouncyCastle plus some additional ciphers.

A key for stream encryption is created by specifying the algorithm and keySize as a **GordianStreamKeySpec**.

A cipher for stream encryption is created by specifying the **GordianStreamKeySpec** (plus variant details eg AEAD)
as a **GordianStreamCipherSpec** and can be used similarly to a blockCipher.

A keyGenerator for a **GordianStreamKeySpec** can be created, which can be used to generate random keys for the keySpec

JCA provides a subset of available algorithms as indicated

## Key Generation
Algorithms are represented by **GordianSymKeySpec**. A **GordianKeyGenerator** is obtained via the keySpec,
and then keys are generated by the generator.

### Sample
```
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

/* Access keyGenerator */
final GordianStreamKeySpec mySpec = GordianStreamKeySpecBuilder.hc(GordianLength.LEN_256);
final GordianKeyGenerator&lt;GordianStreamKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(mySpec);
final GordianKey&lt;GordianStreamKeySpec&gt; myKey = myGenerator.generateKey();
```
            
## Algorithms
The following streamKey algorithms are supported.
<table class="defTable">
  <tr><th class="defHdr" rowspan="2">Algorithm</th><th class="defHdr" rowspan="2">Variant</th><th class="defHdr" rowspan="2">JCA</th>
      <th class="defHdr" colspan="5">KeySize</th><td class="defHdr" rowspan="2">Notes</td></tr>
  <tr><th class="defHdr">128</th><td class="defHdr">192</td><th class="defHdr">256</th><th class="defHdr">512</th><th class="defHdr">1024</th></tr>
  <tr><td rowspan="3">ChaCha20</td><td>Standard</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/><td/></tr>
  <tr><td>ChaCha7359</td><td>Y</td><td/><td/><td>Y</td><td/><td/><td/></tr>
  <tr><td>XChaCha20</td><td/><td/><td/><td>Y</td><td/><td/><td/></tr>
  <tr><td rowspan="2">Salsa20</td><td>Standard</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/><td/></tr>
  <tr><td>XSalsa20</td><td>Y</td><td/><td/><td>Y</td><td/><td/><td/></tr>
  <tr><td>HC</td><td/><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/><td>HC128/HC256 as appropriate</td></tr>
  <tr><td>VMPC</td><td>Standard KSA3</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
  <tr><td>ISAAC</td><td/><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
  <tr><td>RC4</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
  <tr><td>Grain128</td><td/><td>Y</td><td>Y</td><td/><td/><td/><td/><td/></tr>
  <tr><td>Rabbit</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
  <tr><td>Sosemanuk</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
  <tr><td>Snow3G</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
  <tr><td>Zuc</td><td/><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/><td>Zuc-128/Zuc-256 as appropriate</td></tr>
  <tr><td rowspan="3">SkeinXof</td><td>Skein-256</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
  <tr><td>Skein-512</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
  <tr><td>Skein-1024</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
  <tr><td rowspan="2">Blake2X</td><td>Blake2Xs</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/><td/></tr>
  <tr><td>Blake2Xb</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
  <tr><td>Blake3Xof</td><td/><td/><td/><td/><td>Y</td><td/><td/><td/></tr>
  <tr><td>Ascon</td><td>128, 128A</td><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
  <tr><td>Elephant</td><td>160, 176, 200</td><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
  <tr><td>ISAP</td><td>A128, A128A, K128, K128A</td><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
  <tr><td>PhotonBeetle</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
  <tr><td rowspan="3">Sparkle</td><td>128_128, 256_128</td><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
  <tr><td>192_192</td><td/><td/><td>Y</td><td/><td/><td/><td/></tr>
  <tr><td>256_256</td><td/><td/><td/><td>Y</td><td/><td/><td/></tr>
  <tr><td>Xoodyak</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
</table>

## Cipher Usage
Cipher Algorithms are represented by **GordianStreamCipherSpec**. A **GordianStreamCipher** is obtained via the cipherSpec,
and then messages are encrypted/decrypted by the cipher.
### Sample
```
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

/* Create key */
final GordianStreamKeySpec myKeySpec = GordianStreamKeySpecBuilder.hc(GordianLength.LEN_256);
final GordianKeyGenerator<GordianStreamKeySpec> myGenerator = myCipherFactory.getKeyGenerator(myKeySpec);
final GordianKey<GordianStreamKeySpec> myKey = myGenerator.generateKey();

/* Create cipher */
final GordianStreamCipherSpec myCipherSpec = GordianStreamCipherSpecBuilder.stream(myKeySpec);
final GordianStreamCipher myCipher = myCipherFactory.createStreamKeyCipher(myCipherSpec);

/* Encrypt message with random nonce */
GordianCipherParameters myParams = GordianCipherParameters.keyWithRandomNonce(myKey);
myCipher.initForEncrypt(myParams);
final byte[] myMessage = ...
int myOutLen = myCipher.getOutputLength(myMessage.length);
final byte[] myEncrypted = new byte[myOutLen];
int myProcessed = myCipher.update(myMessage, 0, myMessage.length, myEncrypted);
myCipher.finish(myEncrypted, myProcessed);

/* Decrypt message */
myParams = GordianCipherParameters.keyWithNonce(myKey, myCipher.getNonce());
myCipher.initForDecrypt(myParams);
myOutLen = myCipher.getOutputLength(myEncrypted.length);
final byte[] myResult = new byte[myOutLen];
myProcessed = myCipher.update(myEncrypted, 0, myEncrypted.length, myResult);
myCipher.finish(myResult, myProcessed);
```

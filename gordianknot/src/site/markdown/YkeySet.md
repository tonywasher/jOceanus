# GordianKnot KeySets

## Overview
KeySets are supported via the **GordianKeySetFactory** interface.

GordianKnot supports the notion of a KeySet, which is a set of keys of each available algorithm with a 128-bit blockSize.
The keySet may be used to encrypt/decrypt and to secure/derive keys or keySets
        
## KeySet Generation
A keySet can be generated by specifying a **GordianKeySetSpec**. Each key in the keySet is generated randomly.

### Sample
```
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

/* Create keySet */
final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);
```

## KeySet Derivation
The keySet derivation algorithm that generates each of the keys **K<sub>A</sub>** for an algorithm **A**
from a secret **S** is as follows.
1. Obtain a seed **X** from the first 4 bytes of **S** and obtain a seeded random **R** using
                    **X** and **P<sub>1</sub>**
2. Obtain a set of two distinct HMACs **H<sub>1</sub>** and **H<sub>2</sub>** from the seededRandom **R**
3. Use HKDF with the two HMACs to expand the result **S** into **K<sub>A</sub>**.
Use the following info to personalise and differentiate the keys.
                    
    1. Algorithm Name
    2. Key Length
    3. 8 bytes from seeded random
    4. Personalisation value **P**
    5. Personalisation value **I** 

## KeySet Encryption

### Algorithm
Encryption works by selecting a subSet of the available keys and encrypting the message using each key in turn. The number of keys selected and
hence the number of encryption steps is specified in the **GordianKeySetSpec** and can vary betweeen 3 and 6

1. A random 32-bit seed **S** and a random 128-bit initVector **V** are generated.
2. A subSet of **n** keys is selected (all different) using a seededRandom based on **S** and the personalisation value
**I<sub>2</sub>**
3. Two initiation vectors **V<sub>1</sub>** and **V<sub>2</sub>** are calculated by xor-ing **V** with
**IV<sub>1</sub>** and **IV<sub>2</sub>** respectively
4. The first encryption is performed on the message **M** using **K<sub>1</sub>** in **SIC** mode
using **V<sub>1</sub>** as the initialisation vector to create **C<sub>1</sub>**
5. The second encryption is performed on **C<sub>1</sub>** using **K<sub>2</sub>** in
**ECB** mode with **PKCS7** padding to create **C<sub>2</sub>**
6. Further intermediate encryptions are performed on **C<sub>x-1</sub>** using **K<sub>x</sub>**
in **ECB** mode with no padding to produce **C<sub>x</sub>**.
7. The final encryption is performed on **C<sub>n-1</sub>** using **K<sub>n</sub>** in **SIC** mode
using **V<sub>2</sub>** as the initialisation vector to create **C<sub>n</sub>**
8. The result is the concatenation of **S||V||C<sub>n</sub>**

### Sample
```
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

/* Create keySet */
final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);

/* Encrypt data as one-off */
final byte[] myMessage = ...
byte[] myEncrypted = myKeySet.encryptBytes(myMessage);
byte[] myResult = myKeySet.decryptBytes(myEncrypted);

/* Encrypt data as cipher */
final GordianKeySetCipher myCipher = myKeySet.createCipher();
myCipher.initForEncrypt();
myEncrypted = myCipher.finish(myMessage, 0, myMessage.length);
myCipher.initForDecrypt();
myResult = myCipher.finish(myEncrypted, 0, myEncrypted.length);
```

## KeySet AAD Encryption

### Algorithm
AAD is supported by calculating a Mac and appending it to the encrypted cipherText. On decryption the Mac is recalculated and compared to
the trailing bytes of the cipherText. Encryption works as per normal and the only difference is in the calculation of the Mac.
The Mac used is a raw **Poly1305** instance, and the algorithm is as follows.

1. A random 512-bit digest **D** is selected from the seededRandom used to select keys for the keySet algorithm.
2. A random SymKey **K<sub>S</sub>** is selected via the seededRandom from the keys in the keySet that have not been
used for the encryption.
3. Two input values **X<sub>1</sub>** and **X<sub>2</sub>** are calculated by xor-ing **V** with
**IV<sub>3</sub>** and **IV<sub>4</sub>** respectively
4. The input values are encrypted using **K<sub>S</sub>** in **ECB** mode with no padding to produce
**K<sub>1</sub>** and **K<sub>2</sub>**
5. The key for the Poly1305 Mac is the concatenation of **K<sub>1</sub>||K<sub>2</sub>**.
6. The digest **D** is calculated on the plainText
7. The Mac is calculated on data in a similar fashion to ChaCha20Poly1305 with minor differences as follows
    * The AAD data **A**
    * From 0 to 15 zeroes to bring data up to 16-byte boundary
    * The cipherText **C**
    * From 0 to 15 zeroes to bring data up to 16-byte boundary
    * AAD dataLength as 8-byte big-endian long
    * PlainText dataLength as 8-byte big-endian long
    *The result of the digest **D**
8. Finally the Mac result **M** is encrypted using **K<sub>S</sub>** in **ECB** mode with no padding
to produce **M<sub>K</sub>**, and the result in the concatenation of **C||M<sub>K</sub>**
                
### Sample
```
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

/* Create keySet */
final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);

/* Encrypt data as one-off */
final byte[] myAAD = ...
final byte[] myMessage = ...
byte[] myEncrypted = myKeySet.encryptAADBytes(myMessage, myAAD);
byte[] myResult = myKeySet.decryptAADBytes(myEncrypted, myAAD);

/* Encrypt data as cipher */
final GordianKeySetAADCipher myCipher = myKeySet.createAADCipher();
myCipher.initForEncrypt(myAAD);
myEncrypted = myCipher.finish(myMessage, 0, myMessage.length);
myCipher.initForDecrypt(myAAD);
myResult = myCipher.finish(myEncrypted, 0, myEncrypted.length);
```

## KeySet Wrapping

### Algorithm
Wrapping works by selecting a subSet of the available keys and initially encrypting the message with the first key and then using the remaining
keys to wrap the result using the standard wrapping algorithm. In each case where the normal cipher is used to encrypt/decrypt, the remaining set
of keys is used to encrypt/decrypt in turn.

1. A random 32-bit seed **S** and a random 128-bit initVector **V** are generated.
2. A subSet of **n** keys is selected (all different) using a seededRandom based on **S** and the personalisation value
**I<sub>2</sub>**
3. An initiation vector **V<sub>1</sub>** is calculated by xor-ing **V** with **IV<sub>1</sub>**
4. The first encryption is performed on the bytes **B** using **K<sub>1</sub>** in **SIC** mode using **V<sub>1</sub>** as the initialisation vector to create **W<sub>1</sub>**
5. The result **W<sub>1</sub>** is then wrapped using keys **K<sub>2</sub>** to **K<sub>x</sub>**
to produce **W<sub>2</sub>**
6. The result is the concatenation of **S||V||W<sub>2</sub>**

### Sample
```
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

/* Create keySet */
final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);

/* Secure key */
final GordianKey<GordianSymKeySpec> myKey =  ...
final byte[] mySecured = myKeySet.secureKey(myKey);
final GordianKey<GordianSymKeySpec> myResult = myKeySet.deriveKey(mySecured, myKeySpec);
```


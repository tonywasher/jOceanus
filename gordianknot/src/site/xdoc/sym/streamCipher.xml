<document>
    <properties>
        <title>GordianKnot Symmetric Stream Ciphers</title>
        <author email="Tony.Washer@yahoo.co.uk">Tony Washer</author>
    </properties>
    <body>
        <section name="GordianKnot Symmetric Stream Ciphers">
            <subsection name="Overview">
                <p>Stream Ciphers are supported via the <strong>GordianCipherFactory</strong> interface.</p>
                <p>GordianKnot supports most Symmetric Stream Ciphers available from BouncyCastle plus some additional ciphers.</p>
                <p>A key for stream encryption is created by specifying the algorithm and keySize as a <strong>GordianStreamKeySpec</strong>.</p>
                <p>A cipher for stream encryption is created by specifying the <strong>GordianStreamKeySpec</strong> (plus variant details eg AEAD)
                    as a <strong>GordianStreamCipherSpec</strong> and can be used similarly to a blockCipher.</p>
                <p>A keyGenerator for a <strong>GordianStreamKeySpec</strong> can be created, which can be used to generate random keys for the keySpec</p>
                <p>JCA provides a subset of available algorithms as indicated</p>
            </subsection>
            <subsection name="Key Generation">
                <p>Algorithms are represented by <strong>GordianSymKeySpec</strong>. A <strong>GordianKeyGenerator</strong> is obtained via the keySpec,
                    and then keys are generated by the generator.</p>
                <subsection name="Sample">
                    <source>
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

/* Access keyGenerator */
final GordianStreamKeySpec mySpec = GordianStreamKeySpecBuilder.hc(GordianLength.LEN_256);
final GordianKeyGenerator&lt;GordianStreamKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(mySpec);
final GordianKey&lt;GordianStreamKeySpec&gt; myKey = myGenerator.generateKey();
                    </source>
                </subsection>
                <subsection name="Algorithms">
                    <p>The following streamKey algorithms are supported.</p>
                    <table class="defTable">
                        <tr><th class="defHdr" rowspan="2">Algorithm</th><th class="defHdr" rowspan="2">Variant</th><th class="defHdr" rowspan="2">JCA</th>
                            <th class="defHdr" colspan="5">KeySize</th></tr>
                        <tr><th class="defHdr">128</th><td class="defHdr">192</td><th class="defHdr">256</th><th class="defHdr">512</th><th class="defHdr">1024</th></tr>
                        <tr><td rowspan="3">ChaCha20</td><td>Standard</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/></tr>
                        <tr><td>ChaCha7359</td><td>Y</td><td/><td/><td>Y</td><td/><td/></tr>
                        <tr><td>XChaCha20</td><td/><td/><td/><td>Y</td><td/><td/></tr>
                        <tr><td rowspan="2">Salsa20</td><td>Standard</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/></tr>
                        <tr><td>XSalsa20</td><td>Y</td><td/><td/><td>Y</td><td/><td/></tr>
                        <tr><td rowspan="2">HC</td><td>HC128</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>HC256</td><td>Y</td><td/><td/><td>Y</td><td/><td/></tr>
                        <tr><td>VMPC</td><td>Standard KSA3</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
                        <tr><td>ISAAC</td><td/><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
                        <tr><td>RC4</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
                        <tr><td>Grain128</td><td/><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>Rabbit</td><td/><td/><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>Sosemanuk</td><td/><td/><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>Snow3G</td><td/><td/><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td rowspan="2">Zuc</td><td>Zuc-128</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>Zuc-256</td><td>Y</td><td/><td/><td>Y</td><td/><td/></tr>
                        <tr><td rowspan="3">SkeinXof</td><td>Skein-256</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
                        <tr><td>Skein-512</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
                        <tr><td>Skein-1024</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
                        <tr><td rowspan="2">Blake2X</td><td>Blake2Xs</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td>Blake2Xb</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                        <tr><td>Blake3Xof</td><td/><td/><td/><td/><td>Y</td><td/><td/></tr>
                        <tr><td>Ascon</td><td/><td/><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>Elephant</td><td>160, 176, 200</td><td/><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>ISAP</td><td>A128, A128A, K128, K128A</td><td/><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>PhotonBeetle</td><td/><td/><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td rowspan="3">Sparkle</td><td>128_128, 256_128</td><td/><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>192_192</td><td/><td/><td>Y</td><td/><td/><td/></tr>
                        <tr><td>256_256</td><td/><td/><td/><td>Y</td><td/><td/></tr>
                        <tr><td>Xoodyak</td><td/><td/><td>Y</td><td/><td/><td/><td/></tr>
                    </table>
                </subsection>
            </subsection>
            <subsection name="Cipher Usage">
                <p>Cipher Algorithms are represented by <strong>GordianStreamCipherSpec</strong>. A <strong>GordianStreamCipher</strong> is obtained via the cipherSpec,
                    and then messages are encrypted/decrypted by the cipher.</p>
                <subsection name="Sample">
                    <source>
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

/* Create key */
final GordianStreamKeySpec myKeySpec = GordianStreamKeySpecBuilder.hc(GordianLength.LEN_256);
final GordianKeyGenerator&lt;GordianStreamKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(myKeySpec);
final GordianKey&lt;GordianStreamKeySpec&gt; myKey = myGenerator.generateKey();

/* Create cipher */
final GordianStreamCipherSpec myCipherSpec = GordianStreamCipherSpecBuilder.stream(myKeySpec);
final GordianStreamCipher myCipher = myCipherFactory.createStreamKeyCipher(myCipherSpec);

/* Encrypt message with random nonce */
GordianCipherParameters myParams = GordianCipherParameters.keyWithRandomNonce(myKey);
myCipher.initForEncrypt(myParams);
final byte[] myMessage = ...
int myOutLen = myCipher.getOutputLength(myMessage.length);
final byte[] myEncrypted = new byte[myOutLen];
int myProcessed = myCipher.update(myMessage, 0, myMessage.length, myEncrypted);
myCipher.finish(myEncrypted, myProcessed);

/* Decrypt message */
myParams = GordianCipherParameters.keyWithNonce(myKey, myCipher.getNonce());
myCipher.initForDecrypt(myParams);
myOutLen = myCipher.getOutputLength(myEncrypted.length);
final byte[] myResult = new byte[myOutLen];
myProcessed = myCipher.update(myEncrypted, 0, myEncrypted.length, myResult);
myCipher.finish(myResult, myProcessed);
                    </source>
                </subsection>
            </subsection>
        </section>
    </body>
</document>

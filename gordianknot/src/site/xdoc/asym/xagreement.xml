<document>
    <properties>
        <title>GordianKnot Asymmetric Agreements</title>
        <author email="Tony.Washer@yahoo.co.uk">Tony Washer</author>
    </properties>
    <body>
        <section name="GordianKnot Asymmetric Agreements">
            <subsection name="Overview">
                <p>Agreements are supported via the <strong>GordianXAgreementFactory</strong> interface.</p>
                <p>A <strong>GordianXAgreement</strong> is created at the client by the factory using a
                    <b>GordianXAgreementParams</b> object and this will produce a <strong>ClientHello</strong> message to be sent
                    to the server. The receiving factory will take the <strong>ClientHello</strong> message and create a second
                    <strong>GordianXAgreement</strong> object that will process the client message. For non-anonymous agreements,
                    a further <strong>ServerHello</strong> message is generated to be sent back to the client for processing.
                    In turn, for confirm agreements, another <strong>ClientConfirm</strong> message is created for sending back
                    to the server for processing. The result will be available from the agreement once all processing
                    is complete for that object.</p>
                <p>Agreements are always targeted by a <strong>Client</strong> towards a <strong>Server</strong>.</p>
                <p>The resultTypes can be any of the following</p>
                <table class="defTable">
                    <tr><th>ResultType</th><th>Description</th></tr>
                    <tr><td>GordianFactoryType</td><td>The underlying agreement is used as the input to the HKDF algorithm to
                        generate a new personalised <strong>GordianFactory</strong></td></tr>
                    <tr><td>GordianKeySetSpec</td><td>The underlying agreement is used as the input to the HKDF algorithm to generate a new
                        <strong>GordianKeySet</strong> of the specified type, belonging to an agreed BC factory.</td></tr>
                    <tr><td>GordianSymCipherSpec</td><td>The underlying agreement is used as the input to the HKDF algorithm to generate a new
                        <strong>GordianSymCipher</strong> Key and InitVector (if required),
                        belonging to an agreed BC factory. A pair of <strong>GordianSymCipher</strong>s are returned as the result, one for encryption
                        and one for decryption</td></tr>
                    <tr><td>GordianStreamCipherSpec</td><td>Similar to <strong>GordianSymKeySpec</strong>.</td></tr>
                    <tr><td>Integer</td><td>The underlying agreement is used as the input to the HKDF algorithm to generate a byte array
                        of the desired length</td></tr>
                </table>
            </subsection>
            <subsection name="Parameters">
                <p>The following parameters are available</p>
                <table class="defTable">
                    <tr><th>Parameter</th><th>Description</th></tr>
                    <tr><td>ServerCertificate</td><td>The certificate of the server keyPair</td></tr>
                    <tr><td>ClientCertificate</td><td>The certificate of the client keyPair</td></tr>
                    <tr><td>SignerCertificate</td><td>The certificate of the signing keyPair</td></tr>
                    <tr><td>SignerAlgorithm</td><td>The signatureAlgorithm to be used by the signer. If not specified,
                        then the default signature algorithm for the signer keyPair is used</td></tr>
                    <tr><td>AdditionalData</td><td>AdditionalData to be added to personalize the agreement. This is not
                        transmitted and must be supplied independently and identically by client and server. It is only
                        available via the KDF and therefore the KDF must not be NONE for this parameter to be accepted.
                        <strong>NOTE</strong> only <strong>MLKEM</strong> of the postQuantum algorithms currently supports
                        this option</td></tr>
                </table>
            </subsection>
            <subsection name="MiniCertificates">
                <p>Agreements are driven by certificates, but these are not available for newly created keyPairs, and
                    in any case are heavyweight to generate. Therefore <strong>miniCertificates</strong> are
                    available to provide lightweight certificates that can drive agreements.</p>
                <p>The only contents or mini-certificates are the keyPair, the defined usage and the X500Name. The Name
                    does not need to have any meaning, but can convey whatever information is required by the application</p>
            </subsection>
            <subsection name="Anonymous Agreement">
                <p>An anonymous agreement is an agreement where the only certificate required is that of the server.
                    It must be specified in the parameters prior to the agreement being created. If a keyPair is
                    required at the server, then it is an ephemeral anonymous keyPair.</p>
                <p>The client creates a <strong>ClientHello</strong> message to be sent to the server, and immediately
                    enters the <strong>RESULT_AVAILABLE</strong> state and makes the result available to the caller.</p>
                <p>The server will parse the incoming <strong>ClientHello</strong> message and create a corresponding
                    <strong>GordianXAgreementParams</strong> object. It cannot immediately continue, since it does not
                    know the privateKey of the server, so it enters the <strong>AWAITING_SERVERPRIVATE</strong> state.</p>
                <p>The server is expected to look at the serverCertificate contained in the parameters, and replace it
                    with a certificate that contains the privateKey of the server, before updating the agreement.</p>
                <p>The server can now calculate the result and enters the <strong>RESULT_AVAILABLE</strong> state making
                    the result available to the caller</p>
                <p>A random client InitVector is included in the process to randomize the result</p>
                 <subsection name="Sample">
                    <source>
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianAsyncFactory myAsyncFactory = myBase.getAsyncFactory();
final GordianKeyPairFactory myKeyPairFactory = myAsyncFactory.getKeyPairFactory();
final GordianXAgreementFactory myAgreementFactory = myAsyncFactory.getXAgreementFactory();

/* Access keyPairGenerator and create pair */
final GordianKeyPairSpec mySpec = GordianKeyPairSpecBuilder.dh(GordianDHGroup.FFDHE2048);
final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
final GordianKeyPair myTarget = myGenerator.generateKeyPair();

/* Create mini-certificates */
final X500Name myServerName = ...
final GordianCertificate myTargetCert = myAgreementFactory.newMiniCertificate(myServerName, myTarget,
                                                   new GordianKeyPairUsage(GordianKeyPairUse.AGREEMENT));

/* Create the client hello */
final GordianAgreementSpec myAgreeSpec = GordianAgreementSpecBuilder.anon(mySpec, GordianKDFType.SHA256KDF);
final GordianKeySetSpec myKeySetSpec = new GordianKeySetSpec(GordianLength.LEN_256);
GordianXAgreementParams myParams = myAgreementFactory.newAgreementParams(mySpec, myKeySetSpec)
                                                     .setServerCertificate(myTargetCert);
final GordianXAgreement mySender = myAgrees.createAgreement(myParams);
final byte[] myClientHello = mySender.nextMessage();
final GordianKeySet myClientKeySet = (GordianKeySet) mySender.getResult();

/* Handle receipt at server */
final GordianXAgreement myResponder = myAgreementFactory.parseAgreementMessage(myClientHello);
myParams = myResponder.getAgreementParams()
                      .setServerCertificate(myTargetCert);
myResponder.updateParams(myParams);
final GordianKeySet myServerKeySet = (GordianKeySet) myResponder.getResult();
                    </source>
                </subsection>
            </subsection>
            <subsection name="Handshake Agreement">
                <p>A handshake agreement is an agreement where certificates are required for both the client and the
                    server. Both certificates must be specified in the parameters prior to the agreement being created.
                    The clientCertificate must contain the private key of the keyPair.</p>
                <p>The client creates a <strong>ClientHello</strong> message to be sent to the server, and immediately
                    enters the <strong>AWAITING_SERVERHELLO</strong> state. The agreement is added to the factory cache.</p>
                <p>The server will parse the incoming <strong>ClientHello</strong> message as per the Anonymous case.
                    The only difference is that a <strong>ServerHello</strong> message is created to send to the client.</p>
                <p>It is possible for the server to reject the agreement, perhaps because it did not recognize the
                    serverCertificate or accept the clientCertificate. It this case it can set an errorMessage which will
                    cause the result to be an Exception object, and will transmit the error in the
                    <strong>ServerHello</strong> message so that it becomes the result at the client as well.</p>
                <p>The client will parse the incoming <strong>ServerHello</strong> message and will look up the agreement
                    in the cache. If no matching agreement is found then the message is rejected.</p>
                <p>The client can now calculate the result and deletes the agreement from the cache and enters the
                    <strong>RESULT_AVAILABLE</strong> state making the result available to the caller</p>
                <p>Random client and server InitVectors are included in the process to randomize the result</p>
               <subsection name="Sample">
                    <source>
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianAsyncFactory myAsyncFactory = myBase.getAsyncFactory();
final GordianKeyPairFactory myKeyPairFactory = myAsyncFactory.getKeyPairFactory();
final GordianXAgreementFactory myAgreementFactory = myAsyncFactory.getXAgreementFactory();

/* Access keyPairGenerator and create pairs */
final GordianKeyPairSpec mySpec = GordianKeyPairSpecBuilder.dh(GordianDHGroup.FFDHE2048);
final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
final GordianKeyPair mySource = myGenerator.generateKeyPair();
final GordianKeyPair myTarget = myGenerator.generateKeyPair();

/* Create mini-certificates */
final X500Name myClientName = ...
final GordianCertificate mySourceCert = myAgreementFactory.newMiniCertificate(myClientName, mySource,
                                                   new GordianKeyPairUsage(GordianKeyPairUse.AGREEMENT));
final X500Name myServerName = ...
final GordianCertificate myTargetCert = myAgreementFactory.newMiniCertificate(myServerName, myTarget,
                                                   new GordianKeyPairUsage(GordianKeyPairUse.AGREEMENT));

/* Create the client hello */
final GordianAgreementSpec myAgreeSpec = GordianAgreementSpecBuilder.unified(mySpec, GordianKDFType.SHA256KDF);
final GordianKeySetSpec myKeySetSpec = new GordianKeySetSpec(GordianLength.LEN_256);
GordianXAgreementParams myParams = myAgreementFactory.newAgreementParams(mySpec, myKeySetSpec)
                                                     .setClientCertificate(mySourceCert)
                                                     .setServerCertificate(myTargetCert);
final GordianXAgreement mySender = myAgrees.createAgreement(myParams);
final byte[] myClientHello = mySender.nextMessage();

/* Handle receipt at server */
final GordianXAgreement myResponder = myAgreementFactory.parseAgreementMessage(myClientHello);
myParams = myResponder.getAgreementParams()
                      .setServerCertificate(myTargetCert);
myResponder.updateParams(myParams);
final byte[] myServerHello = myResponder.nextMessage();
final GordianKeySet myServerKeySet = (GordianKeySet) myResponder.getResult();

/* Process ServerHello at Client (will receive existing agreement) */
final GordianXAgreement myClient = myAgreementFactory.parseAgreementMessage(myServerHello);
final GordianKeySet myClientKeySet = (GordianKeySet) myClient.getResult();
                    </source>
                </subsection>
            </subsection>
            <subsection name="Confirmation Agreement">
                <p>A confirmation agreement is simply a handshake agreement with an additional step.</p>
                <p>The client creates a <strong>ClientHello</strong> message the same as for a handshake agreement.</p>
                <p>The server processes the <strong>ClientHello</strong> as before but rather than making the result
                    available, it enters the <strong>AWAITING_CLIENTCONFIRM</strong> state. The agreement is added to
                    the factory cache.</p>
                <p>The client will parse the incoming <strong>ServerHello</strong> message as per a handshake agreement,
                    with the addition that a confirmation process is performed and a <strong>ClientConfirm</strong>
                    message is created to send to the server.</p>
                <p>The server will parse the incoming <strong>ClientConfirm</strong> message and will look up the agreement
                    in the cache. If no matching agreement is found then the message is rejected.</p>
                <p>The server can now process the confirmation and calculate the result and deletes the agreement from
                    the cache and enters the <strong>RESULT_AVAILABLE</strong> state making the result available to the caller</p>
                <p>The <strong>SM2</strong> confirm is defined by the SM2 algorithm. For <strong>UNIFIED</strong> and
                    <strong>MQV</strong> agreements the confirmation tags are calculated over the well-known and
                    ephemeral keyPairs using an hMac keyed by the agreed result.</p>
                <subsection name="Sample">
                    <source>
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianAsyncFactory myAsyncFactory = myBase.getAsyncFactory();
final GordianKeyPairFactory myKeyPairFactory = myAsyncFactory.getKeyPairFactory();
final GordianXAgreementFactory myAgreementFactory = myAsyncFactory.getXAgreementFactory();

/* Access keyPairGenerator and create pairs */
final GordianKeyPairSpec mySpec = GordianKeyPairSpecBuilder.dh(GordianDHGroup.FFDHE2048);
final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
final GordianKeyPair mySource = myGenerator.generateKeyPair();
final GordianKeyPair myTarget = myGenerator.generateKeyPair();

/* Create mini-certificates */
final X500Name myClientName = ...
final GordianCertificate mySourceCert = myAgreementFactory.newMiniCertificate(myClientName, mySource,
                                                   new GordianKeyPairUsage(GordianKeyPairUse.AGREEMENT));
final X500Name myServerName = ...
final GordianCertificate myTargetCert = myAgreementFactory.newMiniCertificate(myServerName, myTarget,
                                                   new GordianKeyPairUsage(GordianKeyPairUse.AGREEMENT));

/* Create the client hello */
final GordianAgreementSpec myAgreeSpec = GordianAgreementSpecBuilder.unifiedConfirm(mySpec, GordianKDFType.SHA256KDF);
final GordianKeySetSpec myKeySetSpec = new GordianKeySetSpec(GordianLength.LEN_256);
GordianXAgreementParams myParams = myAgreementFactory.newAgreementParams(mySpec, myKeySetSpec)
                                                     .setClientCertificate(mySourceCert)
                                                     .setServerCertificate(myTargetCert);
final GordianXAgreement mySender = myAgrees.createAgreement(myParams);
final byte[] myClientHello = mySender.nextMessage();

/* Handle receipt at server */
final GordianXAgreement myResponder = myAgreementFactory.parseAgreementMessage(myClientHello);
myParams = myResponder.getAgreementParams()
                      .setServerCertificate(myTargetCert);
myResponder.updateParams(myParams);
final byte[] myServerHello = myResponder.nextMessage();

/* Process ServerHello at Client (will receive existing agreement) */
final GordianXAgreement myClient = myAgrees.parseAgreementMessage(myServerHello);
final byte[] myClientConfirm = myClient.nextMessage();
final GordianKeySet myClientKeySet = (GordianKeySet) myClient.getResult();

/* Process ClientConfirm at Server (will receive existing agreement) */
final GordianXAgreement myServer = myAgreementFactory.parseAgreementMessage(myClientConfirm);
final GordianKeySet myServerKeySet = (GordianKeySet) myServer.getResult();
                    </source>
                </subsection>
            </subsection>
            <subsection name="Signed Agreement">
                <p>A signed agreement is simply a handshake agreement used with ephemeral keyPairs with the results
                    signed by a known signer. No client/server certificates are required.</p>
                <p>The client creates a <strong>ClientHello</strong> message the same as for a handshake agreement.</p>
                <p>The server processes the <strong>ClientHello</strong> but rather than waiting for a
                    serverCertificate with a private key, it waits for signerCertificate with a private key.</p>
                <p>It is possible to specify a default signerCertificate and signatureAlgorithm in the factory, and
                    this will be set as a default in the parameters, so that the server does not have to override
                    on a per-message basis.</p>
                <p>The server will then sign the results and include the signature and signerCertificate in the
                    <strong>ServerHello</strong> message to be sent to the client.</p>
                <p>The client will verify the incoming <strong>ServerHello</strong> message using the signature and
                    signerCertificate, and will proceed as per the handshake agreement.</p>
                <p>The signature is calculated over the two ephemeral keys and the initVectors</p>
                <subsection name="Sample">
                    <source>
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianAsyncFactory myAsyncFactory = myBase.getAsyncFactory();
final GordianKeyPairFactory myKeyPairFactory = myAsyncFactory.getKeyPairFactory();
final GordianXAgreementFactory myAgreementFactory = myAsyncFactory.getXAgreementFactory();

/* Access keyPairGenerator and create pair */
final GordianKeyPairSpec mySpec = GordianKeyPairSpecBuilder.ed25519();
final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
final GordianKeyPair mySigner = myGenerator.generateKeyPair();

/* Create mini-certificates */
final X500Name myClientName = ...
final GordianCertificate mySignerCert = myAgreementFactory.newMiniCertificate(myClientName, mySigner,
                                                   new GordianKeyPairUsage(GordianKeyPairUse.SIGNATURE));

/* Create the client hello */
final GordianAgreementSpec myAgreeSpec = GordianAgreementSpecBuilder.unified(mySpec, GordianKDFType.SHA256KDF);
final GordianKeySetSpec myKeySetSpec = new GordianKeySetSpec(GordianLength.LEN_256);
GordianXAgreementParams myParams = myAgreementFactory.newAgreementParams(mySpec, myKeySetSpec);
final GordianXAgreement mySender = myAgrees.createAgreement(myParams);
final byte[] myClientHello = mySender.nextMessage();

/* Handle receipt at server */
final GordianXAgreement myResponder = myAgreementFactory.parseAgreementMessage(myClientHello);
myParams = myResponder.getAgreementParams()
                      .setSigner(mySignerCert);
myResponder.updateParams(myParams);
final byte[] myServerHello = myResponder.nextMessage();
final GordianKeySet myServerKeySet = (GordianKeySet) myResponder.getResult();

/* Process ServerHello at Client (will receive existing agreement) */
final GordianXAgreement myClient = myAgreementFactory.parseAgreementMessage(myServerHello);
final GordianKeySet myClientKeySet = (GordianKeySet) myClient.getResult();
                    </source>
                </subsection>
            </subsection>
            <subsection name="Composite Agreements">
                <p>Composite agreements may be created by a composite keyPair, as long as each element of the composite keyPair is capable of supporting the
                    desired AgreementSpec. There are three small variations.
                    <ol>
                        <li>Confirm is not supported for <strong>SM2</strong> agreements</li>
                        <li>Signed agreements are implemented as a set of <strong>Basic</strong> Agreements with the results signed.</li>
                        <li>The various individual agreements are used as inputs to the HKDF algorithm to extract a combined agreement secret</li>
                    </ol>
                </p>
                <subsection name="Sample">
                    <source>
/* Access factory */
final GordianFactory myBaseFactory = GordianGenerator.createFactory();
final GordianAsyncFactory myAsyncFactory = myBase.getAsyncFactory();
final GordianKeyPairFactory myKeyPairFactory = myAsyncFactory.getKeyPairFactory();
final GordianXAgreementFactory myAgreementFactory = myAsyncFactory.getXAgreementFactory();

/* Access keyPairGenerator and create pair */
final GordianKeyPairSpec mySpec = GordianKeyPairSpecBuilder.composite(GordianKeyPairSpec.dh(GordianDGroup.FFDHE2048),
                                                                      GordianKeyPairSpec.ec(GordianDSAElliptic.SECP256R1));
final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
final GordianKeyPair myTarget = myGenerator.generateKeyPair();

/* Create mini-certificates */
final X500Name myServerName = ...
final GordianCertificate myTargetCert = myAgreementFactory.newMiniCertificate(myServerName, myTarget,
                                                   new GordianKeyPairUsage(GordianKeyPairUse.AGREEMENT));

/* Handle as standard */
....
                    </source>
                </subsection>
            </subsection>
            <subsection name="Algorithms">
                <p>The following agreement algorithms are supported.</p>
                <table class="defTable">
                    <tr><th class="defHdr">Algorithm</th><th>Type</th><th class="defHdr">KeyTypes</th><th>Notes</th></tr>
                    <tr><td>KEM</td><td>Anonymous</td><td>RSA, EC, GOST2012, DSTU4145, SM2, CMCE, Frodo, SABER,
                        MLKEM, BIKE, HQC, NTRU, NTRUPRIME, NEWHOPE</td><td>RSA, EC, GOST2012, DSTU4145 and SM2 are not available on JCA</td></tr>
                    <tr><td>Anonymous</td><td>Anonymous</td><td>DH, EC, GOST2012, DSTU4145, SM2, XDH</td><td/></tr>
                    <tr><td>Basic</td><td>Handshake</td><td>DH, EC, GOST2012, DSTU4145, SM2, XDH</td><td/></tr>
                    <tr><td>Signed</td><td>Signed</td><td>DH, EC, GOST2012, DSTU4145, SM2, XDH</td><td/></tr>
                    <tr><td>MQV</td><td>Handshake</td><td>DH, EC, GOST2012, DSTU4145, SM2</td><td/></tr>
                    <tr><td>Unified</td><td>Handshake</td><td>DH, EC, GOST2012, DSTU4145, SM2, XDH</td><td/></tr>
                    <tr><td>SM2</td><td>Handshake</td><td>EC, GOST2012, SM2</td><td>Not available on JCA</td></tr>
                </table>
            </subsection>
        </section>
    </body>
</document>

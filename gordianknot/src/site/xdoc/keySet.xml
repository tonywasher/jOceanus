<document>
    <properties>
        <title>GordianKnot KeySets</title>
        <author email="Tony.Washer@yahoo.co.uk">Tony Washer</author>
    </properties>
    <body>
        <section name="Overview">
            <p>KeySets are supported via the <strong>GordianKeySetFactory</strong> interface.</p>
            <p>GordianKnot supports the notion of a KeySet, which is a set of keys of each available algorithm with a 128-bit blockSize.
            The keySet may be used to encrypt/decrypt and to secure/derive keys or keySets</p>
        </section>
        <section name="KeySet Generation">
            <p>A keySet can be generated by specifying a <strong>GordianKeySetSpec</strong>. Each key in the keySet is generated randomly.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

                    /* Create keySet */
                    final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
                    final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);
                </source>
            </subsection>
        </section>
        <section name="KeySet Derivation">
            <p>The keySet derivation algorithm that generates each of the keys <strong>K<sub>A</sub></strong> for an algorithm <strong>A</strong>
                from a secret <strong>S</strong> is as follows.</p>
            <ol>
                <li>Obtain a seed <strong>X</strong> from the first 4 bytes of <strong>S</strong> and obtain a seeded random <strong>R</strong> using
                    <strong>X</strong> and <strong>P<sub>1</sub></strong></li>
                <li>Obtain a set of two distinct HMACs <strong>H<sub>1</sub></strong> and <strong>H<sub>2</sub></strong> from the seededRandom <strong>R</strong></li>
                <li>Use HKDF with the two HMACs to expand the result <strong>S</strong> into <strong>K<sub>A</sub></strong>.
                    Use the following info to personalise and differentiate the keys.
                    <ol>
                        <li>Algorithm Name.</li>
                        <li>Key Length.</li>
                        <li>8 bytes from seeded random.</li>
                        <li>Personalisation value <strong>P</strong>.</li>
                        <li>Personalisation value <strong>I</strong>.</li>
                    </ol>
                </li>
            </ol>
        </section>
        <section name="KeySet Encryption">
            <subsection name="Algorithm">
                <p>Encryption works by selecting a subSet of the available keys and encrypting the message using each key in turn. The number of keys selected and
                    hence the number of encryption steps is specified in the <strong>GordianKeySetSpec</strong> and can vary betweeen 3 and 6</p>
                <ol>
                    <li>A random 32-bit seed <strong>S</strong> and a random 128-bit initVector <strong>V</strong> are generated.</li>
                    <li>A subSet of <strong>n</strong> keys is selected (all different) using a seededRandom based on <strong>S</strong> and the personalisation value
                        <strong>I<sub>2</sub></strong></li>
                    <li>Two initiation vectors <strong>V<sub>1</sub></strong> and <strong>V<sub>2</sub></strong> are calculated by xor-ing <strong>V</strong> with
                        <strong>IV<sub>1</sub></strong> and <strong>IV<sub>2</sub></strong> respectively</li>
                    <li>The first encryption is performed on the message <strong>M</strong> using <strong>K<sub>1</sub></strong> in <strong>SIC</strong> mode
                        using <strong>V<sub>1</sub></strong> as the initialisation vector to create <strong>C<sub>1</sub></strong></li>
                    <li>The second encryption is performed on <strong>C<sub>1</sub></strong> using <strong>K<sub>2</sub></strong> in
                        <strong>ECB</strong> mode with <strong>PKCS7</strong> padding to create <strong>C<sub>2</sub></strong>.</li>
                    <li>Further intermediate encryptions are performed on <strong>C<sub>x-1</sub></strong> using <strong>K<sub>x</sub></strong>
                        in <strong>ECB</strong> mode with no padding to produce <strong>C<sub>x</sub></strong>.</li>
                    <li>The final encryption is performed on <strong>C<sub>n-1</sub></strong> using <strong>K<sub>n</sub></strong> in <strong>SIC</strong> mode
                        using <strong>V<sub>2</sub></strong> as the initialisation vector to create <strong>C<sub>n</sub></strong></li>
                    <li>The result is the concatenation of <strong>S||V||C<sub>n</sub></strong></li>
                </ol>
            </subsection>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

                    /* Create keySet */
                    final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
                    final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);

                    /* Encrypt data as one-off */
                    final byte[] myMessage = ...
                    byte[] myEncrypted = myKeySet.encryptBytes(myMessage);
                    byte[] myResult = myKeySet.decryptBytes(myEncrypted);

                    /* Encrypt data as cipher */
                    final GordianKeySetCipher myCipher = myKeySet.createCipher();
                    myCipher.initForEncrypt();
                    myEncrypted = myCipher.finish(myMessage, 0, myMessage.length);
                    myCipher.initForDecrypt();
                    myResult = myCipher.finish(myEncrypted, 0, myEncrypted.length);
                </source>
            </subsection>
        </section>
        <section name="KeySet AAD Encryption">
            <subsection name="Algorithm">
                <p>AAD is supported by calculating a Mac and appending it to the encrypted cipherText. On decryption the Mac is recalculated and compared to
                    the trailing bytes of the cipherText. Encryption works as per normal and the only difference is in the calculation of the Mac.
                    The Mac used is a raw <strong>Poly1305</strong> instance, and the algorithm is as follows.</p>
                <ol>
                    <li>A random 512-bit digest <strong>D</strong> is selected from the seededRandom used to select keys for the keySet algorithm.</li>
                    <li>A random SymKey <strong>K<sub>S</sub></strong> is selected via the seededRandom from the keys in the keySet that have not been
                        used for the encryption.</li>
                    <li>Two input values <strong>X<sub>1</sub></strong> and <strong>X<sub>2</sub></strong> are calculated by xor-ing <strong>V</strong> with
                        <strong>IV<sub>3</sub></strong> and <strong>IV<sub>4</sub></strong> respectively</li>
                    <li>The input values are encrypted using <strong>K<sub>S</sub></strong> in <strong>ECB</strong> mode with no padding to produce
                        <strong>K<sub>1</sub></strong> and <strong>K<sub>2</sub></strong></li>
                    <li>The key for the Poly1305 Mac is the concatenation of <strong>K<sub>1</sub>||K<sub>2</sub></strong>.</li>
                    <li>The digest <strong>D</strong> is calculated on the plainText</li>
                    <li>The Mac is calculated on data in a similar fashion to ChaCha20Poly1305 with minor differences as follows
                        <ul>
                            <li>The AAD data <strong>A</strong></li>
                            <li>From 0 to 15 zeroes to bring data up to 16-byte boundary</li>
                            <li>The cipherText <strong>C</strong></li>
                            <li>From 0 to 15 zeroes to bring data up to 16-byte boundary</li>
                            <li>AAD dataLength as 8-byte big-endian long</li>
                            <li>PlainText dataLength as 8-byte big-endian long</li>
                            <li>The result of the digest <strong>D</strong></li>
                        </ul>
                    </li>
                    <li>Finally the Mac result <strong>M</strong> is encrypted using <strong>K<sub>S</sub></strong> in <strong>ECB</strong> mode with no padding
                        to produce <strong>M<sub>K</sub></strong>, and the result in the concatenation of <strong>C||M<sub>K</sub></strong></li>
                </ol>
            </subsection>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

                    /* Create keySet */
                    final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
                    final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);

                    /* Encrypt data as one-off */
                    final byte[] myAADe = ...
                    final byte[] myMessage = ...
                    byte[] myEncrypted = myKeySet.encryptAADBytes(myMessage, myAAD);
                    byte[] myResult = myKeySet.decryptAADBytes(myEncrypted, myAAD);

                    /* Encrypt data as cipher */
                    final GordianKeySetAADCipher myCipher = myKeySet.createAADCipher();
                    myCipher.initForEncrypt(myAAD);
                    myEncrypted = myCipher.finish(myMessage, 0, myMessage.length);
                    myCipher.initForDecrypt(myAAD);
                    myResult = myCipher.finish(myEncrypted, 0, myEncrypted.length);
                </source>
            </subsection>
        </section>
        <section name="KeySet Wrapping">
            <subsection name="Algorithm">
                <p>Wrapping works by selecting a subSet of the available keys and initially encrypting the message with the first key and then using the remaining
                    keys to wrap the result using the standard wrapping algorithm. In each case where the normal cipher is used to encrypt/decrypt, the remaining set
                    of keys is used to encrypt/decrypt in turn.</p>
                <ol>
                    <li>A random 32-bit seed <strong>S</strong> and a random 128-bit initVector <strong>V</strong> are generated.</li>
                    <li>A subSet of <strong>n</strong> keys is selected (all different) using a seededRandom based on <strong>S</strong> and the personalisation value
                        <strong>I<sub>2</sub></strong></li>
                    <li>An initiation vector <strong>V<sub>1</sub></strong> is calculated by xor-ing <strong>V</strong> with <strong>IV<sub>1</sub></strong></li>
                    <li>The first encryption is performed on the bytes <strong>B</strong> using <strong>K<sub>1</sub></strong> in <strong>SIC</strong>
                        mode using <strong>V<sub>1</sub></strong> as the initialisation vector to create <strong>W<sub>1</sub></strong></li>
                    <li>The result <strong>W<sub>1</sub></strong> is then wrapped using keys <strong>K<sub>2</sub></strong> to <strong>K<sub>x</sub></strong>
                        to produce <strong>W<sub>2</sub></strong></li>
                    <li>The result is the concatenation of <strong>S||V||W<sub>2</sub></strong></li>
                </ol>
            </subsection>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

                    /* Create keySet */
                    final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
                    final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);

                    /* Secure key */
                    final GordianKey&lt;GordianSymKeySpec&gt; myKey =  ...
                    final byte[] mySecured = myKeySet.secureKey(myKey);
                    final GordianKey&lt;GordianSymKeySpec&gt; myResult = myKeySet.deriveKey(mySecured, myKeySpec);
                </source>
            </subsection>
        </section>
        <section name="KeySetHash">
            <p>A keySet can also be derived from a password and a hash.</p>
            <subsection name="Creation Algorithm">
                <ol>
                    <li>A random 32-bit seed <strong>S</strong> and a random 128-bit initVector <strong>V</strong> are generated.</li>
                    <li>A set of three hMacs (all different) <strong>H<sub>M</sub></strong>, <strong>H<sub>A</sub></strong> and <strong>H<sub>S</sub></strong> are
                         selected in a deterministic fashion using a seededRandom based on <strong>S</strong> and the personalisation value
                        <strong>I<sub>3</sub></strong>. In addition a 512-bit length digest <strong>X</strong> is selected from the same seeded Random.</li>
                    <li>Each of the hMacs is initialised with the password as the key</li>
                    <li>Each of the macs is updated with <strong>P</strong>, <strong>IV</strong> and the number of iterations <strong>L</strong> </li>
                    <li>Set input <strong>D<sub>M</sub></strong>, <strong>D<sub>A</sub></strong> and <strong>D<sub>S</sub></strong> to <strong>V</strong></li>
                    <li>Repeat the following loop <strong>L</strong> times
                         <ol>
                             <li>Update <strong>H<sub>M</sub></strong> with <strong>D<sub>M</sub></strong></li>
                             <li>Update <strong>H<sub>A</sub></strong> with <strong>D<sub>A</sub></strong></li>
                             <li>Update <strong>H<sub>S</sub></strong> with <strong>D<sub>S</sub></strong>, <strong>D<sub>M</sub></strong> and <strong>D<sub>A</sub></strong></li>
                             <li>Build new <strong>D<sub>M</sub></strong> as the hash of <strong>H<sub>M</sub></strong> and xor the result into <strong>C<sub>M</sub></strong>.
                                Repeat for other hashes.</li>
                         </ol>
                    </li>
                    <li>Update digest <strong>X</strong> with <strong>D<sub>M</sub></strong> and <strong>D<sub>A</sub></strong> and calculate the hash as
                         <strong>R<sub>V</sub></strong></li>
                    <li>Update digest <strong>X</strong> with <strong>C<sub>M</sub></strong> and <strong>C<sub>A</sub></strong> and calculate the hash as
                         <strong>R<sub>X</sub></strong></li>
                    <li>Calculate external hash as the concatenation of <strong>S||V||R<sub>X</sub></strong></li>
                    <li>Create keys for the keySet using <strong>C<sub>S</sub></strong> as the secret and <strong>R<sub>V</sub></strong> as the initVector</li>
                </ol>
            </subsection>
            <subsection name="Derivation Algorithm">
                <ol>
                    <li>Extract <strong>S</strong>, <strong>V</strong> and <strong>R<sub>X</sub></strong> from the hash.</li>
                    <li>Repeat creation algorithm with <strong>S</strong>, <strong>V</strong> and the password</li>
                    <li>Compare the calculated <strong>R<sub>X</sub></strong> with the one extracted from the hash. Only create the keySet if it matches.</li>
                 </ol>
            </subsection>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

                    /* Create the hash and access the resultant keySet */
                    final GordianKeySetSpec mySpec = new GordianKeySetHashSpec(new GordianKeySetSpec(GordianLength.LEN_256));
                    final char[] myPassword = ...
                    final GordianKeySetHash myKeySetHash = myKeySetFactory.generateKeySetHash(mySpec, myPassword);
                    final GordianKeySet myKeySet = myKeySetHash.getKeySet();

                    /* Access hash and derive keySet from hash and password */
                    final byte[] myHash = myKeySetHash.getHash();
                    final GordianKeySetHash myResolved = myKeySetFactory.deriveKeySetHash(myHash, myPassword);
               </source>
            </subsection>
        </section>
    </body>
</document>

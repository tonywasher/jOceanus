<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianCoreKeyStore.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">io.github.tonywasher.joceanus.gordianknot.impl.core.keystore</a> &gt; <span class="el_source">GordianCoreKeyStore.java</span></div><h1>GordianCoreKeyStore.java</h1><pre class="source lang-java linenums">/*
 * GordianKnot: Security Suite
 * Copyright 2012-2026. Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.github.tonywasher.joceanus.gordianknot.impl.core.keystore;

import io.github.tonywasher.joceanus.gordianknot.api.base.GordianException;
import io.github.tonywasher.joceanus.gordianknot.api.base.GordianKeySpec;
import io.github.tonywasher.joceanus.gordianknot.api.cert.GordianCertificate;
import io.github.tonywasher.joceanus.gordianknot.api.cert.GordianCertificateId;
import io.github.tonywasher.joceanus.gordianknot.api.key.GordianKey;
import io.github.tonywasher.joceanus.gordianknot.api.keypair.GordianKeyPair;
import io.github.tonywasher.joceanus.gordianknot.api.keyset.GordianKeySet;
import io.github.tonywasher.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry;
import io.github.tonywasher.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStoreCertificate;
import io.github.tonywasher.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStoreKey;
import io.github.tonywasher.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStorePair;
import io.github.tonywasher.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStoreSet;
import io.github.tonywasher.joceanus.gordianknot.api.lock.GordianPasswordLockSpec;
import io.github.tonywasher.joceanus.gordianknot.api.zip.GordianZipFactory;
import io.github.tonywasher.joceanus.gordianknot.api.zip.GordianZipLock;
import io.github.tonywasher.joceanus.gordianknot.api.zip.GordianZipWriteFile;
import io.github.tonywasher.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import io.github.tonywasher.joceanus.gordianknot.impl.core.cert.GordianCoreCertificate;
import io.github.tonywasher.joceanus.gordianknot.impl.core.exc.GordianDataException;
import io.github.tonywasher.joceanus.gordianknot.impl.core.exc.GordianIOException;
import io.github.tonywasher.joceanus.gordianknot.impl.core.keystore.GordianCoreKeyStoreEntry.GordianCoreKeyStoreCertificate;
import io.github.tonywasher.joceanus.gordianknot.impl.core.keystore.GordianKeyStoreElement.GordianKeyStoreCertificateElement;
import io.github.tonywasher.joceanus.gordianknot.impl.core.keystore.GordianKeyStoreElement.GordianKeyStoreCertificateHolder;
import io.github.tonywasher.joceanus.gordianknot.impl.core.keystore.GordianKeyStoreElement.GordianKeyStoreKeyElement;
import io.github.tonywasher.joceanus.gordianknot.impl.core.keystore.GordianKeyStoreElement.GordianKeyStorePairElement;
import io.github.tonywasher.joceanus.gordianknot.impl.core.keystore.GordianKeyStoreElement.GordianKeyStoreSetElement;
import org.bouncycastle.asn1.cms.IssuerAndSerialNumber;
import org.bouncycastle.asn1.x500.X500Name;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;

/**
 * KeyStore implementation.
 * &lt;p&gt;
 * It should be noted that this implementation is based upon a number of assumptions.
 * &lt;/p&gt;
 * &lt;ol&gt;
 *     &lt;li&gt;The combination of Subject Name/Subject Id is viewed as a unique identifier for a public key. Multiple Certificates for the same subject,
 *     issued by different authorities must describe the same publicKey. It is expected that different publicKeys for the same subjectName
 *     WILL have different subjectIDs.&lt;/li&gt;
 *     &lt;li&gt;An issuerCertificate will only issue a single certificate at a time for a subjectName/subjectID combination.
 *     If two such certificates are received, the later one will overwrite the first one, (assuming the publicKey is the same).
 *     No attempt will be made to determine a BETTER certificate (e.g. longer validity)&lt;/li&gt;
 * &lt;/ol&gt;
 */
public class GordianCoreKeyStore
        implements GordianBaseKeyStore {
    /**
     * The ZipFile entry name.
     */
    static final String ZIPENTRY = &quot;KeyStore&quot;;

    /**
     * The factory.
     */
    private final GordianBaseFactory theFactory;

    /**
     * The passwordLockSpec.
     */
    private final GordianPasswordLockSpec thePasswordLockSpec;

    /**
     * The map of certificates by Subject.
     */
    private final Map&lt;GordianCertificateId, Map&lt;GordianCertificateId, GordianCertificate&gt;&gt; theSubjectCerts;

    /**
     * The map of certificates by Issuer.
     */
    private final Map&lt;GordianCertificateId, Map&lt;GordianCertificateId, GordianCertificate&gt;&gt; theIssuerCerts;

    /**
     * The aliases.
     */
    private final Map&lt;String, GordianKeyStoreEntry&gt; theAliases;

    /**
     * Constructor.
     *
     * @param pFactory the factory
     * @param pSpec    the passwordLockSpec
     */
    GordianCoreKeyStore(final GordianBaseFactory pFactory,
<span class="fc" id="L114">                        final GordianPasswordLockSpec pSpec) {</span>
        /* Store parameters */
<span class="fc" id="L116">        theFactory = pFactory;</span>
<span class="fc" id="L117">        thePasswordLockSpec = pSpec;</span>

        /* Create the maps */
<span class="fc" id="L120">        theSubjectCerts = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L121">        theIssuerCerts = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L122">        theAliases = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L123">    }</span>

    @Override
    public GordianBaseFactory getFactory() {
<span class="fc" id="L127">        return theFactory;</span>
    }

    /**
     * Obtain the passwordLockSpec.
     *
     * @return the passwordLockSpec
     */
    public GordianPasswordLockSpec getPasswordLockSpec() {
<span class="fc" id="L136">        return thePasswordLockSpec;</span>
    }

    @Override
    public Map&lt;GordianCertificateId, Map&lt;GordianCertificateId, GordianCertificate&gt;&gt; getSubjectMapOfMaps() {
<span class="fc" id="L141">        return theSubjectCerts;</span>
    }

    /**
     * Obtain the issuerMapofMaps.
     *
     * @return the map
     */
    private Map&lt;GordianCertificateId, Map&lt;GordianCertificateId, GordianCertificate&gt;&gt; getIssuerMapOfMaps() {
<span class="fc" id="L150">        return theIssuerCerts;</span>
    }

    @Override
    public Map&lt;String, GordianKeyStoreEntry&gt; getAliasMap() {
<span class="fc" id="L155">        return theAliases;</span>
    }

    @Override
    public GordianCertificate getCertificate(final GordianKeyStoreCertificateKey pKey) {
<span class="fc" id="L160">        final Map&lt;GordianCertificateId, GordianCertificate&gt; myCertMap = theSubjectCerts.get(pKey.getSubject());</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        return myCertMap == null ? null : myCertMap.get(pKey.getIssuer());</span>
    }

    @Override
    public List&lt;String&gt; getAliases() {
<span class="nc" id="L166">        return new ArrayList&lt;&gt;(theAliases.keySet());</span>
    }

    @Override
    public boolean containsAlias(final String pAlias) {
<span class="fc" id="L171">        return theAliases.containsKey(pAlias);</span>
    }

    @Override
    public int size() {
<span class="fc" id="L176">        return theAliases.size();</span>
    }

    /**
     * Reset the store.
     */
    public void reset() {
<span class="fc" id="L183">        theAliases.clear();</span>
<span class="fc" id="L184">        theSubjectCerts.clear();</span>
<span class="fc" id="L185">        theIssuerCerts.clear();</span>
<span class="fc" id="L186">    }</span>

    @Override
    public void deleteEntry(final String pAlias) {
        /* Remove the existing entry */
<span class="fc" id="L191">        final GordianKeyStoreEntry myEntry = theAliases.remove(pAlias);</span>

        /* Nothing more to do unless we are removing a certificate */
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (!(myEntry instanceof GordianKeyStoreCertificateHolder myCertHolder)) {</span>
<span class="fc" id="L195">            return;</span>
        }

        /* Access the certificate */
<span class="fc" id="L199">        final GordianCertificate myCert = getCertificate(myCertHolder.getCertificateKey());</span>

        /* If the certificate is not referenced by any other alias */
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (getCertificateAlias(myCert) == null) {</span>
            /* Remove the certificate from the maps */
<span class="fc" id="L204">            removeCertificate(myCert);</span>
        }
<span class="fc" id="L206">    }</span>

    /**
     * Remove certificate from maps.
     *
     * @param pCertificate the certificate to remove
     */
    private void removeCertificate(final GordianCertificate pCertificate) {
        /* Access the ids of the certificate */
<span class="fc" id="L215">        final GordianCertificateId mySubjectId = pCertificate.getSubject();</span>
<span class="fc" id="L216">        final GordianCertificateId myIssuerId = pCertificate.getIssuer();</span>

        /* If it is not referenced as issuer by any other certificate */
<span class="fc" id="L219">        Map&lt;GordianCertificateId, GordianCertificate&gt; myIssuedMap = theIssuerCerts.get(mySubjectId);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (isWithoutIssue(myIssuedMap)) {</span>
            /* If the certificate is not self-signed */
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            if (!pCertificate.isSelfSigned()) {</span>
                /* Remove the certificate from the issuer map */
<span class="fc" id="L224">                myIssuedMap = theIssuerCerts.get(myIssuerId);</span>
<span class="fc" id="L225">                myIssuedMap.remove(mySubjectId);</span>

                /* If the issuer now has no issued certificates */
<span class="fc bfc" id="L228" title="All 2 branches covered.">                if (isWithoutIssue(myIssuedMap)) {</span>
                    /* Purge orphan issuers */
<span class="fc" id="L230">                    purgeOrphanIssuers(myIssuerId);</span>
                }
            }

            /* Remove the certificate from the subject map */
<span class="fc" id="L235">            final Map&lt;GordianCertificateId, GordianCertificate&gt; myCertMap = theSubjectCerts.get(mySubjectId);</span>
<span class="fc" id="L236">            myCertMap.remove(myIssuerId);</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (myCertMap.isEmpty()) {</span>
<span class="fc" id="L238">                theSubjectCerts.remove(mySubjectId);</span>
            }
        }
<span class="fc" id="L241">    }</span>

    /**
     * Determine whether an issuer has no children (other than self).
     *
     * @param pIssuer the issuer Map
     * @return true/false
     */
    private static boolean isWithoutIssue(final Map&lt;GordianCertificateId, GordianCertificate&gt; pIssuer) {
        /* If the map is null or empty then there are no children */
<span class="fc bfc" id="L251" title="All 4 branches covered.">        if (pIssuer == null || pIssuer.isEmpty()) {</span>
<span class="fc" id="L252">            return true;</span>
        }

        /* If there is only one certificate in the map */
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (pIssuer.size() == 1) {</span>
            /* If the single certificate is self-signed then we are childless */
<span class="fc" id="L258">            final GordianCertificate myCert = pIssuer.values().iterator().next();</span>
<span class="fc" id="L259">            return myCert.isSelfSigned();</span>
        }

        /* Not childless */
<span class="fc" id="L263">        return false;</span>
    }

    /**
     * Purge orphan issuers.
     *
     * @param pIssuerId the issuerId to purge
     */
    private void purgeOrphanIssuers(final GordianCertificateId pIssuerId) {
        /* Remove the entry */
<span class="fc" id="L273">        theIssuerCerts.remove(pIssuerId);</span>

        /* Look for all issuers */
<span class="fc" id="L276">        final Map&lt;GordianCertificateId, GordianCertificate&gt; myCertMap = theSubjectCerts.get(pIssuerId);</span>
<span class="fc" id="L277">        final List&lt;GordianCertificate&gt; myCerts = new ArrayList&lt;&gt;(myCertMap.values());</span>

        /* Loop through all the certificates */
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for (GordianCertificate myCert : myCerts) {</span>
            /* If the certificate is not referenced by any other alias */
<span class="fc bfc" id="L282" title="All 2 branches covered.">            if (getCertificateAlias(myCert) == null) {</span>
                /* Remove the certificate from the maps */
<span class="fc" id="L284">                removeCertificate(myCert);</span>
            }
<span class="fc" id="L286">        }</span>
<span class="fc" id="L287">    }</span>

    @Override
    public void setCertificate(final String pAlias,
                               final GordianCertificate pCertificate) throws GordianException {
        /* Check the alias */
<span class="fc" id="L293">        checkAlias(pAlias);</span>

        /* Check that we are not about to replace a non-certificate */
<span class="fc" id="L296">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L297" title="3 of 4 branches missed.">        if (myEntry != null</span>
                &amp;&amp; !(myEntry instanceof GordianCoreKeyStoreCertificate)) {
<span class="nc" id="L299">            throw new GordianDataException(&quot;Alias already exists for non-certificate&quot;);</span>
        }

        /* Remove any existing entry */
<span class="fc" id="L303">        deleteEntry(pAlias);</span>

        /* Set the new value */
<span class="fc" id="L306">        final GordianKeyStoreCertificateElement myCert = new GordianKeyStoreCertificateElement(pCertificate);</span>
<span class="fc" id="L307">        theAliases.put(pAlias, myCert);</span>

        /* Store certificate */
<span class="fc" id="L310">        storeCertificate(pCertificate);</span>
<span class="fc" id="L311">    }</span>

    @Override
    public void setKeyPair(final String pAlias,
                           final GordianKeyPair pKeyPair,
                           final char[] pPassword,
                           final List&lt;GordianCertificate&gt; pCertificateChain) throws GordianException {
        /* Check the alias */
<span class="fc" id="L319">        checkAlias(pAlias);</span>

        /* Make sure that the keyPair has a private key */
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        if (pKeyPair.isPublicOnly()) {</span>
<span class="nc" id="L323">            throw new GordianDataException(&quot;Private Key missing&quot;);</span>
        }

        /* Make sure that we have a valid certificate chain */
<span class="fc" id="L327">        checkChain(pKeyPair, pCertificateChain);</span>

        /* Remove any existing entry */
<span class="fc" id="L330">        deleteEntry(pAlias);</span>

        /* Set the new value */
<span class="fc" id="L333">        final GordianKeyStorePairElement myPair = new GordianKeyStorePairElement(theFactory, thePasswordLockSpec, pKeyPair, pPassword, pCertificateChain);</span>
<span class="fc" id="L334">        theAliases.put(pAlias, myPair);</span>

        /* Store all the certificates in the chain */
<span class="fc bfc" id="L337" title="All 2 branches covered.">        for (GordianCertificate myCert : pCertificateChain) {</span>
<span class="fc" id="L338">            storeCertificate(myCert);</span>
<span class="fc" id="L339">        }</span>
<span class="fc" id="L340">    }</span>

    @Override
    public void updateCertificateChain(final String pAlias,
                                       final List&lt;GordianCertificate&gt; pCertificateChain) throws GordianException {
        /* Obtain the keyStore Entry */
<span class="fc" id="L346">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (!(myEntry instanceof GordianKeyStorePairElement myKeyPairElement)) {</span>
<span class="nc" id="L348">            throw new GordianDataException(&quot;Entry not found&quot;);</span>
        }

        /* Access old keyPair */
<span class="fc" id="L352">        final List&lt;GordianCertificate&gt; myChain = myKeyPairElement.buildChain(this);</span>
<span class="fc" id="L353">        final GordianKeyPair myKeyPair = myChain.getFirst().getKeyPair();</span>

        /* Make sure that we have a valid certificate chain */
<span class="fc" id="L356">        checkChain(myKeyPair, pCertificateChain);</span>

        /* Access old certificate */
<span class="fc" id="L359">        final GordianCertificate myOldCert = getCertificate(myKeyPairElement.getCertificateKey());</span>

        /* If the certificate is not referenced by any other alias */
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        if (getCertificateAlias(myOldCert) == null) {</span>
            /* Remove the certificate from the maps */
<span class="nc" id="L364">            removeCertificate(myOldCert);</span>
        }

        /* Update the chain */
<span class="fc" id="L368">        myKeyPairElement.updateChain(pCertificateChain);</span>

        /* Store all the certificates in the chain */
<span class="fc bfc" id="L371" title="All 2 branches covered.">        for (GordianCertificate myCert : pCertificateChain) {</span>
<span class="fc" id="L372">            storeCertificate(myCert);</span>
<span class="fc" id="L373">        }</span>
<span class="fc" id="L374">    }</span>

    @Override
    public &lt;T extends GordianKeySpec&gt; void setKey(final String pAlias,
                                                  final GordianKey&lt;T&gt; pKey,
                                                  final char[] pPassword) throws GordianException {
        /* Check the alias */
<span class="fc" id="L381">        checkAlias(pAlias);</span>

        /* Remove any existing entry */
<span class="fc" id="L384">        deleteEntry(pAlias);</span>

        /* Set the new value */
<span class="fc" id="L387">        final GordianKeyStoreKeyElement&lt;T&gt; myKey = new GordianKeyStoreKeyElement&lt;&gt;(theFactory, thePasswordLockSpec, pKey, pPassword);</span>
<span class="fc" id="L388">        theAliases.put(pAlias, myKey);</span>
<span class="fc" id="L389">    }</span>

    @Override
    public void setKeySet(final String pAlias,
                          final GordianKeySet pKeySet,
                          final char[] pPassword) throws GordianException {
        /* Check the alias */
<span class="fc" id="L396">        checkAlias(pAlias);</span>

        /* Remove any existing entry */
<span class="fc" id="L399">        deleteEntry(pAlias);</span>

        /* Set the new value */
<span class="fc" id="L402">        final GordianKeyStoreSetElement mySet = new GordianKeyStoreSetElement(theFactory, thePasswordLockSpec, pKeySet, pPassword);</span>
<span class="fc" id="L403">        theAliases.put(pAlias, mySet);</span>
<span class="fc" id="L404">    }</span>

    /**
     * Check that the alias is valid.
     *
     * @param pAlias the alias
     */
    private static void checkAlias(final String pAlias) {
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if (pAlias == null) {</span>
<span class="nc" id="L413">            throw new NullPointerException();</span>
        }
<span class="fc" id="L415">    }</span>

    @Override
    public &lt;T extends GordianKeyStoreEntry&gt; boolean entryInstanceOf(final String pAlias,
                                                                    final Class&lt;T&gt; pClazz) {
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">        if (pClazz.isAssignableFrom(GordianKeyStoreCertificate.class)) {</span>
<span class="nc" id="L421">            return isCertificateEntry(pAlias);</span>
        }
<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (pClazz.isAssignableFrom(GordianKeyStorePair.class)) {</span>
<span class="fc" id="L424">            return isKeyPairEntry(pAlias);</span>
        }
<span class="fc bfc" id="L426" title="All 2 branches covered.">        if (pClazz.isAssignableFrom(GordianKeyStoreKey.class)) {</span>
<span class="fc" id="L427">            return isKeyEntry(pAlias);</span>
        }
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        if (pClazz.isAssignableFrom(GordianKeyStoreSet.class)) {</span>
<span class="fc" id="L430">            return isKeySetEntry(pAlias);</span>
        }
<span class="nc" id="L432">        return false;</span>
    }

    @Override
    public boolean isCertificateEntry(final String pAlias) {
<span class="fc" id="L437">        return theAliases.get(pAlias) instanceof GordianKeyStoreCertificateElement;</span>
    }

    @Override
    public boolean isKeyPairEntry(final String pAlias) {
<span class="fc" id="L442">        return theAliases.get(pAlias) instanceof GordianKeyStorePairElement;</span>
    }

    @Override
    public boolean isKeyEntry(final String pAlias) {
<span class="fc" id="L447">        return theAliases.get(pAlias) instanceof GordianKeyStoreKeyElement;</span>
    }

    @Override
    public boolean isKeySetEntry(final String pAlias) {
<span class="fc" id="L452">        return theAliases.get(pAlias) instanceof GordianKeyStoreSetElement;</span>
    }

    @Override
    public GordianKeyStoreEntry getEntry(final String pAlias,
                                         final char[] pPassword) throws GordianException {
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">        if (isCertificateEntry(pAlias)) {</span>
<span class="nc" id="L459">            return getKeyStoreCertificate(pAlias);</span>
        }
<span class="fc bfc" id="L461" title="All 2 branches covered.">        if (isKeyPairEntry(pAlias)) {</span>
<span class="fc" id="L462">            return getKeyStorePair(pAlias, pPassword);</span>
        }
<span class="fc bfc" id="L464" title="All 2 branches covered.">        if (isKeyEntry(pAlias)) {</span>
<span class="fc" id="L465">            return getKeyStoreKey(pAlias, pPassword);</span>
        }
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        return isKeySetEntry(pAlias)</span>
<span class="fc" id="L468">                ? getKeyStoreSet(pAlias, pPassword)</span>
<span class="nc" id="L469">                : null;</span>
    }

    @Override
    public GordianCertificate getCertificate(final String pAlias) {
<span class="nc" id="L474">        final GordianKeyStoreCertificate myCert = getKeyStoreCertificate(pAlias);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (myCert != null) {</span>
<span class="nc" id="L476">            return myCert.getCertificate();</span>
        }
<span class="nc" id="L478">        final List&lt;GordianCertificate&gt; myChain = getCertificateChain(pAlias);</span>
<span class="nc bnc" id="L479" title="All 4 branches missed.">        return myChain == null || myChain.isEmpty() ? null : myChain.getFirst();</span>
    }

    /**
     * Obtain the keyStorePairCertificate.
     *
     * @param pAlias the alias
     * @return the certificate entry (or null)
     */
    private GordianKeyStoreCertificate getKeyStoreCertificate(final String pAlias) {
<span class="nc" id="L489">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        return myEntry instanceof GordianKeyStoreCertificateElement myElement</span>
<span class="nc" id="L491">                ? myElement.buildEntry(this)</span>
<span class="nc" id="L492">                : null;</span>
    }

    @Override
    public GordianKeyPair getKeyPair(final String pAlias,
                                     final char[] pPassword) throws GordianException {
<span class="fc" id="L498">        final GordianKeyStorePair myPair = getKeyStorePair(pAlias, pPassword);</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        return myPair == null ? null : myPair.getKeyPair();</span>
    }

    @Override
    public List&lt;GordianCertificate&gt; getCertificateChain(final String pAlias) {
<span class="fc" id="L504">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">        return myEntry instanceof GordianKeyStorePairElement myElement</span>
<span class="fc" id="L506">                ? myElement.buildChain(this)</span>
<span class="nc" id="L507">                : null;</span>
    }

    /**
     * Obtain the keyStorePair.
     *
     * @param pAlias    the alias
     * @param pPassword the password
     * @return the keyPair entry (or null)
     */
    private GordianKeyStorePair getKeyStorePair(final String pAlias,
                                                final char[] pPassword) throws GordianException {
<span class="fc" id="L519">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">        return myEntry instanceof GordianKeyStorePairElement myElement</span>
<span class="fc" id="L521">                ? myElement.buildEntry(this, pPassword)</span>
<span class="nc" id="L522">                : null;</span>
    }

    @Override
    public &lt;T extends GordianKeySpec&gt; GordianKey&lt;T&gt; getKey(final String pAlias,
                                                           final char[] pPassword) throws GordianException {
<span class="fc" id="L528">        final GordianKeyStoreKey&lt;T&gt; myKey = getKeyStoreKey(pAlias, pPassword);</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">        return myKey == null ? null : myKey.getKey();</span>
    }

    /**
     * Obtain the keyStoreKey.
     *
     * @param &lt;T&gt;       the keyType
     * @param pAlias    the alias
     * @param pPassword the password
     * @return the key entry (or null)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;T extends GordianKeySpec&gt; GordianKeyStoreKey&lt;T&gt; getKeyStoreKey(final String pAlias,
                                                                            final char[] pPassword) throws GordianException {
<span class="fc" id="L543">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">        return myEntry instanceof GordianKeyStoreKeyElement</span>
<span class="fc" id="L545">                ? ((GordianKeyStoreKeyElement&lt;T&gt;) myEntry).buildEntry(this, pPassword)</span>
<span class="nc" id="L546">                : null;</span>
    }

    @Override
    public GordianKeySet getKeySet(final String pAlias,
                                   final char[] pPassword) throws GordianException {
<span class="fc" id="L552">        final GordianKeyStoreSet mySet = getKeyStoreSet(pAlias, pPassword);</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        return mySet == null ? null : mySet.getKeySet();</span>
    }

    /**
     * Obtain the keyStoreKeySet.
     *
     * @param pAlias    the alias
     * @param pPassword the password
     * @return the keySet entry (or null)
     */
    private GordianKeyStoreSet getKeyStoreSet(final String pAlias,
                                              final char[] pPassword) throws GordianException {
<span class="fc" id="L565">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        return myEntry instanceof GordianKeyStoreSetElement myElement</span>
<span class="fc" id="L567">                ? myElement.buildEntry(this, pPassword)</span>
<span class="nc" id="L568">                : null;</span>
    }

    @Override
    public LocalDate getCreationDate(final String pAlias) {
<span class="nc" id="L573">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        return myEntry != null ? myEntry.getCreationDate() : null;</span>
    }

    @Override
    public String getCertificateAlias(final GordianCertificate pCertificate) {
        /* Loop through the alias entries */
<span class="fc bfc" id="L580" title="All 2 branches covered.">        for (Entry&lt;String, GordianKeyStoreEntry&gt; myRecord : theAliases.entrySet()) {</span>
            /* Check for match on certificate entry */
<span class="fc" id="L582">            final GordianKeyStoreEntry myEntry = myRecord.getValue();</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">            if (myEntry instanceof GordianKeyStoreCertificateHolder myHolder) {</span>
<span class="fc" id="L584">                final GordianKeyStoreCertificateKey myKey = myHolder.getCertificateKey();</span>
<span class="fc" id="L585">                final GordianCertificate myCert = getCertificate(myKey);</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">                if (pCertificate.equals(myCert)) {</span>
<span class="fc" id="L587">                    return myRecord.getKey();</span>
                }
            }
<span class="fc" id="L590">        }</span>

        /* Not found */
<span class="fc" id="L593">        return null;</span>
    }

    @Override
    public void storeCertificate(final GordianCertificate pCertificate) {
        /* Access the ids */
<span class="fc" id="L599">        final GordianCertificateId mySubjectId = pCertificate.getSubject();</span>
<span class="fc" id="L600">        final GordianCertificateId myIssuerId = pCertificate.getIssuer();</span>

        /* Add the certificate to the list of certificates for this subject */
<span class="fc" id="L603">        Map&lt;GordianCertificateId, GordianCertificate&gt; myMap = theSubjectCerts.computeIfAbsent(mySubjectId, i -&gt; new LinkedHashMap&lt;&gt;());</span>
<span class="fc" id="L604">        myMap.put(myIssuerId, pCertificate);</span>

        /* Add the certificate to the list of certificates for this issuer */
<span class="fc" id="L607">        myMap = theIssuerCerts.computeIfAbsent(myIssuerId, i -&gt; new LinkedHashMap&lt;&gt;());</span>
<span class="fc" id="L608">        myMap.put(mySubjectId, pCertificate);</span>
<span class="fc" id="L609">    }</span>

    /**
     * Check validity of certificate chain.
     *
     * @param pKeyPair the keyPair
     * @param pChain   the certificate chain
     * @throws GordianException on error
     */
    private void checkChain(final GordianKeyPair pKeyPair,
                            final List&lt;GordianCertificate&gt; pChain) throws GordianException {
        /* Make sure that we have a chain */
<span class="pc bpc" id="L621" title="2 of 4 branches missed.">        if (pChain == null || pChain.isEmpty()) {</span>
<span class="nc" id="L622">            throw new GordianDataException(&quot;Empty chain&quot;);</span>
        }

        /* Make sure that the keyPair matches end-entity certificate */
<span class="fc" id="L626">        final GordianCoreCertificate myCert = (GordianCoreCertificate) pChain.getFirst();</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">        if (!myCert.checkMatchingPublicKey(pKeyPair)) {</span>
<span class="nc" id="L628">            throw new GordianDataException(&quot;End-entity certificate does not match keyPair&quot;);</span>
        }

        /* Loop through the certificates */
<span class="fc" id="L632">        final int mySize = pChain.size();</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">        for (int i = 0; i &lt; mySize - 1; i++) {</span>
            /* Access the certificate */
<span class="fc" id="L635">            final GordianCoreCertificate myTestCert = (GordianCoreCertificate) pChain.get(i);</span>
<span class="fc" id="L636">            final GordianCoreCertificate mySignerCert = (GordianCoreCertificate) pChain.get(i + 1);</span>

            /* Check the hierarchy */
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">            if (!myTestCert.validateCertificate(mySignerCert)) {</span>
<span class="nc" id="L640">                throw new GordianDataException(&quot;Invalid certificate in path&quot;);</span>
            }

            /* Look up any existing certificate for the signer */
<span class="fc" id="L644">            final Map&lt;GordianCertificateId, GordianCertificate&gt; myMap = theSubjectCerts.get(mySignerCert.getSubject());</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">            if (myMap != null) {</span>
<span class="fc" id="L646">                final GordianCoreCertificate myExisting = (GordianCoreCertificate) myMap.values().iterator().next();</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">                if (!myExisting.checkMatchingPublicKey(mySignerCert.getKeyPair())) {</span>
<span class="nc" id="L648">                    throw new GordianDataException(&quot;Intermediate certificate does not match existing keyPair&quot;);</span>
                }
            }
        }

        /* Check that we are anchored by a root certificate */
<span class="fc" id="L654">        final GordianCertificate myRoot = pChain.get(mySize - 1);</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">        if (!((GordianCoreCertificate) myRoot).validateRootCertificate()) {</span>
<span class="nc" id="L656">            throw new GordianDataException(&quot;Invalid root certificate&quot;);</span>
        }

        /* Check that the root is known if the depth is greater than 1 */
<span class="pc bpc" id="L660" title="1 of 4 branches missed.">        if (mySize &gt; 1 &amp;&amp; getCertificateAlias(myRoot) == null) {</span>
<span class="nc" id="L661">            throw new GordianDataException(&quot;Unknown root certificate&quot;);</span>
        }
<span class="fc" id="L663">    }</span>

    @Override
    public String findIssuerCert(final IssuerAndSerialNumber pIssuer) throws GordianException {
        /* Loop through the alias entries */
<span class="nc" id="L668">        final X500Name myIssuer = pIssuer.getName();</span>
<span class="nc" id="L669">        final BigInteger mySerial = pIssuer.getSerialNumber().getValue();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        for (Entry&lt;String, GordianKeyStoreEntry&gt; myEntry : theAliases.entrySet()) {</span>
            /* If this is a keyPair(Set) entry */
<span class="nc bnc" id="L672" title="All 2 branches missed.">            if (myEntry.getValue() instanceof GordianKeyStorePairElement myPair) {</span>
                /* Access details */
<span class="nc" id="L674">                final GordianKeyStoreCertificateKey myCertKey = myPair.getCertificateChain().getFirst();</span>
<span class="nc" id="L675">                final GordianCoreCertificate myCert = (GordianCoreCertificate) getCertificate(myCertKey);</span>

                /* Return alias if we have a match */
<span class="nc bnc" id="L678" title="All 2 branches missed.">                if (myIssuer.equals(myCert.getIssuer().getName())</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">                        &amp;&amp; mySerial.equals(myCert.getSerialNo())) {</span>
<span class="nc" id="L680">                    return myEntry.getKey();</span>
                }
            }
<span class="nc" id="L683">        }</span>

        /* Reject request */
<span class="nc" id="L686">        throw new GordianDataException(&quot;Issuer not found&quot;);</span>
    }

    @Override
    public void storeToFile(final File pFile,
                            final char[] pPassword) throws GordianException {
        try {
<span class="nc" id="L693">            storeToStream(new FileOutputStream(pFile), pPassword);</span>
<span class="nc" id="L694">        } catch (IOException e) {</span>
<span class="nc" id="L695">            throw new GordianIOException(&quot;Failed to store to file&quot;, e);</span>
<span class="nc" id="L696">        }</span>
<span class="nc" id="L697">    }</span>

    @Override
    public void storeToStream(final OutputStream pOutputStream,
                              final char[] pPassword) throws GordianException {
        /* Access the Factories */
<span class="fc" id="L703">        final GordianZipFactory myZipFactory = theFactory.getZipFactory();</span>

        /* Create the lock */
<span class="fc" id="L706">        final GordianZipLock myLock = myZipFactory.factoryZipLock(pPassword);</span>

        /* Create the Zip file */
<span class="fc" id="L709">        try (GordianZipWriteFile myZipFile = myZipFactory.createZipFile(myLock, pOutputStream)) {</span>
            /* Create the XML representation */
<span class="fc" id="L711">            final GordianKeyStoreDocument myDocument = new GordianKeyStoreDocument(this);</span>

            /* Write the document to the file */
<span class="fc" id="L714">            myZipFile.writeXMLDocument(new File(ZIPENTRY), myDocument.getDocument());</span>

            /* Catch Exceptions */
<span class="nc" id="L717">        } catch (IOException e) {</span>
<span class="nc" id="L718">            throw new GordianIOException(&quot;Failed to store to stream&quot;, e);</span>
<span class="fc" id="L719">        }</span>
<span class="fc" id="L720">    }</span>

    @Override
    public boolean equals(final Object pThat) {
        /* Handle the trivial case */
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">        if (pThat == this) {</span>
<span class="nc" id="L726">            return true;</span>
        }
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (pThat == null) {</span>
<span class="nc" id="L729">            return false;</span>
        }

        /* Ensure object is correct class */
<span class="fc" id="L733">        return pThat instanceof GordianCoreKeyStore myThat</span>
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">                &amp;&amp; theSubjectCerts.equals(myThat.getSubjectMapOfMaps())</span>
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">                &amp;&amp; theIssuerCerts.equals(myThat.getIssuerMapOfMaps())</span>
<span class="pc bpc" id="L736" title="2 of 4 branches missed.">                &amp;&amp; theAliases.equals(myThat.getAliasMap());</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L741">        return Objects.hash(theSubjectCerts, theIssuerCerts, theAliases);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
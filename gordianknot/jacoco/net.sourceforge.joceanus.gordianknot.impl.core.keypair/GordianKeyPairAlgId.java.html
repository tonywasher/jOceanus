<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianKeyPairAlgId.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.core.keypair</a> &gt; <span class="el_source">GordianKeyPairAlgId.java</span></div><h1>GordianKeyPairAlgId.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.core.keypair;

import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianBIKESpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianCMCESpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianDHGroup;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianDSAElliptic;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianDSAKeyType;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianDSTU4145Elliptic;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianFRODOSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianFalconSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianGOSTElliptic;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianHQCSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairSpecBuilder;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianLMSKeySpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianMLDSASpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianMLKEMSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianMayoSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianNTRUPrimeSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianNTRUPrimeSpec.GordianNTRUPrimeParams;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianNTRUPrimeSpec.GordianNTRUPrimeType;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianNTRUSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianPicnicSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianRSAModulus;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianSABERSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianSLHDSASpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianSM2Elliptic;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianSnovaSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianXMSSKeySpec.GordianXMSSDigestType;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianXMSSKeySpec.GordianXMSSHeight;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianXMSSKeySpec.GordianXMSSMTLayers;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianDataException;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianIOException;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.cryptopro.ECGOST3410NamedCurves;
import org.bouncycastle.asn1.cryptopro.GOST3410PublicKeyAlgParameters;
import org.bouncycastle.asn1.edec.EdECObjectIdentifiers;
import org.bouncycastle.asn1.isara.IsaraObjectIdentifiers;
import org.bouncycastle.asn1.misc.MiscObjectIdentifiers;
import org.bouncycastle.asn1.nist.NISTObjectIdentifiers;
import org.bouncycastle.asn1.oiw.ElGamalParameter;
import org.bouncycastle.asn1.oiw.OIWObjectIdentifiers;
import org.bouncycastle.asn1.pkcs.DHParameter;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.asn1.pkcs.RSAPrivateKey;
import org.bouncycastle.asn1.pkcs.RSAPublicKey;
import org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers;
import org.bouncycastle.asn1.ua.DSTU4145NamedCurves;
import org.bouncycastle.asn1.ua.DSTU4145Params;
import org.bouncycastle.asn1.ua.UAObjectIdentifiers;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.DSAParameter;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.asn1.x9.DomainParameters;
import org.bouncycastle.asn1.x9.ECNamedCurveTable;
import org.bouncycastle.asn1.x9.X962Parameters;
import org.bouncycastle.asn1.x9.X9ObjectIdentifiers;
import org.bouncycastle.crypto.ec.CustomNamedCurves;
import org.bouncycastle.crypto.params.DHParameters;
import org.bouncycastle.crypto.params.ECDomainParameters;
import org.bouncycastle.pqc.asn1.PQCObjectIdentifiers;
import org.bouncycastle.pqc.asn1.XMSSKeyParams;
import org.bouncycastle.pqc.asn1.XMSSMTKeyParams;
import org.bouncycastle.pqc.crypto.lms.HSSPrivateKeyParameters;
import org.bouncycastle.pqc.crypto.lms.HSSPublicKeyParameters;
import org.bouncycastle.pqc.crypto.lms.LMSKeyParameters;
import org.bouncycastle.pqc.crypto.lms.LMSPrivateKeyParameters;
import org.bouncycastle.pqc.crypto.lms.LMSPublicKeyParameters;
import org.bouncycastle.pqc.crypto.util.PrivateKeyFactory;
import org.bouncycastle.pqc.crypto.util.PublicKeyFactory;
import org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters;
import org.bouncycastle.pqc.crypto.xmss.XMSSParameters;
import org.bouncycastle.util.Pack;

import java.io.IOException;
import java.math.BigInteger;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Mappings from EncodedId to KeyPairSpec.
 */
public class GordianKeyPairAlgId {
    /**
     * TWO as big integer.
     */
<span class="fc" id="L113">    private static final BigInteger TWO = BigInteger.valueOf(2);</span>

    /**
     * The algorithm error.
     */
    private static final String ERROR_ALGO = &quot;Unrecognised algorithm&quot;;

    /**
     * The parse error.
     */
    private static final String ERROR_PARSE = &quot;Failed to parse Key&quot;;

    /**
     * The namedCurve error.
     */
    private static final String ERROR_NAMEDCURVE = &quot;Not a Named Curve&quot;;

    /**
     * The unsupportedCurve error.
     */
    private static final String ERROR_UNSUPCURVE = &quot;Unsupported Curve: &quot;;

    /**
     * The treeDigest error.
     */
    private static final String ERROR_TREEDIGEST = &quot;Unsupported treeDigest: &quot;;

    /**
     * The parser map.
     */
    private final Map&lt;ASN1ObjectIdentifier, GordianEncodedParser&gt; theParserMap;

    /**
     * Constructor.
     */
<span class="fc" id="L148">    public GordianKeyPairAlgId() {</span>
        /* Create the map */
<span class="fc" id="L150">        theParserMap = new HashMap&lt;&gt;();</span>

        /* Register the parsers */
<span class="fc" id="L153">        GordianRSAEncodedParser.register(this);</span>
<span class="fc" id="L154">        GordianElGamalEncodedParser.register(this);</span>
<span class="fc" id="L155">        GordianDSAEncodedParser.register(this);</span>
<span class="fc" id="L156">        GordianDHEncodedParser.register(this);</span>
<span class="fc" id="L157">        GordianECEncodedParser.register(this);</span>
<span class="fc" id="L158">        GordianDSTUEncodedParser.register(this);</span>
<span class="fc" id="L159">        GordianGOSTEncodedParser.register(this);</span>
<span class="fc" id="L160">        GordianEdwardsEncodedParser.register(this);</span>
<span class="fc" id="L161">        GordianSLHDSAEncodedParser.register(this);</span>
<span class="fc" id="L162">        GordianXMSSEncodedParser.register(this);</span>
<span class="fc" id="L163">        GordianXMSSMTEncodedParser.register(this);</span>
<span class="fc" id="L164">        GordianLMSEncodedParser.register(this);</span>
<span class="fc" id="L165">        GordianNewHopeEncodedParser.register(this);</span>
<span class="fc" id="L166">        GordianCMCEEncodedParser.register(this);</span>
<span class="fc" id="L167">        GordianFrodoEncodedParser.register(this);</span>
<span class="fc" id="L168">        GordianSABEREncodedParser.register(this);</span>
<span class="fc" id="L169">        GordianMLKEMEncodedParser.register(this);</span>
<span class="fc" id="L170">        GordianMLDSAEncodedParser.register(this);</span>
<span class="fc" id="L171">        GordianHQCEncodedParser.register(this);</span>
<span class="fc" id="L172">        GordianBIKEEncodedParser.register(this);</span>
<span class="fc" id="L173">        GordianNTRUEncodedParser.register(this);</span>
<span class="fc" id="L174">        GordianNTRUPrimeEncodedParser.register(this);</span>
<span class="fc" id="L175">        GordianFalconEncodedParser.register(this);</span>
<span class="fc" id="L176">        GordianMayoEncodedParser.register(this);</span>
<span class="fc" id="L177">        GordianSnovaEncodedParser.register(this);</span>
<span class="fc" id="L178">        GordianPicnicEncodedParser.register(this);</span>
<span class="fc" id="L179">        GordianCompositeEncodedParser.register(this);</span>
<span class="fc" id="L180">    }</span>

    /**
     * Obtain KeySpec from X509KeySpec.
     * @param pEncoded X509 keySpec
     * @return the keySpec
     * @throws GordianException on error
     */
    public GordianKeyPairSpec determineKeyPairSpec(final PKCS8EncodedKeySpec pEncoded) throws GordianException {
        /* Determine the algorithm Id. */
<span class="fc" id="L190">        final PrivateKeyInfo myInfo = PrivateKeyInfo.getInstance(pEncoded.getEncoded());</span>
<span class="fc" id="L191">        final AlgorithmIdentifier myId = myInfo.getPrivateKeyAlgorithm();</span>
<span class="fc" id="L192">        final ASN1ObjectIdentifier myAlgId = myId.getAlgorithm();</span>

        /* Obtain the parser */
<span class="fc" id="L195">        final GordianEncodedParser myParser = theParserMap.get(myAlgId);</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (myParser != null) {</span>
<span class="fc" id="L197">            return myParser.determineKeyPairSpec(myInfo);</span>
        }
<span class="nc" id="L199">        throw new GordianDataException(ERROR_ALGO);</span>
    }

    /**
     * Obtain KeySpec from X509KeySpec.
     * @param pEncoded X509 keySpec
     * @return the keySpec
     * @throws GordianException on error
     */
    public GordianKeyPairSpec determineKeyPairSpec(final X509EncodedKeySpec pEncoded) throws GordianException {
        /* Determine the algorithm Id. */
<span class="fc" id="L210">        final SubjectPublicKeyInfo myInfo = SubjectPublicKeyInfo.getInstance(pEncoded.getEncoded());</span>
<span class="fc" id="L211">        final AlgorithmIdentifier myId = myInfo.getAlgorithm();</span>
<span class="fc" id="L212">        final ASN1ObjectIdentifier myAlgId = myId.getAlgorithm();</span>

        /* Obtain the parser */
<span class="fc" id="L215">        final GordianEncodedParser myParser = theParserMap.get(myAlgId);</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (myParser != null) {</span>
<span class="fc" id="L217">            return myParser.determineKeyPairSpec(myInfo);</span>
        }
<span class="nc" id="L219">        throw new GordianDataException(ERROR_ALGO);</span>
    }

    /**
     * register the parser.
     * @param pAlgId the algorithm Id.
     * @param pParser the parser
     */
    void registerParser(final ASN1ObjectIdentifier pAlgId,
                        final GordianEncodedParser pParser) {
<span class="fc" id="L229">        theParserMap.put(pAlgId, pParser);</span>
<span class="fc" id="L230">    }</span>

    /**
     * EncodedParser interface.
     */
    private interface GordianEncodedParser {
        /**
         * Obtain KeySpec from PrivateKeyInfo.
         * @param pInfo keySpec
         * @return the keySpec
         * @throws GordianException on error
         */
        GordianKeyPairSpec determineKeyPairSpec(SubjectPublicKeyInfo pInfo) throws GordianException;

        /**
         * Obtain KeySpec from SubjectPublicKeyInfo.
         * @param pInfo keySpec
         * @return the keySpec
         * @throws GordianException on error
         */
        GordianKeyPairSpec determineKeyPairSpec(PrivateKeyInfo pInfo) throws GordianException;
    }

    /**
     * RSA Encoded parser.
     */
    private static final class GordianRSAEncodedParser implements GordianEncodedParser {
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L262">            pIdManager.registerParser(PKCSObjectIdentifiers.rsaEncryption, new GordianRSAEncodedParser());</span>
<span class="fc" id="L263">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
            /* Protect against exceptions */
            try {
                /* Parse the publicKey */
<span class="fc" id="L270">                final RSAPublicKey myPublic = RSAPublicKey.getInstance(pInfo.parsePublicKey());</span>
<span class="fc" id="L271">                return determineKeyPairSpec(myPublic.getModulus());</span>

                /* Handle exceptions */
<span class="nc" id="L274">            } catch (IOException e) {</span>
<span class="nc" id="L275">                throw new GordianIOException(ERROR_PARSE, e);</span>
            }
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
            /* Protect against exceptions */
            try {
                /* Parse the publicKey */
<span class="fc" id="L284">                final RSAPrivateKey myPrivate = RSAPrivateKey.getInstance(pInfo.parsePrivateKey());</span>
<span class="fc" id="L285">                return determineKeyPairSpec(myPrivate.getModulus());</span>

                /* Handle exceptions */
<span class="nc" id="L288">            } catch (IOException e) {</span>
<span class="nc" id="L289">                throw new GordianIOException(ERROR_PARSE, e);</span>
            }
        }

        /**
         * Obtain keySpec from Modulus.
         * @param pModulus the modulus
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final BigInteger pModulus) throws GordianException {
<span class="fc" id="L300">            final GordianRSAModulus myModulus = GordianRSAModulus.getModulusForInteger(pModulus);</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            if (myModulus == null) {</span>
<span class="nc" id="L302">                throw new GordianDataException(&quot;RSA strength not supported: &quot; + pModulus.bitLength());</span>
            }
<span class="fc" id="L304">            return  GordianKeyPairSpecBuilder.rsa(myModulus);</span>
        }
    }

    /**
     * DSA Encoded parser.
     */
    private static final class GordianDSAEncodedParser implements GordianEncodedParser {
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L317">            pIdManager.registerParser(X9ObjectIdentifiers.id_dsa, new GordianDSAEncodedParser());</span>
<span class="fc" id="L318">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L322">            final AlgorithmIdentifier myId = pInfo.getAlgorithm();</span>
<span class="fc" id="L323">            final DSAParameter myParms = DSAParameter.getInstance(myId.getParameters());</span>
<span class="fc" id="L324">            return determineKeyPairSpec(myParms);</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L329">            final AlgorithmIdentifier myId = pInfo.getPrivateKeyAlgorithm();</span>
<span class="fc" id="L330">            final DSAParameter myParms = DSAParameter.getInstance(myId.getParameters());</span>
<span class="fc" id="L331">            return determineKeyPairSpec(myParms);</span>
        }

        /**
         * Obtain keySpec from Parameters.
         * @param pParms the parameters
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final DSAParameter pParms) throws GordianException {
<span class="fc" id="L341">            final GordianDSAKeyType myKeyType = GordianDSAKeyType.getDSATypeForParms(pParms);</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            if (myKeyType == null) {</span>
<span class="nc" id="L343">                throw new GordianDataException(&quot;Unsupported DSA parameters: &quot;</span>
<span class="nc" id="L344">                        + pParms.getP().bitLength() + &quot;:&quot; + pParms.getQ().bitLength());</span>
            }
<span class="fc" id="L346">            return  GordianKeyPairSpecBuilder.dsa(myKeyType);</span>
        }
    }

    /**
     * DH Encoded parser.
     */
<span class="fc" id="L353">    public static class GordianDHEncodedParser implements GordianEncodedParser {</span>
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L359">            pIdManager.registerParser(PKCSObjectIdentifiers.dhKeyAgreement, new GordianDHEncodedParser());</span>
<span class="fc" id="L360">            pIdManager.registerParser(X9ObjectIdentifiers.dhpublicnumber, new GordianDHEncodedParser());</span>
<span class="fc" id="L361">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L365">            final DHParameters myParms = determineParameters(pInfo.getAlgorithm());</span>
<span class="fc" id="L366">            return determineKeyPairSpec(myParms);</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L371">            final DHParameters myParms = determineParameters(pInfo.getPrivateKeyAlgorithm());</span>
<span class="fc" id="L372">            return determineKeyPairSpec(myParms);</span>
        }

        /**
         * Obtain parameters from encoded sequence.
         * @param pId the algorithm Identifier
         * @return the parameters
         */
        public static DHParameters determineParameters(final AlgorithmIdentifier pId) {
            /* Access algorithmId */
<span class="fc" id="L382">            final ASN1ObjectIdentifier myId = pId.getAlgorithm();</span>

            /* If this is key agreement */
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            if (PKCSObjectIdentifiers.dhKeyAgreement.equals(myId)) {</span>
                /* Access the DHParameter */
<span class="nc" id="L387">                final DHParameter myParams = DHParameter.getInstance(pId.getParameters());</span>

                /* If we have an L value */
<span class="nc bnc" id="L390" title="All 2 branches missed.">                return myParams.getL() != null</span>
<span class="nc" id="L391">                       ? new DHParameters(myParams.getP(), myParams.getG(), null, myParams.getL().intValue())</span>
<span class="nc" id="L392">                       : new DHParameters(myParams.getP(), myParams.getG());</span>

<span class="pc bpc" id="L394" title="1 of 2 branches missed.">            } else if (X9ObjectIdentifiers.dhpublicnumber.equals(myId)) {</span>
                /* Access Domain Parameters */
<span class="fc" id="L396">                final DomainParameters myParams = DomainParameters.getInstance(pId.getParameters());</span>

<span class="fc" id="L398">                return new DHParameters(myParams.getP(), myParams.getG(), myParams.getQ(), myParams.getJ(), null);</span>
            } else {
<span class="nc" id="L400">                throw new IllegalArgumentException(&quot;unknown algorithm type: &quot; + myId);</span>
            }
        }

        /**
         * Obtain keySpec from Parameters.
         * @param pParms the parameters
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final DHParameters pParms) throws GordianException {
<span class="fc" id="L411">            final GordianDHGroup myGroup = GordianDHGroup.getGroupForParams(pParms);</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">            if (myGroup == null) {</span>
<span class="nc" id="L413">                throw new GordianDataException(&quot;Unsupported DH parameters: &quot;</span>
<span class="nc" id="L414">                        + pParms.getP().bitLength());</span>
            }
<span class="fc" id="L416">            return  GordianKeyPairSpecBuilder.dh(myGroup);</span>
        }
    }

    /**
     * ElGamal Encoded parser.
     */
<span class="fc" id="L423">    public static class GordianElGamalEncodedParser implements GordianEncodedParser {</span>
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L429">            pIdManager.registerParser(OIWObjectIdentifiers.elGamalAlgorithm, new GordianElGamalEncodedParser());</span>
<span class="fc" id="L430">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L434">            final DHParameters myParms = determineParameters(pInfo.getAlgorithm());</span>
<span class="fc" id="L435">            return determineKeyPairSpec(myParms);</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L440">            final DHParameters myParms = determineParameters(pInfo.getPrivateKeyAlgorithm());</span>
<span class="fc" id="L441">            return determineKeyPairSpec(myParms);</span>
        }

        /**
         * Obtain parameters from encoded sequence.
         * @param pId the algorithm Identifier
         * @return the parameters
         */
        public static DHParameters determineParameters(final AlgorithmIdentifier pId) {
            /* Access the ElGamalParameter */
<span class="fc" id="L451">            final ElGamalParameter myParams = ElGamalParameter.getInstance(pId.getParameters());</span>

            /* Convert to DH parameters */
<span class="fc" id="L454">            return new DHParameters(myParams.getP(), TWO, myParams.getG());</span>
        }

        /**
         * Obtain keySpec from Parameters.
         * @param pParms the parameters
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final DHParameters pParms) throws GordianException {
<span class="fc" id="L464">            final GordianDHGroup myGroup = GordianDHGroup.getGroupForParams(pParms);</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">            if (myGroup == null) {</span>
<span class="nc" id="L466">                throw new GordianDataException(&quot;Unsupported DH parameters: &quot;</span>
<span class="nc" id="L467">                        + pParms.getP().bitLength());</span>
            }
<span class="fc" id="L469">            return  GordianKeyPairSpecBuilder.elGamal(myGroup);</span>
        }
    }

    /**
     * EC Encoded parser.
     */
    private static final class GordianECEncodedParser implements GordianEncodedParser {
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L482">            pIdManager.registerParser(X9ObjectIdentifiers.id_ecPublicKey, new GordianECEncodedParser());</span>
<span class="fc" id="L483">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L487">            final AlgorithmIdentifier myId = pInfo.getAlgorithm();</span>
<span class="fc" id="L488">            final X962Parameters myParms = X962Parameters.getInstance(myId.getParameters());</span>
<span class="fc" id="L489">            return determineKeyPairSpec(myParms);</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L494">            final AlgorithmIdentifier myId = pInfo.getPrivateKeyAlgorithm();</span>
<span class="fc" id="L495">            final X962Parameters myParms = X962Parameters.getInstance(myId.getParameters());</span>
<span class="fc" id="L496">            return determineKeyPairSpec(myParms);</span>
        }

        /**
         * Obtain keySpec from Parameters.
         * @param pParms the parameters
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final X962Parameters pParms) throws GordianException {
            /* Reject if not a named curve */
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">            if (!pParms.isNamedCurve()) {</span>
<span class="nc" id="L508">                throw new GordianDataException(ERROR_NAMEDCURVE);</span>
            }

            /* Check for EC named curve */
<span class="fc" id="L512">            final ASN1ObjectIdentifier myId = (ASN1ObjectIdentifier) pParms.getParameters();</span>
<span class="fc" id="L513">            String myName = CustomNamedCurves.getName(myId);</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">            if (myName == null) {</span>
<span class="nc" id="L515">                myName = ECNamedCurveTable.getName(myId);</span>
            }
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">            if (myName != null) {</span>
<span class="fc" id="L518">                final GordianDSAElliptic myDSACurve = GordianDSAElliptic.getCurveForName(myName);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">                if (myDSACurve != null) {</span>
<span class="fc" id="L520">                    return GordianKeyPairSpecBuilder.ec(myDSACurve);</span>
                }
<span class="fc" id="L522">                final GordianSM2Elliptic mySM2Curve = GordianSM2Elliptic.getCurveForName(myName);</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">                if (mySM2Curve != null) {</span>
<span class="fc" id="L524">                    return GordianKeyPairSpecBuilder.sm2(mySM2Curve);</span>
                }
<span class="nc" id="L526">                throw new GordianDataException(ERROR_UNSUPCURVE + myName);</span>
            }

            /* Curve is not supported */
<span class="nc" id="L530">            throw new GordianDataException(ERROR_UNSUPCURVE + pParms);</span>
        }
    }

    /**
     * DSTU Encoded parser.
     */
    private static final class GordianDSTUEncodedParser implements GordianEncodedParser {
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L543">            pIdManager.registerParser(UAObjectIdentifiers.dstu4145be, new GordianDSTUEncodedParser());</span>
<span class="fc" id="L544">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L548">            final AlgorithmIdentifier myId = pInfo.getAlgorithm();</span>
<span class="fc" id="L549">            final DSTU4145Params  myParms = DSTU4145Params.getInstance(myId.getParameters());</span>
<span class="fc" id="L550">            return determineKeyPairSpec(myParms);</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L555">            final AlgorithmIdentifier myId = pInfo.getPrivateKeyAlgorithm();</span>
<span class="fc" id="L556">            final X962Parameters myParms = X962Parameters.getInstance(myId.getParameters());</span>
<span class="fc" id="L557">            return determineKeyPairSpec(myParms);</span>
        }

        /**
         * Obtain keySpec from Parameters.
         * @param pParms the parameters
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final DSTU4145Params pParms) throws GordianException {
            /* Reject if not a named curve */
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">            if (!pParms.isNamedCurve()) {</span>
<span class="nc" id="L569">                throw new GordianDataException(ERROR_NAMEDCURVE);</span>
            }
<span class="fc" id="L571">            return determineKeyPairSpec(pParms.getNamedCurve());</span>
        }

        /**
         * Obtain keySpec from Parameters.
         * @param pParms the parameters
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final X962Parameters pParms) throws GordianException {
            /* Reject if not a named curve */
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">            if (!pParms.isNamedCurve()) {</span>
<span class="nc" id="L583">                throw new GordianDataException(ERROR_NAMEDCURVE);</span>
            }
<span class="fc" id="L585">            return determineKeyPairSpec((ASN1ObjectIdentifier) pParms.getParameters());</span>
        }

        /**
         * Obtain keySpec from curveId.
         * @param pId the curveId
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final ASN1ObjectIdentifier pId) throws GordianException {
            /* Check for EC named surve */
<span class="fc" id="L596">            final String myName = pId.toString();</span>
<span class="fc" id="L597">            final ECDomainParameters myParms = DSTU4145NamedCurves.getByOID(pId);</span>
<span class="fc" id="L598">            final GordianDSTU4145Elliptic myCurve = GordianDSTU4145Elliptic.getCurveForName(myName);</span>
<span class="pc bpc" id="L599" title="2 of 4 branches missed.">            if (myParms == null || myCurve == null) {</span>
<span class="nc" id="L600">                throw new GordianDataException(ERROR_UNSUPCURVE + myName);</span>
            }
<span class="fc" id="L602">            return GordianKeyPairSpecBuilder.dstu4145(myCurve);</span>
        }
    }

    /**
     * GOST Encoded parser.
     */
    private static final class GordianGOSTEncodedParser implements GordianEncodedParser {
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L615">            final GordianGOSTEncodedParser myParser = new GordianGOSTEncodedParser();</span>
<span class="fc" id="L616">            pIdManager.registerParser(RosstandartObjectIdentifiers.id_tc26_gost_3410_12_256, myParser);</span>
<span class="fc" id="L617">            pIdManager.registerParser(RosstandartObjectIdentifiers.id_tc26_gost_3410_12_512, myParser);</span>
<span class="fc" id="L618">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L622">            return determineKeyPairSpec(pInfo.getAlgorithm());</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L627">            return determineKeyPairSpec(pInfo.getPrivateKeyAlgorithm());</span>
        }

        /**
         * Obtain keySpec from Parameters.
         * @param pId the algorithmId
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final AlgorithmIdentifier pId) throws GordianException {
            /* Determine the curve name */
<span class="fc" id="L638">            final GOST3410PublicKeyAlgParameters myParms = GOST3410PublicKeyAlgParameters.getInstance(pId.getParameters());</span>
<span class="fc" id="L639">            final ASN1ObjectIdentifier myId = myParms.getPublicKeyParamSet();</span>
<span class="fc" id="L640">            final String myName = ECGOST3410NamedCurves.getName(myId);</span>

            /* Determine curve */
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">            if (myName != null) {</span>
<span class="fc" id="L644">                final GordianGOSTElliptic myCurve = GordianGOSTElliptic.getCurveForName(myName);</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">                if (myCurve == null) {</span>
<span class="nc" id="L646">                    throw new GordianDataException(ERROR_UNSUPCURVE + myName);</span>
                }
<span class="fc" id="L648">                return GordianKeyPairSpecBuilder.gost2012(myCurve);</span>
            }

            /* Curve is not supported */
<span class="nc" id="L652">            throw new GordianDataException(ERROR_UNSUPCURVE + myParms);</span>
        }
    }

    /**
     * SLHDSA Encoded parser.
     */
    private static class GordianSLHDSAEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L669">        GordianSLHDSAEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L670">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L671">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L678" title="All 2 branches covered.">            for (GordianSLHDSASpec mySpec : GordianSLHDSASpec.values()) {</span>
<span class="fc" id="L679">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianSLHDSAEncodedParser(GordianKeyPairSpecBuilder.slhdsa(mySpec)));</span>
            }
<span class="fc" id="L681">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L685">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L690">            return theKeySpec;</span>
        }
    }

    /**
     * CMCE Encoded parser.
     */
    private static class GordianCMCEEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L707">        GordianCMCEEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L708">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L709">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L716" title="All 2 branches covered.">            for (GordianCMCESpec mySpec : GordianCMCESpec.values()) {</span>
<span class="fc" id="L717">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianCMCEEncodedParser(GordianKeyPairSpecBuilder.cmce(mySpec)));</span>
            }
<span class="fc" id="L719">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L723">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L728">            return theKeySpec;</span>
        }
    }

    /**
     * Frodo Encoded parser.
     */
    private static class GordianFrodoEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L745">        GordianFrodoEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L746">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L747">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L754" title="All 2 branches covered.">            for (GordianFRODOSpec mySpec : GordianFRODOSpec.values()) {</span>
<span class="fc" id="L755">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianFrodoEncodedParser(GordianKeyPairSpecBuilder.frodo(mySpec)));</span>
            }
<span class="fc" id="L757">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L761">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L766">            return theKeySpec;</span>
        }
    }

    /**
     * SABER Encoded parser.
     */
    private static class GordianSABEREncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L783">        GordianSABEREncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L784">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L785">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L792" title="All 2 branches covered.">            for (GordianSABERSpec mySpec : GordianSABERSpec.values()) {</span>
<span class="fc" id="L793">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianSABEREncodedParser(GordianKeyPairSpecBuilder.saber(mySpec)));</span>
            }
<span class="fc" id="L795">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L799">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L804">            return theKeySpec;</span>
        }
    }

    /**
     * MLKEM Encoded parser.
     */
    private static class GordianMLKEMEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L821">        GordianMLKEMEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L822">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L823">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L830" title="All 2 branches covered.">            for (GordianMLKEMSpec mySpec : GordianMLKEMSpec.values()) {</span>
<span class="fc" id="L831">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianMLKEMEncodedParser(GordianKeyPairSpecBuilder.mlkem(mySpec)));</span>
            }
<span class="fc" id="L833">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L837">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L842">            return theKeySpec;</span>
        }
    }

    /**
     * MLDSA Encoded parser.
     */
    private static class GordianMLDSAEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L859">        GordianMLDSAEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L860">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L861">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L868" title="All 2 branches covered.">            for (GordianMLDSASpec mySpec : GordianMLDSASpec.values()) {</span>
<span class="fc" id="L869">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianMLDSAEncodedParser(GordianKeyPairSpecBuilder.mldsa(mySpec)));</span>
            }
<span class="fc" id="L871">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L875">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L880">            return theKeySpec;</span>
        }
    }

    /**
     * HQC Encoded parser.
     */
    private static class GordianHQCEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L897">        GordianHQCEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L898">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L899">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L906" title="All 2 branches covered.">            for (GordianHQCSpec mySpec : GordianHQCSpec.values()) {</span>
<span class="fc" id="L907">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianHQCEncodedParser(GordianKeyPairSpecBuilder.hqc(mySpec)));</span>
            }
<span class="fc" id="L909">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L913">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L918">            return theKeySpec;</span>
        }
    }

    /**
     * BIKE Encoded parser.
     */
    private static class GordianBIKEEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L935">        GordianBIKEEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L936">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L937">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L944" title="All 2 branches covered.">            for (GordianBIKESpec mySpec : GordianBIKESpec.values()) {</span>
<span class="fc" id="L945">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianBIKEEncodedParser(GordianKeyPairSpecBuilder.bike(mySpec)));</span>
            }
<span class="fc" id="L947">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L951">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L956">            return theKeySpec;</span>
        }
    }

    /**
     * NTRU Encoded parser.
     */
    private static class GordianNTRUEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L973">        GordianNTRUEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L974">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L975">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L982" title="All 2 branches covered.">            for (GordianNTRUSpec mySpec : GordianNTRUSpec.values()) {</span>
<span class="fc" id="L983">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianNTRUEncodedParser(GordianKeyPairSpecBuilder.ntru(mySpec)));</span>
            }
<span class="fc" id="L985">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L989">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L994">            return theKeySpec;</span>
        }
    }

    /**
     * NTRUPrime Encoded parser.
     */
    private static class GordianNTRUPrimeEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L1011">        GordianNTRUPrimeEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L1012">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L1013">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L1020" title="All 2 branches covered.">            for (GordianNTRUPrimeParams myParams : GordianNTRUPrimeParams.values()) {</span>
<span class="fc" id="L1021">                pIdManager.registerParser(myParams.getNTRULIdentifier(),</span>
<span class="fc" id="L1022">                        new GordianNTRUPrimeEncodedParser(GordianKeyPairSpecBuilder.ntruprime(new GordianNTRUPrimeSpec(GordianNTRUPrimeType.NTRUL, myParams))));</span>
<span class="fc" id="L1023">                pIdManager.registerParser(myParams.getSNTRUIdentifier(),</span>
<span class="fc" id="L1024">                        new GordianNTRUPrimeEncodedParser(GordianKeyPairSpecBuilder.ntruprime(new GordianNTRUPrimeSpec(GordianNTRUPrimeType.SNTRU, myParams))));</span>
            }
<span class="fc" id="L1026">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1030">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1035">            return theKeySpec;</span>
        }
    }

    /**
     * Falcon Encoded parser.
     */
    private static class GordianFalconEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L1052">        GordianFalconEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L1053">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L1054">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L1061" title="All 2 branches covered.">            for (GordianFalconSpec mySpec : GordianFalconSpec.values()) {</span>
<span class="fc" id="L1062">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianFalconEncodedParser(GordianKeyPairSpecBuilder.falcon(mySpec)));</span>
            }
<span class="fc" id="L1064">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1068">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1073">            return theKeySpec;</span>
        }
    }

    /**
     * Mayo Encoded parser.
     */
    private static class GordianMayoEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L1090">        GordianMayoEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L1091">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L1092">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L1099" title="All 2 branches covered.">            for (GordianMayoSpec mySpec : GordianMayoSpec.values()) {</span>
<span class="fc" id="L1100">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianMayoEncodedParser(GordianKeyPairSpecBuilder.mayo(mySpec)));</span>
            }
<span class="fc" id="L1102">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1106">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1111">            return theKeySpec;</span>
        }
    }

    /**
     * Snova Encoded parser.
     */
    private static class GordianSnovaEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L1128">        GordianSnovaEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L1129">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L1130">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L1137" title="All 2 branches covered.">            for (GordianSnovaSpec mySpec : GordianSnovaSpec.values()) {</span>
<span class="fc" id="L1138">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianSnovaEncodedParser(GordianKeyPairSpecBuilder.snova(mySpec)));</span>
            }
<span class="fc" id="L1140">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1144">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1149">            return theKeySpec;</span>
        }
    }

    /**
     * Picnic Encoded parser.
     */
    private static class GordianPicnicEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L1166">        GordianPicnicEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L1167">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L1168">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc bfc" id="L1175" title="All 2 branches covered.">            for (GordianPicnicSpec mySpec : GordianPicnicSpec.values()) {</span>
<span class="fc" id="L1176">                pIdManager.registerParser(mySpec.getIdentifier(), new GordianPicnicEncodedParser(GordianKeyPairSpecBuilder.picnic(mySpec)));</span>
            }
<span class="fc" id="L1178">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1182">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1187">            return theKeySpec;</span>
        }
    }

    /**
     * NewHope Encoded parser.
     */
    private static final class GordianNewHopeEncodedParser implements GordianEncodedParser {
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L1200">            pIdManager.registerParser(PQCObjectIdentifiers.newHope, new GordianNewHopeEncodedParser());</span>
<span class="fc" id="L1201">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) {
<span class="fc" id="L1205">            return GordianKeyPairSpecBuilder.newHope();</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) {
<span class="fc" id="L1210">            return GordianKeyPairSpecBuilder.newHope();</span>
        }
    }

    /**
     * XMSS Encoded parser.
     */
    private static final class GordianXMSSEncodedParser implements GordianEncodedParser {
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L1223">            pIdManager.registerParser(PQCObjectIdentifiers.xmss, new GordianXMSSEncodedParser());</span>
<span class="fc" id="L1224">            pIdManager.registerParser(IsaraObjectIdentifiers.id_alg_xmss, new GordianXMSSEncodedParser());</span>
<span class="fc" id="L1225">        }</span>


        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1230">            final AlgorithmIdentifier myId = pInfo.getAlgorithm();</span>
<span class="fc" id="L1231">            final XMSSKeyParams myParms = XMSSKeyParams.getInstance(myId.getParameters());</span>
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">            if (myParms != null) {</span>
<span class="nc" id="L1233">                return determineKeyPairSpec(myParms);</span>
            }

            /* Protect against exceptions */
            try {
<span class="fc" id="L1238">                final byte[] keyEnc = Objects.requireNonNull(ASN1OctetString.getInstance(pInfo.parsePublicKey())).getOctets();</span>
<span class="fc" id="L1239">                final int myOID = Pack.bigEndianToInt(keyEnc, 0);</span>
<span class="fc" id="L1240">                final XMSSParameters myParams = XMSSParameters.lookupByOID(myOID);</span>
<span class="fc" id="L1241">                return GordianKeyPairSpecBuilder.xmss(determineKeyType(myParams.getTreeDigestOID()),</span>
<span class="fc" id="L1242">                        determineHeight(myParams.getHeight()));</span>
<span class="nc" id="L1243">            } catch (IOException e) {</span>
<span class="nc" id="L1244">                throw new GordianIOException(&quot;Failed to resolve key&quot;, e);</span>
            }
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1250">            final AlgorithmIdentifier myId = pInfo.getPrivateKeyAlgorithm();</span>
<span class="fc" id="L1251">            final XMSSKeyParams myParms = XMSSKeyParams.getInstance(myId.getParameters());</span>
<span class="fc" id="L1252">            return determineKeyPairSpec(myParms);</span>
        }

        /**
         * Obtain keySpec from Parameters.
         * @param pParms the parameters
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final XMSSKeyParams pParms) throws GordianException {
<span class="fc" id="L1262">            final ASN1ObjectIdentifier myDigest = pParms.getTreeDigest().getAlgorithm();</span>
<span class="fc" id="L1263">            final GordianXMSSHeight myHeight = determineHeight(pParms.getHeight());</span>
<span class="fc" id="L1264">            return GordianKeyPairSpecBuilder.xmss(determineKeyType(myDigest), myHeight);</span>
        }

        /**
         * Obtain keyType from digest.
         * @param pDigest the treeDigest
         * @return the keyType
         * @throws GordianException on error
         */
        static GordianXMSSDigestType determineKeyType(final ASN1ObjectIdentifier pDigest) throws GordianException {
<span class="fc bfc" id="L1274" title="All 2 branches covered.">            if (pDigest.equals(NISTObjectIdentifiers.id_sha256)) {</span>
<span class="fc" id="L1275">                return GordianXMSSDigestType.SHA256;</span>
            }
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">            if (pDigest.equals(NISTObjectIdentifiers.id_sha512)) {</span>
<span class="fc" id="L1278">                return GordianXMSSDigestType.SHA512;</span>
            }
<span class="nc bnc" id="L1280" title="All 2 branches missed.">            if (pDigest.equals(NISTObjectIdentifiers.id_shake128)) {</span>
<span class="nc" id="L1281">                return GordianXMSSDigestType.SHAKE128;</span>
            }
<span class="nc bnc" id="L1283" title="All 2 branches missed.">            if (pDigest.equals(NISTObjectIdentifiers.id_shake256)) {</span>
<span class="nc" id="L1284">                return GordianXMSSDigestType.SHAKE256;</span>
            }

            /* Tree Digest is not supported */
<span class="nc" id="L1288">            throw new GordianDataException(ERROR_TREEDIGEST + pDigest);</span>
        }

        /**
         * Obtain height.
         * @param pHeight the height
         * @return the xmssHeight
         * @throws GordianException on error
         */
        static GordianXMSSHeight determineHeight(final int pHeight) throws GordianException {
            /* Loo through the heights */
<span class="pc bpc" id="L1299" title="1 of 2 branches missed.">            for (GordianXMSSHeight myHeight : GordianXMSSHeight.values()) {</span>
<span class="pc bpc" id="L1300" title="1 of 2 branches missed.">                if (myHeight.getHeight() == pHeight) {</span>
<span class="fc" id="L1301">                    return myHeight;</span>
                }
            }

            /* Height is not supported */
<span class="nc" id="L1306">            throw new GordianDataException(&quot;Inavlid height: &quot; + pHeight);</span>
        }
    }

    /**
     * XMSSMT Encoded parser.
     */
    private static final class GordianXMSSMTEncodedParser implements GordianEncodedParser {
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L1319">            pIdManager.registerParser(PQCObjectIdentifiers.xmss_mt, new GordianXMSSMTEncodedParser());</span>
<span class="fc" id="L1320">            pIdManager.registerParser(IsaraObjectIdentifiers.id_alg_xmssmt, new GordianXMSSMTEncodedParser());</span>
<span class="fc" id="L1321">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="nc" id="L1325">            final AlgorithmIdentifier myId = pInfo.getAlgorithm();</span>
<span class="nc" id="L1326">            final XMSSMTKeyParams myParms = XMSSMTKeyParams.getInstance(myId.getParameters());</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">            if (myParms != null) {</span>
<span class="nc" id="L1328">                return determineKeyPairSpec(myParms);</span>
            }

            /* Protect against exceptions */
            try {
<span class="nc" id="L1333">                final byte[] keyEnc = Objects.requireNonNull(ASN1OctetString.getInstance(pInfo.parsePublicKey())).getOctets();</span>
<span class="nc" id="L1334">                final int myOID = Pack.bigEndianToInt(keyEnc, 0);</span>
<span class="nc" id="L1335">                final XMSSMTParameters myParams = XMSSMTParameters.lookupByOID(myOID);</span>
<span class="nc" id="L1336">                return GordianKeyPairSpecBuilder.xmssmt(GordianXMSSEncodedParser.determineKeyType(myParams.getTreeDigestOID()),</span>
<span class="nc" id="L1337">                        GordianXMSSEncodedParser.determineHeight(myParams.getHeight()), determineLayers(myParams.getLayers()));</span>
<span class="nc" id="L1338">            } catch (IOException e) {</span>
<span class="nc" id="L1339">                throw new GordianIOException(&quot;Failed to resolve key&quot;,  e);</span>
            }
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="nc" id="L1345">            final AlgorithmIdentifier myId = pInfo.getPrivateKeyAlgorithm();</span>
<span class="nc" id="L1346">            final XMSSMTKeyParams myParms = XMSSMTKeyParams.getInstance(myId.getParameters());</span>
<span class="nc" id="L1347">            return determineKeyPairSpec(myParms);</span>
        }

        /**
         * Obtain keySpec from Parameters.
         * @param pParms the parameters
         * @return the keySpec
         * @throws GordianException on error
         */
        private static GordianKeyPairSpec determineKeyPairSpec(final XMSSMTKeyParams pParms) throws GordianException {
<span class="nc" id="L1357">            final ASN1ObjectIdentifier myDigest = pParms.getTreeDigest().getAlgorithm();</span>
<span class="nc" id="L1358">            final GordianXMSSHeight myHeight = GordianXMSSEncodedParser.determineHeight(pParms.getHeight());</span>
<span class="nc" id="L1359">            final GordianXMSSMTLayers myLayers = determineLayers(pParms.getLayers());</span>
<span class="nc" id="L1360">            return GordianKeyPairSpecBuilder.xmssmt(GordianXMSSEncodedParser.determineKeyType(myDigest), myHeight, myLayers);</span>
        }

        /**
         * Obtain layers.
         * @param pLayers the layers
         * @return the xmssMTLayers
         * @throws GordianException on error
         */
        static GordianXMSSMTLayers determineLayers(final int pLayers) throws GordianException {
            /* Loo through the heights */
<span class="nc bnc" id="L1371" title="All 2 branches missed.">            for (GordianXMSSMTLayers myLayers : GordianXMSSMTLayers.values()) {</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">                if (myLayers.getLayers() == pLayers) {</span>
<span class="nc" id="L1373">                    return myLayers;</span>
                }
            }

            /* Layers is not supported */
<span class="nc" id="L1378">            throw new GordianDataException(&quot;Invalid layers: &quot; + pLayers);</span>
        }
    }

    /**
     * Edwards Encoded parser.
     */
    private static class GordianEdwardsEncodedParser implements GordianEncodedParser {
        /**
         * AsymKeySpec.
         */
        private final GordianKeyPairSpec theKeySpec;

        /**
         * Constructor.
         * @param pKeySpec the keySpec
         */
<span class="fc" id="L1395">        GordianEdwardsEncodedParser(final GordianKeyPairSpec pKeySpec) {</span>
<span class="fc" id="L1396">            theKeySpec = pKeySpec;</span>
<span class="fc" id="L1397">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L1404">            pIdManager.registerParser(EdECObjectIdentifiers.id_X25519, new GordianEdwardsEncodedParser(GordianKeyPairSpecBuilder.x25519()));</span>
<span class="fc" id="L1405">            pIdManager.registerParser(EdECObjectIdentifiers.id_X448, new GordianEdwardsEncodedParser(GordianKeyPairSpecBuilder.x448()));</span>
<span class="fc" id="L1406">            pIdManager.registerParser(EdECObjectIdentifiers.id_Ed25519, new GordianEdwardsEncodedParser(GordianKeyPairSpecBuilder.ed25519()));</span>
<span class="fc" id="L1407">            pIdManager.registerParser(EdECObjectIdentifiers.id_Ed448, new GordianEdwardsEncodedParser(GordianKeyPairSpecBuilder.ed448()));</span>
<span class="fc" id="L1408">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1412">            return theKeySpec;</span>
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
<span class="fc" id="L1417">            return theKeySpec;</span>
        }
    }

    /**
     * LMS Encoded parser.
     */
    private static final class GordianLMSEncodedParser implements GordianEncodedParser {
        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L1430">            pIdManager.registerParser(PKCSObjectIdentifiers.id_alg_hss_lms_hashsig, new GordianLMSEncodedParser());</span>
<span class="fc" id="L1431">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
            /* Protect against exceptions */
            try {
                /* Parse public key */
<span class="fc" id="L1438">                final LMSKeyParameters myParms = (LMSKeyParameters) PublicKeyFactory.createKey(pInfo);</span>
<span class="pc bpc" id="L1439" title="1 of 2 branches missed.">                if (myParms instanceof HSSPublicKeyParameters myPublic) {</span>
<span class="fc" id="L1440">                    final int myDepth = myPublic.getL();</span>
<span class="fc" id="L1441">                    final LMSPublicKeyParameters myLMSPublicKey = myPublic.getLMSPublicKey();</span>
<span class="fc" id="L1442">                    final GordianLMSKeySpec myKeySpec = determineKeyPairSpec(myLMSPublicKey);</span>
<span class="fc" id="L1443">                    return GordianKeyPairSpecBuilder.hss(myKeySpec, myDepth);</span>

                } else {
<span class="nc" id="L1446">                    final LMSPublicKeyParameters myPublic = (LMSPublicKeyParameters) myParms;</span>
<span class="nc" id="L1447">                    final GordianLMSKeySpec myKeySpec = determineKeyPairSpec(myPublic);</span>
<span class="nc" id="L1448">                    return GordianKeyPairSpecBuilder.lms(myKeySpec);</span>
                }

                /* Handle exceptions */
<span class="nc" id="L1452">            } catch (IOException e) {</span>
<span class="nc" id="L1453">                throw new GordianIOException(ERROR_PARSE, e);</span>
            }
         }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
            /* Protect against exceptions */
            try {
                /* Parse public key */
<span class="fc" id="L1462">                final LMSKeyParameters myParms = (LMSKeyParameters) PrivateKeyFactory.createKey(pInfo);</span>
<span class="pc bpc" id="L1463" title="1 of 2 branches missed.">                if (myParms instanceof HSSPrivateKeyParameters) {</span>
<span class="fc" id="L1464">                    final HSSPrivateKeyParameters myPrivate = (HSSPrivateKeyParameters) PrivateKeyFactory.createKey(pInfo);</span>
<span class="fc" id="L1465">                    final int myDepth = myPrivate.getL();</span>
<span class="fc" id="L1466">                    final LMSPublicKeyParameters myLMSPublicKey = myPrivate.getPublicKey().getLMSPublicKey();</span>
<span class="fc" id="L1467">                    final GordianLMSKeySpec myKeySpec = determineKeyPairSpec(myLMSPublicKey);</span>
<span class="fc" id="L1468">                    return GordianKeyPairSpecBuilder.hss(myKeySpec, myDepth);</span>

                } else {
<span class="nc" id="L1471">                    final LMSPrivateKeyParameters myPrivate = (LMSPrivateKeyParameters) PrivateKeyFactory.createKey(pInfo);</span>
<span class="nc" id="L1472">                    return GordianKeyPairSpecBuilder.lms(GordianLMSKeySpec.determineKeySpec(myPrivate.getSigParameters(), myPrivate.getOtsParameters()));</span>
                }

                /* Handle exceptions */
<span class="nc" id="L1476">            } catch (IOException e) {</span>
<span class="nc" id="L1477">                throw new GordianIOException(ERROR_PARSE, e);</span>
            }
        }

        /**
         * Obtain keySpec from public key.
         * @param pPublic the publicKeyParams
         * @return the LMSKeySpec
         */
        static GordianLMSKeySpec determineKeyPairSpec(final LMSPublicKeyParameters pPublic) {
<span class="fc" id="L1487">            return GordianLMSKeySpec.determineKeySpec(pPublic.getSigParameters(), pPublic.getOtsParameters());</span>
        }
    }

    /**
     * Composite Encoded parser.
     */
    private static class GordianCompositeEncodedParser implements GordianEncodedParser {
        /**
         * The KeyPairFactory.
         */
        private final GordianKeyPairAlgId theIdManager;

        /**
         * Constructor.
         * @param pIdManager the idManager
         */
<span class="fc" id="L1504">        GordianCompositeEncodedParser(final GordianKeyPairAlgId pIdManager) {</span>
<span class="fc" id="L1505">            theIdManager = pIdManager;</span>
<span class="fc" id="L1506">        }</span>

        /**
         * Registrar.
         * @param pIdManager the idManager
         */
        static void register(final GordianKeyPairAlgId pIdManager) {
<span class="fc" id="L1513">            pIdManager.registerParser(MiscObjectIdentifiers.id_alg_composite, new GordianCompositeEncodedParser(pIdManager));</span>
<span class="fc" id="L1514">        }</span>

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final SubjectPublicKeyInfo pInfo) throws GordianException {
            /* Protect against exceptions */
            try {
<span class="fc" id="L1520">                final ASN1Sequence myKeys = ASN1Sequence.getInstance(pInfo.getPublicKeyData().getBytes());</span>
<span class="fc" id="L1521">                final List&lt;GordianKeyPairSpec&gt; mySpecs = new ArrayList&lt;&gt;();</span>

                /* Build the list from the keys sequence */
<span class="fc" id="L1524">                final Enumeration&lt;?&gt; en = myKeys.getObjects();</span>
<span class="fc bfc" id="L1525" title="All 2 branches covered.">                while (en.hasMoreElements()) {</span>
<span class="fc" id="L1526">                    final SubjectPublicKeyInfo myPKInfo = SubjectPublicKeyInfo.getInstance(en.nextElement());</span>
<span class="fc" id="L1527">                    mySpecs.add(theIdManager.determineKeyPairSpec(new X509EncodedKeySpec(myPKInfo.getEncoded())));</span>
<span class="fc" id="L1528">                }</span>
<span class="fc" id="L1529">                return GordianKeyPairSpecBuilder.composite(mySpecs);</span>

                /* Handle exceptions */
<span class="nc" id="L1532">            } catch (IOException e) {</span>
<span class="nc" id="L1533">                throw new GordianIOException(ERROR_PARSE, e);</span>
            }
        }

        @Override
        public GordianKeyPairSpec determineKeyPairSpec(final PrivateKeyInfo pInfo) throws GordianException {
            /* Protect against exceptions */
            try {
<span class="fc" id="L1541">                final ASN1Sequence myKeys = ASN1Sequence.getInstance(pInfo.getPrivateKey().getOctets());</span>
<span class="fc" id="L1542">                final List&lt;GordianKeyPairSpec&gt; mySpecs = new ArrayList&lt;&gt;();</span>

                /* Build the list from the keys sequence */
<span class="fc" id="L1545">                final Enumeration&lt;?&gt; en = myKeys.getObjects();</span>
<span class="fc bfc" id="L1546" title="All 2 branches covered.">                while (en.hasMoreElements()) {</span>
<span class="fc" id="L1547">                    final PrivateKeyInfo myPKInfo = PrivateKeyInfo.getInstance(en.nextElement());</span>
<span class="fc" id="L1548">                    mySpecs.add(theIdManager.determineKeyPairSpec(new PKCS8EncodedKeySpec(myPKInfo.getEncoded())));</span>
<span class="fc" id="L1549">                }</span>
<span class="fc" id="L1550">                return GordianKeyPairSpecBuilder.composite(mySpecs);</span>

                /* Handle exceptions */
<span class="nc" id="L1553">            } catch (IOException e) {</span>
<span class="nc" id="L1554">                throw new GordianIOException(ERROR_PARSE, e);</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
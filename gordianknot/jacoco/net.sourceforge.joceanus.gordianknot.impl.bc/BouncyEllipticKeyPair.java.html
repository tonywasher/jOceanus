<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BouncyEllipticKeyPair.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.bc</a> &gt; <span class="el_source">BouncyEllipticKeyPair.java</span></div><h1>BouncyEllipticKeyPair.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.bc;

import net.sourceforge.joceanus.gordianknot.api.agree.GordianAgreementSpec;
import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.encrypt.GordianEncryptorSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairFactory;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianElliptic;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPair;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairGenerator;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairSpec;
import net.sourceforge.joceanus.gordianknot.api.sign.GordianSignParams;
import net.sourceforge.joceanus.gordianknot.api.sign.GordianSignatureSpec;
import net.sourceforge.joceanus.gordianknot.impl.bc.BouncyDHKeyPair.BouncyDHPrivateKey;
import net.sourceforge.joceanus.gordianknot.impl.bc.BouncyDHKeyPair.BouncyDHPublicKey;
import net.sourceforge.joceanus.gordianknot.impl.bc.BouncyKeyPair.BouncyPrivateKey;
import net.sourceforge.joceanus.gordianknot.impl.bc.BouncyKeyPair.BouncyPublicKey;
import net.sourceforge.joceanus.gordianknot.impl.bc.BouncySignature.BouncyDERCoder;
import net.sourceforge.joceanus.gordianknot.impl.bc.BouncySignature.BouncyDigestSignature;
import net.sourceforge.joceanus.gordianknot.impl.core.agree.GordianAgreementMessageASN1;
import net.sourceforge.joceanus.gordianknot.impl.core.agree.GordianCoreAnonymousAgreement;
import net.sourceforge.joceanus.gordianknot.impl.core.agree.GordianCoreBasicAgreement;
import net.sourceforge.joceanus.gordianknot.impl.core.agree.GordianCoreEphemeralAgreement;
import net.sourceforge.joceanus.gordianknot.impl.core.agree.GordianCoreSignedAgreement;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import net.sourceforge.joceanus.gordianknot.impl.core.encrypt.GordianCoreEncryptor;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianCryptoException;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianIOException;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianLogicException;
import net.sourceforge.joceanus.gordianknot.impl.core.keypair.GordianKeyPairValidity;
import net.sourceforge.joceanus.gordianknot.impl.core.xagree.GordianXCoreAgreementFactory;
import net.sourceforge.joceanus.gordianknot.impl.ext.engines.GordianEllipticEncryptor;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.asn1.x9.ECNamedCurveTable;
import org.bouncycastle.asn1.x9.X9ECParameters;
import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
import org.bouncycastle.crypto.DSA;
import org.bouncycastle.crypto.DerivationFunction;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.SecretWithEncapsulation;
import org.bouncycastle.crypto.agreement.ECDHCBasicAgreement;
import org.bouncycastle.crypto.agreement.ECDHCUnifiedAgreement;
import org.bouncycastle.crypto.agreement.ECMQVBasicAgreement;
import org.bouncycastle.crypto.generators.ECKeyPairGenerator;
import org.bouncycastle.crypto.kems.ECIESKEMExtractor;
import org.bouncycastle.crypto.kems.ECIESKEMGenerator;
import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
import org.bouncycastle.crypto.params.ECDHUPrivateParameters;
import org.bouncycastle.crypto.params.ECDHUPublicParameters;
import org.bouncycastle.crypto.params.ECKeyGenerationParameters;
import org.bouncycastle.crypto.params.ECNamedDomainParameters;
import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
import org.bouncycastle.crypto.params.ECPublicKeyParameters;
import org.bouncycastle.crypto.params.MQVPrivateParameters;
import org.bouncycastle.crypto.params.MQVPublicParameters;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.crypto.util.PrivateKeyFactory;
import org.bouncycastle.crypto.util.PrivateKeyInfoFactory;
import org.bouncycastle.crypto.util.PublicKeyFactory;
import org.bouncycastle.crypto.util.SubjectPublicKeyInfoFactory;
import org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;
import org.bouncycastle.util.BigIntegers;

import javax.security.auth.DestroyFailedException;
import java.io.IOException;
import java.math.BigInteger;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

/**
 * EllipticCurve KeyPair classes.
 */
public final class BouncyEllipticKeyPair {
    /**
     * Private constructor.
     */
    private BouncyEllipticKeyPair() {
    }

    /**
     * Bouncy Elliptic PublicKey.
     */
    public static class BouncyECPublicKey
            extends BouncyPublicKey&lt;ECPublicKeyParameters&gt; {
        /**
         * Constructor.
         * @param pKeySpec the keySpec
         * @param pPublicKey the public key
         */
        BouncyECPublicKey(final GordianKeyPairSpec pKeySpec,
                          final ECPublicKeyParameters pPublicKey) {
<span class="fc" id="L109">            super(pKeySpec, pPublicKey);</span>
<span class="fc" id="L110">        }</span>

        @Override
        protected boolean matchKey(final AsymmetricKeyParameter pThat) {
            /* Access keys */
<span class="fc" id="L115">            final ECPublicKeyParameters myThis = getPublicKey();</span>
<span class="fc" id="L116">            final ECPublicKeyParameters myThat = (ECPublicKeyParameters) pThat;</span>

            /* Compare keys */
<span class="fc" id="L119">            return compareKeys(myThis, myThat);</span>
        }

        /**
         * Is the private key valid for this public key?
         * @param pPrivate the private key
         * @return true/false
         */
        public boolean validPrivate(final BouncyECPrivateKey pPrivate) {
<span class="nc" id="L128">            final ECPrivateKeyParameters myPrivate = pPrivate.getPrivateKey();</span>
<span class="nc" id="L129">            return getPublicKey().getParameters().equals(myPrivate.getParameters());</span>
        }

        /**
         * CompareKeys.
         * @param pFirst the first key
         * @param pSecond the second key
         * @return true/false
         */
        private static boolean compareKeys(final ECPublicKeyParameters pFirst,
                                           final ECPublicKeyParameters pSecond) {
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">            return pFirst.getQ().equals(pSecond.getQ())</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">                    &amp;&amp; pFirst.getParameters().equals(pSecond.getParameters());</span>
        }
    }

    /**
     * Bouncy Elliptic PrivateKey.
     */
    public static class BouncyECPrivateKey
            extends BouncyPrivateKey&lt;ECPrivateKeyParameters&gt; {
        /**
         * Constructor.
         * @param pKeySpec the keySpec
         * @param pPrivateKey the private key
         */
        BouncyECPrivateKey(final GordianKeyPairSpec pKeySpec,
                           final ECPrivateKeyParameters pPrivateKey) {
<span class="fc" id="L157">            super(pKeySpec, pPrivateKey);</span>
<span class="fc" id="L158">        }</span>

        @Override
        protected boolean matchKey(final AsymmetricKeyParameter pThat) {
            /* Access keys */
<span class="fc" id="L163">            final ECPrivateKeyParameters myThis = getPrivateKey();</span>
<span class="fc" id="L164">            final ECPrivateKeyParameters myThat = (ECPrivateKeyParameters) pThat;</span>

            /* Compare keys */
<span class="fc" id="L167">            return compareKeys(myThis, myThat);</span>
        }

        /**
         * CompareKeys.
         * @param pFirst the first key
         * @param pSecond the second key
         * @return true/false
         */
        private static boolean compareKeys(final ECPrivateKeyParameters pFirst,
                                           final ECPrivateKeyParameters pSecond) {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">            return pFirst.getD().equals(pSecond.getD())</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">                    &amp;&amp; pFirst.getParameters().equals(pSecond.getParameters());</span>
        }
    }

    /**
     * BouncyCastle Elliptic KeyPair generator.
     */
    public static class BouncyECKeyPairGenerator
            extends BouncyKeyPairGenerator {
        /**
         * Generator.
         */
        private final ECKeyPairGenerator theGenerator;

        /**
         * Constructor.
         * @param pFactory the Security Factory
         * @param pKeySpec the keySpec
         * @throws GordianException on error
         */
        BouncyECKeyPairGenerator(final GordianBaseFactory pFactory,
                                 final GordianKeyPairSpec pKeySpec) throws GordianException {
            /* Initialise underlying class */
<span class="fc" id="L202">            super(pFactory, pKeySpec);</span>

            /* Create the generator */
<span class="fc" id="L205">            theGenerator = newGenerator();</span>

            /* Lookup the parameters */
<span class="fc" id="L208">            final GordianElliptic myElliptic = pKeySpec.getElliptic();</span>
<span class="fc" id="L209">            final String myCurve = myElliptic.getCurveName();</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">            final X9ECParameters x9 = myElliptic.hasCustomCurve()</span>
<span class="fc" id="L211">                                ? ECUtil.getNamedCurveByName(myCurve)</span>
<span class="pc" id="L212">                                : ECNamedCurveTable.getByName(myCurve);</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            if (x9 == null) {</span>
<span class="nc" id="L214">                throw new GordianLogicException(&quot;Invalid KeySpec - &quot; + pKeySpec);</span>
            }

            /* Initialise the generator */
<span class="fc" id="L218">            final ASN1ObjectIdentifier myOid = ECUtil.getNamedCurveOid(myCurve);</span>
<span class="fc" id="L219">            final ECNamedDomainParameters myDomain = new ECNamedDomainParameters(myOid, x9.getCurve(), x9.getG(), x9.getN(), x9.getH(), x9.getSeed());</span>
<span class="fc" id="L220">            final ECKeyGenerationParameters myParams = new ECKeyGenerationParameters(myDomain, getRandom());</span>
<span class="fc" id="L221">            theGenerator.init(myParams);</span>
<span class="fc" id="L222">        }</span>

        /**
         * Create the generator.
         * @return the generator
         */
        ECKeyPairGenerator newGenerator() {
<span class="fc" id="L229">            return new ECKeyPairGenerator();</span>
        }

        @Override
        public BouncyKeyPair generateKeyPair() {
            /* Generate and return the keyPair */
<span class="fc" id="L235">            final AsymmetricCipherKeyPair myPair = theGenerator.generateKeyPair();</span>
<span class="fc" id="L236">            final BouncyECPublicKey myPublic = new BouncyECPublicKey(getKeySpec(), (ECPublicKeyParameters) myPair.getPublic());</span>
<span class="fc" id="L237">            final BouncyECPrivateKey myPrivate = new BouncyECPrivateKey(getKeySpec(), (ECPrivateKeyParameters) myPair.getPrivate());</span>
<span class="fc" id="L238">            return new BouncyKeyPair(myPublic, myPrivate);</span>
        }

        @Override
        public PKCS8EncodedKeySpec getPKCS8Encoding(final GordianKeyPair pKeyPair) throws GordianException {
            /* Protect against exceptions */
            try {
                /* Check the keyPair type and keySpecs */
<span class="fc" id="L246">                BouncyKeyPair.checkKeyPair(pKeyPair, getKeySpec());</span>

                /* build and return the encoding */
<span class="fc" id="L249">                final BouncyECPrivateKey myPrivateKey = (BouncyECPrivateKey) getPrivateKey(pKeyPair);</span>
<span class="fc" id="L250">                final ECPrivateKeyParameters myParms = myPrivateKey.getPrivateKey();</span>
<span class="fc" id="L251">                final PrivateKeyInfo myInfo = PrivateKeyInfoFactory.createPrivateKeyInfo(myParms);</span>
<span class="fc" id="L252">                return new PKCS8EncodedKeySpec(myInfo.getEncoded());</span>

<span class="nc" id="L254">            } catch (IOException e) {</span>
<span class="nc" id="L255">                throw new GordianCryptoException(ERROR_PARSE, e);</span>
            }
        }

        @Override
        public BouncyKeyPair deriveKeyPair(final X509EncodedKeySpec pPublicKey,
                                           final PKCS8EncodedKeySpec pPrivateKey) throws GordianException {
            /* Protect against exceptions */
            try {
                /* Check the keySpecs */
<span class="fc" id="L265">                checkKeySpec(pPrivateKey);</span>

                /* derive keyPair */
<span class="fc" id="L268">                final BouncyECPublicKey myPublic = derivePublicKey(pPublicKey);</span>
<span class="fc" id="L269">                final PrivateKeyInfo myInfo = PrivateKeyInfo.getInstance(pPrivateKey.getEncoded());</span>
<span class="fc" id="L270">                final ECPrivateKeyParameters myParms = (ECPrivateKeyParameters) PrivateKeyFactory.createKey(myInfo);</span>
<span class="fc" id="L271">                final BouncyECPrivateKey myPrivate = new BouncyECPrivateKey(getKeySpec(), myParms);</span>
<span class="fc" id="L272">                final BouncyKeyPair myPair = new BouncyKeyPair(myPublic, myPrivate);</span>

                /* Check that we have a matching pair */
<span class="fc" id="L275">                GordianKeyPairValidity.checkValidity(getFactory(), myPair);</span>

                /* Return the keyPair */
<span class="fc" id="L278">                return myPair;</span>

<span class="nc" id="L280">            } catch (IOException e) {</span>
<span class="nc" id="L281">                throw new GordianCryptoException(ERROR_PARSE, e);</span>
            }
        }

        @Override
        public X509EncodedKeySpec getX509Encoding(final GordianKeyPair pKeyPair) throws GordianException {
            /* Protect against exceptions */
            try {
                /* Check the keyPair type and keySpecs */
<span class="fc" id="L290">                BouncyKeyPair.checkKeyPair(pKeyPair, getKeySpec());</span>

                /* build and return the encoding */
<span class="fc" id="L293">                final BouncyECPublicKey myPublicKey = (BouncyECPublicKey) getPublicKey(pKeyPair);</span>
<span class="fc" id="L294">                final ECPublicKeyParameters myParms = myPublicKey.getPublicKey();</span>
<span class="fc" id="L295">                final SubjectPublicKeyInfo myInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(myParms);</span>
<span class="fc" id="L296">                return new X509EncodedKeySpec(myInfo.getEncoded());</span>

<span class="nc" id="L298">            } catch (IOException e) {</span>
<span class="nc" id="L299">                throw new GordianCryptoException(ERROR_PARSE, e);</span>
            }
        }

        @Override
        public BouncyKeyPair derivePublicOnlyKeyPair(final X509EncodedKeySpec pEncodedKey) throws GordianException {
<span class="fc" id="L305">            final BouncyECPublicKey myPublic = derivePublicKey(pEncodedKey);</span>
<span class="fc" id="L306">            return new BouncyKeyPair(myPublic);</span>
        }

        /**
         * Derive public key from encoded.
         * @param pEncodedKey the encoded key
         * @return the public key
         * @throws GordianException on error
         */
        private BouncyECPublicKey derivePublicKey(final X509EncodedKeySpec pEncodedKey) throws GordianException {
            /* Protect against exceptions */
            try {
                /* Check the keySpecs */
<span class="fc" id="L319">                checkKeySpec(pEncodedKey);</span>

                /* derive publicKey */
<span class="fc" id="L322">                final SubjectPublicKeyInfo myInfo = SubjectPublicKeyInfo.getInstance(pEncodedKey.getEncoded());</span>
<span class="fc" id="L323">                final ECPublicKeyParameters myParms = (ECPublicKeyParameters) PublicKeyFactory.createKey(myInfo);</span>
<span class="fc" id="L324">                return new BouncyECPublicKey(getKeySpec(), myParms);</span>

<span class="nc" id="L326">            } catch (IOException e) {</span>
<span class="nc" id="L327">                throw new GordianCryptoException(ERROR_PARSE, e);</span>
            }
        }
    }

    /**
     * EC signer.
     */
    public static class BouncyECSignature
            extends BouncyDigestSignature {
        /**
         * The Signer.
         */
        private final DSA theSigner;

        /**
         * The Coder.
         */
        private final BouncyDERCoder theCoder;

        /**
         * Constructor.
         * @param pFactory the factory
         * @param pSpec the signatureSpec.
         * @throws GordianException on error
         */
        BouncyECSignature(final GordianBaseFactory pFactory,
                          final GordianSignatureSpec pSpec) throws GordianException {
            /* Initialise underlying class */
<span class="fc" id="L356">            super(pFactory, pSpec);</span>

            /* Create the signer and Coder */
<span class="fc" id="L359">            theSigner = BouncySignature.getDSASigner(pFactory, pSpec);</span>
<span class="fc" id="L360">            theCoder = new BouncyDERCoder();</span>
<span class="fc" id="L361">        }</span>

        @Override
        public void initForSigning(final GordianSignParams pParams) throws GordianException {
            /* Initialise detail */
<span class="fc" id="L366">            super.initForSigning(pParams);</span>
<span class="fc" id="L367">            final BouncyKeyPair myPair = getKeyPair();</span>
<span class="fc" id="L368">            BouncyKeyPair.checkKeyPair(myPair);</span>

            /* Initialise and set the signer */
<span class="fc" id="L371">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) myPair.getPrivateKey();</span>
<span class="fc" id="L372">            final ParametersWithRandom myParms = new ParametersWithRandom(myPrivate.getPrivateKey(), getRandom());</span>
<span class="fc" id="L373">            theSigner.init(true, myParms);</span>
<span class="fc" id="L374">        }</span>

        @Override
        public void initForVerify(final GordianSignParams pParams) throws GordianException {
            /* Initialise detail */
<span class="fc" id="L379">            super.initForVerify(pParams);</span>
<span class="fc" id="L380">            final BouncyKeyPair myPair = getKeyPair();</span>
<span class="fc" id="L381">            BouncyKeyPair.checkKeyPair(myPair);</span>

            /* Initialise and set the signer */
<span class="fc" id="L384">            final BouncyECPublicKey myPublic = (BouncyECPublicKey) myPair.getPublicKey();</span>
<span class="fc" id="L385">            theSigner.init(false, myPublic.getPublicKey());</span>
<span class="fc" id="L386">        }</span>

        @Override
        public byte[] sign() throws GordianException {
            /* Check that we are in signing mode */
<span class="fc" id="L391">            checkMode(GordianSignatureMode.SIGN);</span>

            /* Sign the message */
<span class="fc" id="L394">            final BigInteger[] myValues = theSigner.generateSignature(getDigest());</span>
<span class="fc" id="L395">            return theCoder.dsaEncode(myValues[0], myValues[1]);</span>
        }

        @Override
        public boolean verify(final byte[] pSignature) throws GordianException {
            /* Check that we are in verify mode */
<span class="fc" id="L401">            checkMode(GordianSignatureMode.VERIFY);</span>

            /* Verify the message */
<span class="fc" id="L404">            final BigInteger[] myValues = theCoder.dsaDecode(pSignature);</span>
<span class="fc" id="L405">            return theSigner.verifySignature(getDigest(), myValues[0], myValues[1]);</span>
        }
    }

    /**
     * ECIES Encapsulation.
     */
    public static class BouncyECIESAgreement
            extends GordianCoreAnonymousAgreement {
        /**
         * Key Length.
         */
        private static final int KEYLEN = 32;

        /**
         * Key Generator.
         */
        private final ECIESKEMGenerator theGenerator;

        /**
         * Derivation function.
         */
        private final DerivationFunction theDerivation;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         */
        BouncyECIESAgreement(final GordianBaseFactory pFactory,
                             final GordianAgreementSpec pSpec) {
            /* Initialise underlying class */
<span class="fc" id="L437">            super(pFactory, pSpec);</span>

            /* Create Key Encapsulation */
<span class="fc" id="L440">            theDerivation = newDerivationFunction();</span>
<span class="fc" id="L441">            theGenerator = new ECIESKEMGenerator(KEYLEN, theDerivation, getRandom());</span>
<span class="fc" id="L442">        }</span>

        @Override
        public GordianAgreementMessageASN1 createClientHelloASN1(final GordianKeyPair pServer) throws GordianException {
            /* Protect against exceptions */
            try {
                /* Check keyPair */
<span class="fc" id="L449">                BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L450">                checkKeyPair(pServer);</span>

                /* Create encapsulation */
<span class="fc" id="L453">                final BouncyECPublicKey myPublic = (BouncyECPublicKey) getPublicKey(pServer);</span>
<span class="fc" id="L454">                final SecretWithEncapsulation myResult = theGenerator.generateEncapsulated(myPublic.getPublicKey());</span>

                /* Build the clientHello Message */
<span class="fc" id="L457">                final GordianAgreementMessageASN1 myClientHello = buildClientHelloASN1(myResult.getEncapsulation());</span>

                /* Store secret and create initVector */
<span class="fc" id="L460">                storeSecret(myResult.getSecret());</span>
<span class="fc" id="L461">                myResult.destroy();</span>

                /* Return the clientHello message  */
<span class="fc" id="L464">                return myClientHello;</span>
<span class="nc" id="L465">            } catch (DestroyFailedException e) {</span>
<span class="nc" id="L466">                throw new GordianIOException(&quot;Failed to destroy secret&quot;, e);</span>
            }
        }

        @Override
        public void acceptClientHelloASN1(final GordianKeyPair pServer,
                                          final GordianAgreementMessageASN1 pClientHello) throws GordianException {
            /* Check keyPair */
<span class="fc" id="L474">            BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L475">            checkKeyPair(pServer);</span>

            /* initialise Key Encapsulation */
<span class="fc" id="L478">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(pServer);</span>
<span class="fc" id="L479">            final ECIESKEMExtractor myExtractor = new ECIESKEMExtractor(myPrivate.getPrivateKey(), KEYLEN, theDerivation);</span>

            /* Parse clientHello message and store secret */
<span class="fc" id="L482">            final byte[] myMessage = pClientHello.getEncapsulated();</span>
<span class="fc" id="L483">            storeSecret(myExtractor.extractSecret(myMessage));</span>
<span class="fc" id="L484">        }</span>
    }

    /**
     * EC Anonymous.
     */
    public static class BouncyECAnonymousAgreement
            extends GordianCoreAnonymousAgreement {
        /**
         * The agreement.
         */
        private final ECDHCBasicAgreement theAgreement;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         */
        BouncyECAnonymousAgreement(final GordianBaseFactory pFactory,
                                   final GordianAgreementSpec pSpec) {
            /* Initialise underlying class */
<span class="fc" id="L505">            super(pFactory, pSpec);</span>

            /* Create the agreement */
<span class="fc" id="L508">            theAgreement = new ECDHCBasicAgreement();</span>

            /* Add in the derivation function */
<span class="fc" id="L511">            enableDerivation();</span>
<span class="fc" id="L512">        }</span>

        @Override
        public GordianAgreementMessageASN1 createClientHelloASN1(final GordianKeyPair pServer) throws GordianException {
            /* Check keyPair */
<span class="fc" id="L517">            BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L518">            checkKeyPair(pServer);</span>

            /* Create an ephemeral keyPair */
<span class="fc" id="L521">            final GordianKeyPairFactory myFactory = getFactory().getAsyncFactory().getKeyPairFactory();</span>
<span class="fc" id="L522">            final GordianKeyPairGenerator myGenerator = myFactory.getKeyPairGenerator(pServer.getKeyPairSpec());</span>
<span class="fc" id="L523">            final GordianKeyPair myPair = myGenerator.generateKeyPair();</span>
<span class="fc" id="L524">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(myPair);</span>

            /* Create the request  */
<span class="fc" id="L527">            final X509EncodedKeySpec myKeySpec = myGenerator.getX509Encoding(myPair);</span>
<span class="fc" id="L528">            final GordianAgreementMessageASN1 myClientHello = buildClientHelloASN1(myKeySpec);</span>

            /* Derive the secret */
<span class="fc" id="L531">            theAgreement.init(myPrivate.getPrivateKey());</span>
<span class="fc" id="L532">            final BouncyECPublicKey myTarget = (BouncyECPublicKey) getPublicKey(pServer);</span>
<span class="fc" id="L533">            final BigInteger mySecret = theAgreement.calculateAgreement(myTarget.getPublicKey());</span>
<span class="fc" id="L534">            storeSecret(BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), mySecret));</span>
<span class="fc" id="L535">            return myClientHello;</span>
        }

        @Override
        public void acceptClientHelloASN1(final GordianKeyPair pSelf,
                                          final GordianAgreementMessageASN1 pClientHello) throws GordianException {
            /* Check keyPair */
<span class="fc" id="L542">            BouncyKeyPair.checkKeyPair(pSelf);</span>
<span class="fc" id="L543">            checkKeyPair(pSelf);</span>

            /* Obtain source keySpec */
<span class="fc" id="L546">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(pSelf);</span>
<span class="fc" id="L547">            final X509EncodedKeySpec myKeySpec = pClientHello.getEphemeral();</span>
<span class="fc" id="L548">            final GordianKeyPairFactory myFactory = getFactory().getAsyncFactory().getKeyPairFactory();</span>
<span class="fc" id="L549">            final GordianKeyPairGenerator myGenerator = myFactory.getKeyPairGenerator(pSelf.getKeyPairSpec());</span>

            /* Derive partner key */
<span class="fc" id="L552">            final GordianKeyPair myPartner = myGenerator.derivePublicOnlyKeyPair(myKeySpec);</span>
<span class="fc" id="L553">            final BouncyECPublicKey myPublicKey = (BouncyECPublicKey) getPublicKey(myPartner);</span>

            /* Derive the secret */
<span class="fc" id="L556">            theAgreement.init(myPrivate.getPrivateKey());</span>
<span class="fc" id="L557">            final BigInteger mySecret = theAgreement.calculateAgreement(myPublicKey.getPublicKey());</span>

            /* Store secret */
<span class="fc" id="L560">            storeSecret(BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), mySecret));</span>
<span class="fc" id="L561">        }</span>
    }

    /**
     * EC Basic Agreement.
     */
    public static class BouncyECBasicAgreement
            extends GordianCoreBasicAgreement {
        /**
         * Key Agreement.
         */
        private final ECDHCBasicAgreement theAgreement;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         */
        BouncyECBasicAgreement(final GordianBaseFactory pFactory,
                               final GordianAgreementSpec pSpec) {
            /* Initialise underlying class */
<span class="fc" id="L582">            super(pFactory, pSpec);</span>

            /* Derive the secret */
<span class="fc" id="L585">            theAgreement = new ECDHCBasicAgreement();</span>

            /* Add in the derivation function */
<span class="fc" id="L588">            enableDerivation();</span>
<span class="fc" id="L589">        }</span>

        @Override
        public GordianAgreementMessageASN1 acceptClientHelloASN1(final GordianKeyPair pClient,
                                                                 final GordianKeyPair pServer,
                                                                 final GordianAgreementMessageASN1 pClientHello) throws GordianException {
            /* Check keyPair */
<span class="fc" id="L596">            BouncyKeyPair.checkKeyPair(pClient);</span>
<span class="fc" id="L597">            checkKeyPair(pClient);</span>
<span class="fc" id="L598">            BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L599">            checkKeyPair(pServer);</span>

            /* Process the clientHello */
<span class="fc" id="L602">            processClientHelloASN1(pServer, pClientHello);</span>
<span class="fc" id="L603">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(pServer);</span>
<span class="fc" id="L604">            final BouncyECPublicKey myPublic = (BouncyECPublicKey) getPublicKey(pClient);</span>

            /* Derive the secret */
<span class="fc" id="L607">            theAgreement.init(myPrivate.getPrivateKey());</span>
<span class="fc" id="L608">            final BigInteger mySecret = theAgreement.calculateAgreement(myPublic.getPublicKey());</span>

            /* Store secret */
<span class="fc" id="L611">            storeSecret(BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), mySecret));</span>

            /* Return the serverHello */
<span class="fc" id="L614">            return buildServerHello();</span>
        }

        @Override
        public void acceptServerHelloASN1(final GordianKeyPair pServer,
                                          final GordianAgreementMessageASN1 pServerHello) throws GordianException {
            /* Check keyPair */
<span class="fc" id="L621">            BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L622">            checkKeyPair(pServer);</span>

            /* process the serverHello */
<span class="fc" id="L625">            processServerHelloASN1(pServerHello);</span>
<span class="fc" id="L626">            final BouncyPrivateKey&lt;?&gt; myPrivate = (BouncyPrivateKey&lt;?&gt;) getPrivateKey(getClientKeyPair());</span>

            /* Calculate agreement */
<span class="fc" id="L629">            theAgreement.init(myPrivate.getPrivateKey());</span>
<span class="fc" id="L630">            final BouncyPublicKey&lt;?&gt; mySrcPublic = (BouncyPublicKey&lt;?&gt;) getPublicKey(pServer);</span>
<span class="fc" id="L631">            final BigInteger mySecret = theAgreement.calculateAgreement(mySrcPublic.getPublicKey());</span>
<span class="fc" id="L632">            storeSecret(BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), mySecret));</span>
<span class="fc" id="L633">        }</span>
    }

    /**
     * EC Signed Agreement.
     */
    public static class BouncyECSignedAgreement
            extends GordianCoreSignedAgreement {
        /**
         * Agreement.
         */
        private final ECDHCBasicAgreement theAgreement;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         */
        BouncyECSignedAgreement(final GordianBaseFactory pFactory,
                                final GordianAgreementSpec pSpec) {
            /* Initialise underlying class */
<span class="fc" id="L654">            super(pFactory, pSpec);</span>

            /* Create the agreement */
<span class="fc" id="L657">            theAgreement = new ECDHCBasicAgreement();</span>
<span class="fc" id="L658">            enableDerivation();</span>
<span class="fc" id="L659">        }</span>

        @Override
        public GordianAgreementMessageASN1 acceptClientHelloASN1(final GordianKeyPair pServer,
                                                                 final GordianAgreementMessageASN1 pClientHello) throws GordianException {
            /* Process clientHello */
<span class="fc" id="L665">            BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L666">            processClientHelloASN1(pClientHello);</span>
<span class="fc" id="L667">            final BouncyPrivateKey&lt;?&gt; myPrivate = (BouncyPrivateKey&lt;?&gt;) getPrivateKey(getServerEphemeralKeyPair());</span>
<span class="fc" id="L668">            final BouncyPublicKey&lt;?&gt; myPublic = (BouncyPublicKey&lt;?&gt;) getPublicKey(getClientEphemeralKeyPair());</span>

            /* Derive the secret */
<span class="fc" id="L671">            theAgreement.init(myPrivate.getPrivateKey());</span>
<span class="fc" id="L672">            final BigInteger mySecretInt = theAgreement.calculateAgreement(myPublic.getPublicKey());</span>
<span class="fc" id="L673">            final byte[] mySecret = BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), mySecretInt);</span>

            /* Store secret */
<span class="fc" id="L676">            storeSecret(mySecret);</span>

            /* Return the serverHello */
<span class="fc" id="L679">            return buildServerHelloASN1(pServer);</span>
        }

        @Override
        public void acceptServerHelloASN1(final GordianKeyPair pServer,
                                          final GordianAgreementMessageASN1 pServerHello) throws GordianException {
            /* process the serverHello */
<span class="fc" id="L686">            BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L687">            processServerHelloASN1(pServer, pServerHello);</span>
<span class="fc" id="L688">            final BouncyPrivateKey&lt;?&gt; myPrivate = (BouncyPrivateKey&lt;?&gt;) getPrivateKey(getClientEphemeralKeyPair());</span>

            /* Calculate agreement */
<span class="fc" id="L691">            theAgreement.init(myPrivate.getPrivateKey());</span>
<span class="fc" id="L692">            final BouncyPublicKey&lt;?&gt; myPublic = (BouncyPublicKey&lt;?&gt;) getPublicKey(getServerEphemeralKeyPair());</span>
<span class="fc" id="L693">            final BigInteger mySecretInt = theAgreement.calculateAgreement(myPublic.getPublicKey());</span>
<span class="fc" id="L694">            final byte[] mySecret = BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), mySecretInt);</span>

            /* Store secret */
<span class="fc" id="L697">            storeSecret(mySecret);</span>
<span class="fc" id="L698">        }</span>
    }

    /**
     * EC Unified Agreement.
     */
    public static class BouncyECUnifiedAgreement
            extends GordianCoreEphemeralAgreement {
        /**
         * Key Agreement.
         */
        private final ECDHCUnifiedAgreement theAgreement;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         */
        BouncyECUnifiedAgreement(final GordianBaseFactory pFactory,
                                 final GordianAgreementSpec pSpec) {
            /* Initialise underlying class */
<span class="fc" id="L719">            super(pFactory, pSpec);</span>

            /* Create Key Agreement */
<span class="fc" id="L722">            theAgreement = new ECDHCUnifiedAgreement();</span>

            /* Add in the derivation function */
<span class="fc" id="L725">            enableDerivation();</span>
<span class="fc" id="L726">        }</span>

        @Override
        public GordianAgreementMessageASN1 acceptClientHelloASN1(final GordianKeyPair pClient,
                                                                 final GordianKeyPair pServer,
                                                                 final GordianAgreementMessageASN1 pClientHello) throws GordianException {
            /* process clientHello */
<span class="fc" id="L733">            BouncyKeyPair.checkKeyPair(pClient);</span>
<span class="fc" id="L734">            BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L735">            processClientHelloASN1(pClient, pServer, pClientHello);</span>

            /* Initialise agreement */
<span class="fc" id="L738">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(pServer);</span>
<span class="fc" id="L739">            final BouncyECPrivateKey myEphPrivate = (BouncyECPrivateKey) getPrivateKey(getServerEphemeralKeyPair());</span>
<span class="fc" id="L740">            final BouncyECPublicKey myEphPublic = (BouncyECPublicKey) getPublicKey(getServerEphemeralKeyPair());</span>
<span class="fc" id="L741">            final ECDHUPrivateParameters myPrivParams = new ECDHUPrivateParameters(myPrivate.getPrivateKey(),</span>
<span class="fc" id="L742">                    myEphPrivate.getPrivateKey(), myEphPublic.getPublicKey());</span>
<span class="fc" id="L743">            theAgreement.init(myPrivParams);</span>

            /* Calculate agreement */
<span class="fc" id="L746">            final BouncyECPublicKey mySrcPublic = (BouncyECPublicKey) getPublicKey(pClient);</span>
<span class="fc" id="L747">            final BouncyECPublicKey mySrcEphPublic = (BouncyECPublicKey) getPublicKey(getClientEphemeralKeyPair());</span>
<span class="fc" id="L748">            final ECDHUPublicParameters myPubParams = new ECDHUPublicParameters(mySrcPublic.getPublicKey(),</span>
<span class="fc" id="L749">                    mySrcEphPublic.getPublicKey());</span>
<span class="fc" id="L750">            storeSecret(theAgreement.calculateAgreement(myPubParams));</span>

            /* Return the serverHello */
<span class="fc" id="L753">            return buildServerHello();</span>
        }

        @Override
        public GordianAgreementMessageASN1 acceptServerHelloASN1(final GordianKeyPair pServer,
                                                                 final GordianAgreementMessageASN1 pServerHello) throws GordianException {
            /* Check keyPair */
<span class="fc" id="L760">            BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L761">            checkKeyPair(pServer);</span>

            /* process the serverHello */
<span class="fc" id="L764">            processServerHelloASN1(pServer, pServerHello);</span>

            /* Initialise agreement */
<span class="fc" id="L767">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(getClientKeyPair());</span>
<span class="fc" id="L768">            final BouncyECPrivateKey myEphPrivate = (BouncyECPrivateKey) getPrivateKey(getClientEphemeralKeyPair());</span>
<span class="fc" id="L769">            final BouncyECPublicKey myEphPublic = (BouncyECPublicKey) getPublicKey(getClientEphemeralKeyPair());</span>
<span class="fc" id="L770">            final ECDHUPrivateParameters myPrivParams = new ECDHUPrivateParameters(myPrivate.getPrivateKey(),</span>
<span class="fc" id="L771">                    myEphPrivate.getPrivateKey(), myEphPublic.getPublicKey());</span>
<span class="fc" id="L772">            theAgreement.init(myPrivParams);</span>

            /* Calculate agreement */
<span class="fc" id="L775">            final BouncyECPublicKey mySrcPublic = (BouncyECPublicKey) getPublicKey(pServer);</span>
<span class="fc" id="L776">            final BouncyECPublicKey mySrcEphPublic = (BouncyECPublicKey) getPublicKey(getServerEphemeralKeyPair());</span>
<span class="fc" id="L777">            final ECDHUPublicParameters myPubParams = new ECDHUPublicParameters(mySrcPublic.getPublicKey(),</span>
<span class="fc" id="L778">                    mySrcEphPublic.getPublicKey());</span>
<span class="fc" id="L779">            storeSecret(theAgreement.calculateAgreement(myPubParams));</span>

            /* Return confirmation if needed */
<span class="fc" id="L782">            return buildClientConfirmASN1();</span>
         }
    }

    /**
     * EC MQV Agreement.
     */
    public static class BouncyECMQVAgreement
            extends GordianCoreEphemeralAgreement {
        /**
         * Key Agreement.
         */
        private final ECMQVBasicAgreement theAgreement;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         */
        BouncyECMQVAgreement(final GordianBaseFactory pFactory,
                             final GordianAgreementSpec pSpec) {
            /* Initialise underlying class */
<span class="fc" id="L804">            super(pFactory, pSpec);</span>

            /* Create Key Agreement */
<span class="fc" id="L807">            theAgreement = new ECMQVBasicAgreement();</span>

            /* Add in the derivation function */
<span class="fc" id="L810">            enableDerivation();</span>
<span class="fc" id="L811">        }</span>

        @Override
        public GordianAgreementMessageASN1 acceptClientHelloASN1(final GordianKeyPair pClient,
                                                                 final GordianKeyPair pServer,
                                                                 final GordianAgreementMessageASN1 pClientHello) throws GordianException {
            /* process clientHello */
<span class="fc" id="L818">            BouncyKeyPair.checkKeyPair(pClient);</span>
<span class="fc" id="L819">            BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L820">            processClientHelloASN1(pClient, pServer, pClientHello);</span>

            /* Initialise agreement */
<span class="fc" id="L823">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(pServer);</span>
<span class="fc" id="L824">            final BouncyECPrivateKey myEphPrivate = (BouncyECPrivateKey) getPrivateKey(getServerEphemeralKeyPair());</span>
<span class="fc" id="L825">            final BouncyECPublicKey myEphPublic = (BouncyECPublicKey) getPublicKey(getServerEphemeralKeyPair());</span>
<span class="fc" id="L826">            final MQVPrivateParameters myPrivParams = new MQVPrivateParameters(myPrivate.getPrivateKey(),</span>
<span class="fc" id="L827">                    myEphPrivate.getPrivateKey(), myEphPublic.getPublicKey());</span>
<span class="fc" id="L828">            theAgreement.init(myPrivParams);</span>

            /* Calculate agreement */
<span class="fc" id="L831">            final BouncyECPublicKey mySrcPublic = (BouncyECPublicKey) getPublicKey(pClient);</span>
<span class="fc" id="L832">            final BouncyECPublicKey mySrcEphPublic = (BouncyECPublicKey) getPublicKey(getClientEphemeralKeyPair());</span>
<span class="fc" id="L833">            final MQVPublicParameters myPubParams = new MQVPublicParameters(mySrcPublic.getPublicKey(),</span>
<span class="fc" id="L834">                    mySrcEphPublic.getPublicKey());</span>
<span class="fc" id="L835">            storeSecret(BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), theAgreement.calculateAgreement(myPubParams)));</span>

            /* Return the serverHello */
<span class="fc" id="L838">            return buildServerHello();</span>
        }

        @Override
        public GordianAgreementMessageASN1 acceptServerHelloASN1(final GordianKeyPair pServer,
                                                                 final GordianAgreementMessageASN1 pServerHello) throws GordianException {
            /* Check keyPair */
<span class="fc" id="L845">            BouncyKeyPair.checkKeyPair(pServer);</span>
<span class="fc" id="L846">            checkKeyPair(pServer);</span>

            /* process the serverHello */
<span class="fc" id="L849">            processServerHelloASN1(pServer, pServerHello);</span>

            /* Initialise agreement */
<span class="fc" id="L852">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(getClientKeyPair());</span>
<span class="fc" id="L853">            final BouncyECPrivateKey myEphPrivate = (BouncyECPrivateKey) getPrivateKey(getClientEphemeralKeyPair());</span>
<span class="fc" id="L854">            final BouncyECPublicKey myEphPublic = (BouncyECPublicKey) getPublicKey(getClientEphemeralKeyPair());</span>
<span class="fc" id="L855">            final MQVPrivateParameters myPrivParams = new MQVPrivateParameters(myPrivate.getPrivateKey(),</span>
<span class="fc" id="L856">                    myEphPrivate.getPrivateKey(), myEphPublic.getPublicKey());</span>
<span class="fc" id="L857">            theAgreement.init(myPrivParams);</span>

            /* Calculate agreement */
<span class="fc" id="L860">            final BouncyECPublicKey mySrcPublic = (BouncyECPublicKey) getPublicKey(pServer);</span>
<span class="fc" id="L861">            final BouncyECPublicKey mySrcEphPublic = (BouncyECPublicKey) getPublicKey(getServerEphemeralKeyPair());</span>
<span class="fc" id="L862">            final MQVPublicParameters myPubParams = new MQVPublicParameters(mySrcPublic.getPublicKey(),</span>
<span class="fc" id="L863">                    mySrcEphPublic.getPublicKey());</span>
<span class="fc" id="L864">            storeSecret(BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), theAgreement.calculateAgreement(myPubParams)));</span>

            /* Return confirmation if needed */
<span class="fc" id="L867">            return buildClientConfirmASN1();</span>
        }
    }

    /**
     * EC XAgreement Engine.
     */
    public static class BouncyECIESXAgreementEngine
            extends BouncyXAgreementBase {
        /**
         * Key Length.
         */
        private static final int KEYLEN = 32;

        /**
         * Derivation function.
         */
        private final DerivationFunction theDerivation;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         * @throws GordianException on error
         */
        BouncyECIESXAgreementEngine(final GordianXCoreAgreementFactory pFactory,
                                    final GordianAgreementSpec pSpec) throws GordianException {
            /* Initialize underlying class */
<span class="nc" id="L895">            super(pFactory, pSpec);</span>

            /* Initialise the derivation function */
<span class="nc" id="L898">            theDerivation = newDerivationFunction();</span>
<span class="nc" id="L899">        }</span>

        @Override
        public void buildClientHello() throws GordianException {
            /* Protect against exceptions */
            try {
                /* Create encapsulation */
<span class="nc" id="L906">                final BouncyECPublicKey myPublic = (BouncyECPublicKey) getPublicKey(getServerKeyPair());</span>
<span class="nc" id="L907">                final ECIESKEMGenerator myGenerator = new ECIESKEMGenerator(KEYLEN, theDerivation, getRandom());</span>
<span class="nc" id="L908">                final SecretWithEncapsulation myResult = myGenerator.generateEncapsulated(myPublic.getPublicKey());</span>

                /* Store the encapsulation */
<span class="nc" id="L911">                setEncapsulated(myResult.getEncapsulation());</span>

                /* Store secret and create initVector */
<span class="nc" id="L914">                storeSecret(myResult.getSecret());</span>
<span class="nc" id="L915">                myResult.destroy();</span>

<span class="nc" id="L917">            } catch (DestroyFailedException e) {</span>
<span class="nc" id="L918">                throw new GordianIOException(&quot;Failed to destroy secret&quot;, e);</span>
<span class="nc" id="L919">            }</span>
<span class="nc" id="L920">        }</span>

        @Override
        public void processClientHello() throws GordianException {
            /* Create encapsulation */
<span class="nc" id="L925">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(getServerKeyPair());</span>
<span class="nc" id="L926">            final ECIESKEMExtractor myExtractor = new ECIESKEMExtractor(myPrivate.getPrivateKey(), KEYLEN, theDerivation);</span>

            /* Parse encapsulated message and store secret */
<span class="nc" id="L929">            final byte[] myMessage = getEncapsulated();</span>
<span class="nc" id="L930">            storeSecret(myExtractor.extractSecret(myMessage));</span>
<span class="nc" id="L931">        }</span>
    }

    /**
     * EC Anonymous XAgreement Engine.
     */
    public static class BouncyECAnonXAgreementEngine
            extends BouncyXAgreementBase {
        /**
         * The agreement.
         */
        private final ECDHCBasicAgreement theAgreement;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         * @throws GordianException on error
         */
        BouncyECAnonXAgreementEngine(final GordianXCoreAgreementFactory pFactory,
                                     final GordianAgreementSpec pSpec) throws GordianException {
            /* Initialize underlying class */
<span class="nc" id="L953">            super(pFactory, pSpec);</span>

            /* Create the agreement */
<span class="nc" id="L956">            theAgreement = new ECDHCBasicAgreement();</span>
<span class="nc" id="L957">        }</span>

        @Override
        public void buildClientHello() throws GordianException {
            /* Access keys */
<span class="nc" id="L962">            final BouncyECPublicKey myPublic = (BouncyECPublicKey) getPublicKey(getServerKeyPair());</span>
<span class="nc" id="L963">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(getClientEphemeral());</span>

            /* Derive the secret */
<span class="nc" id="L966">            theAgreement.init(myPrivate.getPrivateKey());</span>
<span class="nc" id="L967">            final BigInteger mySecretInt = theAgreement.calculateAgreement(myPublic.getPublicKey());</span>
<span class="nc" id="L968">            final byte[] mySecret = BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), mySecretInt);</span>

            /* Store secret */
<span class="nc" id="L971">            storeSecret(mySecret);</span>
<span class="nc" id="L972">        }</span>

        @Override
        public void processClientHello() throws GordianException {
            /* Access keys */
<span class="nc" id="L977">            final BouncyECPublicKey myPublic = (BouncyECPublicKey) getPublicKey(getClientEphemeral());</span>
<span class="nc" id="L978">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(getServerKeyPair());</span>

            /* Derive the secret */
<span class="nc" id="L981">            theAgreement.init(myPrivate.getPrivateKey());</span>
<span class="nc" id="L982">            final BigInteger mySecretInt = theAgreement.calculateAgreement(myPublic.getPublicKey());</span>
<span class="nc" id="L983">            final byte[] mySecret = BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), mySecretInt);</span>

            /* Store secret */
<span class="nc" id="L986">            storeSecret(mySecret);</span>
<span class="nc" id="L987">        }</span>
    }

    /**
     * EC Basic XAgreement Engine.
     */
    public static class BouncyECBasicXAgreementEngine
            extends BouncyXAgreementBase {
        /**
         * The agreement.
         */
        private final ECDHCBasicAgreement theAgreement;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         * @throws GordianException on error
         */
        BouncyECBasicXAgreementEngine(final GordianXCoreAgreementFactory pFactory,
                                      final GordianAgreementSpec pSpec) throws GordianException {
            /* Initialize underlying class */
<span class="nc" id="L1009">            super(pFactory, pSpec);</span>

            /* Create the agreement */
<span class="nc" id="L1012">            theAgreement = new ECDHCBasicAgreement();</span>
<span class="nc" id="L1013">        }</span>

        @Override
        public void processClientHello() throws GordianException {
            /* Access keys */
<span class="nc" id="L1018">            final BouncyDHPublicKey myPublic = (BouncyDHPublicKey) getPublicKey(getClientKeyPair());</span>
<span class="nc" id="L1019">            final BouncyDHPrivateKey myPrivate = (BouncyDHPrivateKey) getPrivateKey(getServerKeyPair());</span>

            /* Derive the secret */
<span class="nc" id="L1022">            theAgreement.init(myPrivate.getPrivateKey());</span>
<span class="nc" id="L1023">            final BigInteger mySecretInt = theAgreement.calculateAgreement(myPublic.getPublicKey());</span>
<span class="nc" id="L1024">            final byte[] mySecret = BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), mySecretInt);</span>

            /* Store secret */
<span class="nc" id="L1027">            storeSecret(mySecret);</span>
<span class="nc" id="L1028">        }</span>

        @Override
        public void processServerHello() throws GordianException {
            /* Access keys */
<span class="nc" id="L1033">            final BouncyDHPublicKey myPublic = (BouncyDHPublicKey) getPublicKey(getServerKeyPair());</span>
<span class="nc" id="L1034">            final BouncyDHPrivateKey myPrivate = (BouncyDHPrivateKey) getPrivateKey(getClientKeyPair());</span>

            /* Derive the secret */
<span class="nc" id="L1037">            theAgreement.init(myPrivate.getPrivateKey());</span>
<span class="nc" id="L1038">            final BigInteger mySecretInt = theAgreement.calculateAgreement(myPublic.getPublicKey());</span>
<span class="nc" id="L1039">            final byte[] mySecret = BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), mySecretInt);</span>

            /* Store secret */
<span class="nc" id="L1042">            storeSecret(mySecret);</span>
<span class="nc" id="L1043">        }</span>
    }

    /**
     * EC Unified XAgreement Engine.
     */
    public static class BouncyECUnifiedXAgreementEngine
            extends BouncyXAgreementBase {
        /**
         * The agreement.
         */
        private final ECDHCUnifiedAgreement theAgreement;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         * @throws GordianException on error
         */
        BouncyECUnifiedXAgreementEngine(final GordianXCoreAgreementFactory pFactory,
                                        final GordianAgreementSpec pSpec) throws GordianException {
            /* Initialize underlying class */
<span class="nc" id="L1065">            super(pFactory, pSpec);</span>

            /* Create the agreement */
<span class="nc" id="L1068">            theAgreement = new ECDHCUnifiedAgreement();</span>
<span class="nc" id="L1069">        }</span>

        @Override
        public void processClientHello() throws GordianException {
            /* Access keys */
<span class="nc" id="L1074">            final BouncyECPublicKey myClientPublic = (BouncyECPublicKey) getPublicKey(getClientKeyPair());</span>
<span class="nc" id="L1075">            final BouncyECPublicKey myClientEphPublic = (BouncyECPublicKey) getPublicKey(getClientEphemeral());</span>
<span class="nc" id="L1076">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(getServerKeyPair());</span>
<span class="nc" id="L1077">            final BouncyECPublicKey myEphPublic = (BouncyECPublicKey) getPublicKey(getServerEphemeral());</span>
<span class="nc" id="L1078">            final BouncyECPrivateKey myEphPrivate = (BouncyECPrivateKey) getPrivateKey(getServerEphemeral());</span>

            /* Derive the secret */
<span class="nc" id="L1081">            final ECDHUPrivateParameters myPrivParams</span>
<span class="nc" id="L1082">                    = new ECDHUPrivateParameters(myPrivate.getPrivateKey(), myEphPrivate.getPrivateKey(), myEphPublic.getPublicKey());</span>
<span class="nc" id="L1083">            theAgreement.init(myPrivParams);</span>
<span class="nc" id="L1084">            final ECDHUPublicParameters myPubParams</span>
<span class="nc" id="L1085">                    = new ECDHUPublicParameters(myClientPublic.getPublicKey(), myClientEphPublic.getPublicKey());</span>
<span class="nc" id="L1086">            storeSecret(theAgreement.calculateAgreement(myPubParams));</span>
<span class="nc" id="L1087">        }</span>

        @Override
        public void processServerHello() throws GordianException {
            /* Access keys */
<span class="nc" id="L1092">            final BouncyECPublicKey myServerPublic = (BouncyECPublicKey) getPublicKey(getServerKeyPair());</span>
<span class="nc" id="L1093">            final BouncyECPublicKey myServerEphPublic = (BouncyECPublicKey) getPublicKey(getServerEphemeral());</span>
<span class="nc" id="L1094">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(getClientKeyPair());</span>
<span class="nc" id="L1095">            final BouncyECPublicKey myEphPublic = (BouncyECPublicKey) getPublicKey(getClientEphemeral());</span>
<span class="nc" id="L1096">            final BouncyECPrivateKey myEphPrivate = (BouncyECPrivateKey) getPrivateKey(getClientEphemeral());</span>

            /* Derive the secret */
<span class="nc" id="L1099">            final ECDHUPrivateParameters myPrivParams</span>
<span class="nc" id="L1100">                    = new ECDHUPrivateParameters(myPrivate.getPrivateKey(), myEphPrivate.getPrivateKey(), myEphPublic.getPublicKey());</span>
<span class="nc" id="L1101">            theAgreement.init(myPrivParams);</span>
<span class="nc" id="L1102">            final ECDHUPublicParameters myPubParams</span>
<span class="nc" id="L1103">                    = new ECDHUPublicParameters(myServerPublic.getPublicKey(), myServerEphPublic.getPublicKey());</span>
<span class="nc" id="L1104">            storeSecret(theAgreement.calculateAgreement(myPubParams));</span>
<span class="nc" id="L1105">        }</span>
    }

    /**
     * EC MQV XAgreement Engine.
     */
    public static class BouncyECMQVXAgreementEngine
            extends BouncyXAgreementBase {
        /**
         * The agreement.
         */
        private final ECMQVBasicAgreement theAgreement;

        /**
         * Constructor.
         * @param pFactory the security factory
         * @param pSpec the agreementSpec
         * @throws GordianException on error
         */
        BouncyECMQVXAgreementEngine(final GordianXCoreAgreementFactory pFactory,
                                    final GordianAgreementSpec pSpec) throws GordianException {
            /* Initialize underlying class */
<span class="nc" id="L1127">            super(pFactory, pSpec);</span>

            /* Create the agreement */
<span class="nc" id="L1130">            theAgreement = new ECMQVBasicAgreement();</span>
<span class="nc" id="L1131">        }</span>

        @Override
        public void processClientHello() throws GordianException {
            /* Access keys */
<span class="nc" id="L1136">            final BouncyECPublicKey myClientPublic = (BouncyECPublicKey) getPublicKey(getClientKeyPair());</span>
<span class="nc" id="L1137">            final BouncyECPublicKey myClientEphPublic = (BouncyECPublicKey) getPublicKey(getClientEphemeral());</span>
<span class="nc" id="L1138">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(getServerKeyPair());</span>
<span class="nc" id="L1139">            final BouncyECPublicKey myEphPublic = (BouncyECPublicKey) getPublicKey(getServerEphemeral());</span>
<span class="nc" id="L1140">            final BouncyECPrivateKey myEphPrivate = (BouncyECPrivateKey) getPrivateKey(getServerEphemeral());</span>

            /* Derive the secret */
<span class="nc" id="L1143">            final MQVPrivateParameters myPrivParams</span>
<span class="nc" id="L1144">                    = new MQVPrivateParameters(myPrivate.getPrivateKey(), myEphPrivate.getPrivateKey(), myEphPublic.getPublicKey());</span>
<span class="nc" id="L1145">            theAgreement.init(myPrivParams);</span>
<span class="nc" id="L1146">            final MQVPublicParameters myPubParams</span>
<span class="nc" id="L1147">                    = new MQVPublicParameters(myClientPublic.getPublicKey(), myClientEphPublic.getPublicKey());</span>
<span class="nc" id="L1148">            storeSecret(BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), theAgreement.calculateAgreement(myPubParams)));</span>
<span class="nc" id="L1149">        }</span>

        @Override
        public void processServerHello() throws GordianException {
            /* Access keys */
<span class="nc" id="L1154">            final BouncyECPublicKey myServerPublic = (BouncyECPublicKey) getPublicKey(getServerKeyPair());</span>
<span class="nc" id="L1155">            final BouncyECPublicKey myServerEphPublic = (BouncyECPublicKey) getPublicKey(getServerEphemeral());</span>
<span class="nc" id="L1156">            final BouncyECPrivateKey myPrivate = (BouncyECPrivateKey) getPrivateKey(getClientKeyPair());</span>
<span class="nc" id="L1157">            final BouncyECPublicKey myEphPublic = (BouncyECPublicKey) getPublicKey(getClientEphemeral());</span>
<span class="nc" id="L1158">            final BouncyECPrivateKey myEphPrivate = (BouncyECPrivateKey) getPrivateKey(getClientEphemeral());</span>

            /* Derive the secret */
<span class="nc" id="L1161">            final MQVPrivateParameters myPrivParams</span>
<span class="nc" id="L1162">                    = new MQVPrivateParameters(myPrivate.getPrivateKey(), myEphPrivate.getPrivateKey(), myEphPublic.getPublicKey());</span>
<span class="nc" id="L1163">            theAgreement.init(myPrivParams);</span>
<span class="nc" id="L1164">            final MQVPublicParameters myPubParams</span>
<span class="nc" id="L1165">                    = new MQVPublicParameters(myServerPublic.getPublicKey(), myServerEphPublic.getPublicKey());</span>
<span class="nc" id="L1166">            storeSecret(BigIntegers.asUnsignedByteArray(theAgreement.getFieldSize(), theAgreement.calculateAgreement(myPubParams)));</span>
<span class="nc" id="L1167">        }</span>
    }

    /**
     * EC Encryptor.
     */
    public static class BouncyECEncryptor
            extends GordianCoreEncryptor {
        /**
         * The underlying encryptor.
         */
        private final GordianEllipticEncryptor theEncryptor;

        /**
         * Constructor.
         * @param pFactory the factory
         * @param pSpec the encryptorSpec
         */
        BouncyECEncryptor(final GordianBaseFactory pFactory,
                          final GordianEncryptorSpec pSpec) {
            /* Initialise underlying cipher */
<span class="fc" id="L1188">            super(pFactory, pSpec);</span>
<span class="fc" id="L1189">            theEncryptor = new GordianEllipticEncryptor();</span>
<span class="fc" id="L1190">        }</span>

        @Override
        protected BouncyPublicKey&lt;?&gt; getPublicKey() {
<span class="fc" id="L1194">            return (BouncyPublicKey&lt;?&gt;) super.getPublicKey();</span>
        }

        @Override
        protected BouncyPrivateKey&lt;?&gt; getPrivateKey() {
<span class="fc" id="L1199">            return (BouncyPrivateKey&lt;?&gt;) super.getPrivateKey();</span>
        }

        @Override
        public void initForEncrypt(final GordianKeyPair pKeyPair) throws GordianException {
            /* Initialize underlying cipher */
<span class="fc" id="L1205">            BouncyKeyPair.checkKeyPair(pKeyPair);</span>
<span class="fc" id="L1206">            super.initForEncrypt(pKeyPair);</span>

            /* Initialize for encryption */
<span class="fc" id="L1209">            final ECPublicKeyParameters myParms = (ECPublicKeyParameters) getPublicKey().getPublicKey();</span>
<span class="fc" id="L1210">            theEncryptor.initForEncrypt(myParms, getRandom());</span>
<span class="fc" id="L1211">        }</span>

        @Override
        public void initForDecrypt(final GordianKeyPair pKeyPair) throws GordianException {
            /* Initialize underlying cipher */
<span class="fc" id="L1216">            BouncyKeyPair.checkKeyPair(pKeyPair);</span>
<span class="fc" id="L1217">            super.initForDecrypt(pKeyPair);</span>

            /* Initialize for decryption */
<span class="fc" id="L1220">            final ECPrivateKeyParameters myParms = (ECPrivateKeyParameters) getPrivateKey().getPrivateKey();</span>
<span class="fc" id="L1221">            theEncryptor.initForDecrypt(myParms);</span>
<span class="fc" id="L1222">        }</span>

        @Override
        public byte[] encrypt(final byte[] pBytes) throws GordianException {
            try {
                /* Check that we are in encryption mode */
<span class="fc" id="L1228">                checkMode(GordianEncryptMode.ENCRYPT);</span>

                /* Encrypt the message */
<span class="fc" id="L1231">                return theEncryptor.encrypt(pBytes);</span>
<span class="nc" id="L1232">            } catch (InvalidCipherTextException e) {</span>
<span class="nc" id="L1233">                throw new GordianCryptoException(&quot;Failed to process data&quot;, e);</span>
            }
        }

        @Override
        public byte[] decrypt(final byte[] pBytes) throws GordianException {
            try {
                /* Check that we are in decryption mode */
<span class="fc" id="L1241">                checkMode(GordianEncryptMode.DECRYPT);</span>

                /* Decrypt the message */
<span class="fc" id="L1244">                return theEncryptor.decrypt(pBytes);</span>
<span class="nc" id="L1245">            } catch (InvalidCipherTextException e) {</span>
<span class="nc" id="L1246">                throw new GordianCryptoException(&quot;Failed to process data&quot;, e);</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianCoreCipherFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.core.cipher</a> &gt; <span class="el_source">GordianCoreCipherFactory.java</span></div><h1>GordianCoreCipherFactory.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.core.cipher;

import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.base.GordianKeySpec;
import net.sourceforge.joceanus.gordianknot.api.base.GordianLength;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianCipherMode;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianCipherSpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianPBESpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianPBESpec.GordianPBEDigestAndCountSpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianPadding;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamCipherSpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamCipherSpecBuilder;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec.GordianBlakeXofKey;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec.GordianChaCha20Key;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec.GordianElephantKey;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec.GordianISAPKey;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec.GordianRomulusKey;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec.GordianSalsa20Key;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec.GordianSkeinXofKey;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec.GordianSparkleKey;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec.GordianStreamSubKeyType;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec.GordianVMPCKey;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeyType;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianSymCipherSpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianSymKeySpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianSymKeyType;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianWrapper;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigestSpec;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigestSpecBuilder;
import net.sourceforge.joceanus.gordianknot.api.key.GordianKey;
import net.sourceforge.joceanus.gordianknot.api.key.GordianKeyLengths;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianBaseData;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianDataException;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Core Cipher factory.
 */
public abstract class GordianCoreCipherFactory
    implements GordianBaseCipherFactory {
    /**
     * The factory.
     */
    private final GordianBaseFactory theFactory;

    /**
     * The Cipher AlgIds.
     */
    private GordianCipherAlgId theCipherAlgIds;

    /**
     * Constructor.
     * @param pFactory the factory.
     */
<span class="fc" id="L80">    protected GordianCoreCipherFactory(final GordianBaseFactory pFactory) {</span>
<span class="fc" id="L81">        theFactory = pFactory;</span>
<span class="fc" id="L82">    }</span>

    /**
     * Obtain the factory.
     * @return the factory
     */
    protected GordianBaseFactory getFactory() {
<span class="fc" id="L89">        return theFactory;</span>
    }

    @Override
    public Predicate&lt;GordianSymKeySpec&gt; supportedSymKeySpecs() {
<span class="fc" id="L94">        return this::validSymKeySpec;</span>
    }

    @Override
    public Predicate&lt;GordianSymCipherSpec&gt; supportedSymCipherSpecs() {
<span class="fc" id="L99">        return this::validSymCipherSpec;</span>
    }

    @Override
    public Predicate&lt;GordianSymKeyType&gt; supportedSymKeyTypes() {
<span class="fc" id="L104">        return t -&gt; theFactory.getValidator().validSymKeyType(t);</span>
    }

    @Override
    public Predicate&lt;GordianStreamKeySpec&gt; supportedStreamKeySpecs() {
<span class="fc" id="L109">        return this::validStreamKeySpec;</span>
    }

    @Override
    public Predicate&lt;GordianStreamCipherSpec&gt; supportedStreamCipherSpecs() {
<span class="fc" id="L114">        return this::validStreamCipherSpec;</span>
    }

    @Override
    public Predicate&lt;GordianStreamKeyType&gt; supportedStreamKeyTypes() {
<span class="fc" id="L119">        return t -&gt; theFactory.getValidator().validStreamKeyType(t);</span>
    }

    @Override
    public Predicate&lt;GordianPBECipherSpec&lt;? extends GordianKeySpec&gt;&gt; supportedPBECipherSpecs() {
<span class="fc" id="L124">        return this::validPBECipherSpec;</span>
    }

    /**
     * Create a wrapCipher.
     * @param pKey the key
     * @param pBlockCipher the underlying block cipher
     * @return the wrapCipher
     */
    protected GordianWrapper createKeyWrapper(final GordianKey&lt;GordianSymKeySpec&gt; pKey,
                                              final GordianCoreCipher&lt;GordianSymKeySpec&gt; pBlockCipher) {
<span class="fc" id="L135">        return new GordianCoreWrapper(theFactory, pKey, pBlockCipher);</span>
    }

    /**
     * Check SymKeySpec.
     * @param pSymKeySpec the symKeySpec
     * @return true/false
     */
    public boolean validSymKeySpec(final GordianSymKeySpec pSymKeySpec) {
        /* Reject invalid keySpec */
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (pSymKeySpec == null</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">                || !pSymKeySpec.isValid()) {</span>
<span class="nc" id="L147">            return false;</span>
        }
<span class="fc" id="L149">        return supportedSymKeyTypes().test(pSymKeySpec.getSymKeyType());</span>
    }

    /**
     * validate the symCipherSpec.
     * @param pCipherSpec the cipherSpec.
     * @return true/false
     */
    protected boolean validSymCipherSpec(final GordianSymCipherSpec pCipherSpec) {
        /* Reject invalid cipherSpec */
<span class="pc bpc" id="L159" title="2 of 4 branches missed.">        if (pCipherSpec == null || !pCipherSpec.isValid()) {</span>
<span class="nc" id="L160">            return false;</span>
        }

        /* Reject unsupported keySpecs */
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (!supportedSymKeySpecs().test(pCipherSpec.getKeyType())) {</span>
<span class="nc" id="L165">            return false;</span>
        }

        /* Reject null modes */
<span class="fc" id="L169">        final GordianCipherMode myMode = pCipherSpec.getCipherMode();</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (myMode == null) {</span>
<span class="nc" id="L171">            return false;</span>
        }

        /* Check that the mode is valid for the keyType */
<span class="fc" id="L175">        final GordianSymKeySpec myKeySpec = pCipherSpec.getKeyType();</span>
<span class="fc" id="L176">        final GordianSymKeyType myKeyType = myKeySpec.getSymKeyType();</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (!myMode.validForSymKey(myKeySpec)) {</span>
<span class="fc" id="L178">            return false;</span>
        }

        /* Disallow AAD for RC5-64 */
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (GordianSymKeyType.RC5.equals(myKeyType)</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                &amp;&amp; GordianLength.LEN_128.equals(myKeySpec.getBlockLength())</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                &amp;&amp; myMode.isAAD()) {</span>
<span class="fc" id="L185">            return false;</span>
        }

        /* Determine whether we have a short block length */
<span class="fc" id="L189">        final int myLen = myKeySpec.getBlockLength().getLength();</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        final boolean shortBlock = myLen &lt; GordianLength.LEN_128.getLength();</span>

        /* Reject modes which do not allow short blocks */
<span class="fc bfc" id="L193" title="All 4 branches covered.">        if (shortBlock &amp;&amp; !myMode.allowShortBlock()) {</span>
<span class="fc" id="L194">            return false;</span>
        }

        /* Reject modes which do not allow non-standard blocks */
<span class="fc bfc" id="L198" title="All 2 branches covered.">        final boolean stdBlock = myLen == GordianLength.LEN_128.getLength();</span>
<span class="fc bfc" id="L199" title="All 4 branches covered.">        if (!stdBlock &amp;&amp; myMode.needsStdBlock()) {</span>
<span class="fc" id="L200">            return false;</span>
        }

        /* Reject bad padding */
<span class="fc" id="L204">        final GordianPadding myPadding = pCipherSpec.getPadding();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">        return myMode.hasPadding()</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">               ? myPadding != null</span>
<span class="fc" id="L207">               : GordianPadding.NONE.equals(myPadding);</span>
    }

    /**
     * Check the keySpec.
     * @param pKeySpec the keySpec
     * @throws GordianException on error
     */
    protected void checkKeySpec(final GordianKeySpec pKeySpec) throws GordianException {
        /* Assume failure */
<span class="fc" id="L217">        boolean bValid = false;</span>

        /* If this is a streamKeySpec */
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (pKeySpec instanceof GordianStreamKeySpec mySpec) {</span>
            /* Check validity of StreamKey */
<span class="fc" id="L222">            bValid = supportedStreamKeySpecs().test(mySpec);</span>

            /* If this is a symKeySpec */
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        } else  if (pKeySpec instanceof GordianSymKeySpec mySpec) {</span>
            /* Check validity of SymKey */
<span class="fc" id="L227">            bValid = supportedSymKeySpecs().test(mySpec);</span>
        }

        /* Report error */
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (!bValid) {</span>
<span class="nc" id="L232">            throw new GordianDataException(GordianBaseData.getInvalidText(pKeySpec));</span>
        }
<span class="fc" id="L234">    }</span>

    /**
     * Check the symKeySpec.
     * @param pKeySpec the symKeySpec
     * @throws GordianException on error
     */
    public void checkSymKeySpec(final GordianSymKeySpec pKeySpec) throws GordianException {
        /* Check validity of SymKey */
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (!supportedSymKeySpecs().test(pKeySpec)) {</span>
<span class="nc" id="L244">            throw new GordianDataException(GordianBaseData.getInvalidText(pKeySpec));</span>
        }
<span class="nc" id="L246">    }</span>

    /**
     * Check the symCipherSpec.
     * @param pCipherSpec the cipherSpec
     * @throws GordianException on error
     */
    public void checkSymCipherSpec(final GordianSymCipherSpec pCipherSpec) throws GordianException {
        /* Reject invalid cipherSpec */
<span class="pc bpc" id="L255" title="2 of 4 branches missed.">        if (pCipherSpec == null || !pCipherSpec.isValid()) {</span>
<span class="nc" id="L256">            throw new GordianDataException(GordianBaseData.getInvalidText(pCipherSpec));</span>
        }

        /* Check validity of SymKey */
<span class="fc" id="L260">        final GordianSymKeySpec myKeySpec = pCipherSpec.getKeyType();</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if (!supportedSymKeySpecs().test(myKeySpec)) {</span>
<span class="nc" id="L262">            throw new GordianDataException(GordianBaseData.getInvalidText(pCipherSpec));</span>
        }

        /* Check validity of Mode */
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (!validSymCipherSpec(pCipherSpec)) {</span>
<span class="nc" id="L267">            throw new GordianDataException(GordianBaseData.getInvalidText(pCipherSpec));</span>
        }
<span class="fc" id="L269">    }</span>

    /**
     * Check the streamCipherSpec.
     * @param pCipherSpec the cipherSpec
     * @throws GordianException on error
     */
    public void checkStreamCipherSpec(final GordianStreamCipherSpec pCipherSpec) throws GordianException {
        /* Reject invalid cipherSpec */
<span class="pc bpc" id="L278" title="2 of 4 branches missed.">        if (pCipherSpec == null || !pCipherSpec.isValid()) {</span>
<span class="nc" id="L279">            throw new GordianDataException(GordianBaseData.getInvalidText(pCipherSpec));</span>
        }

        /* Check validity of StreamKey */
<span class="fc" id="L283">        final GordianStreamKeySpec myKeySpec = pCipherSpec.getKeyType();</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        if (!supportedStreamKeySpecs().test(myKeySpec)) {</span>
<span class="nc" id="L285">            throw new GordianDataException(GordianBaseData.getInvalidText(myKeySpec));</span>
        }

        /* Check validity of Mode */
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">        if (!validStreamCipherSpec(pCipherSpec)) {</span>
<span class="nc" id="L290">            throw new GordianDataException(GordianBaseData.getInvalidText(pCipherSpec));</span>
        }
<span class="fc" id="L292">    }</span>

    /**
     * Check StreamCipherSpec.
     * @param pCipherSpec the streamCipherSpec
     * @return true/false
     */
    protected boolean validStreamCipherSpec(final GordianStreamCipherSpec pCipherSpec) {
<span class="fc" id="L300">        return true;</span>
    }

    /**
     * Check StreamKeySpec.
     * @param pKeySpec the streamKeySpec
     * @return true/false
     */
    protected boolean validStreamKeySpec(final GordianStreamKeySpec pKeySpec) {
        /* Reject invalid keySpec */
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (pKeySpec == null</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                || !pKeySpec.isValid()) {</span>
<span class="nc" id="L312">            return false;</span>
        }
<span class="fc" id="L314">        return supportedStreamKeyTypes().test(pKeySpec.getStreamKeyType());</span>
    }

    /**
     * Obtain Identifier for cipherSpec.
     * @param pSpec the cipherSpec.
     * @return the Identifier
     */
    public AlgorithmIdentifier getIdentifierForSpec(final GordianCipherSpec&lt;?&gt; pSpec) {
<span class="fc" id="L323">        return getCipherAlgIds().getIdentifierForSpec(pSpec);</span>
    }

    /**
     * Obtain cipherSpec for Identifier.
     * @param pIdentifier the identifier.
     * @return the cipherSpec (or null if not found)
     */
    public GordianCipherSpec&lt;?&gt; getCipherSpecForIdentifier(final AlgorithmIdentifier pIdentifier) {
<span class="fc" id="L332">        return getCipherAlgIds().getCipherSpecForIdentifier(pIdentifier);</span>
    }

    /**
     * Obtain the cipher algorithm Ids.
     * @return the cipher Algorithm Ids
     */
    private GordianCipherAlgId getCipherAlgIds() {
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (theCipherAlgIds == null) {</span>
<span class="fc" id="L341">            theCipherAlgIds = new GordianCipherAlgId(theFactory);</span>
        }
<span class="fc" id="L343">        return theCipherAlgIds;</span>
    }

    /**
     * Check SymCipherSpec and PBESpec combination.
     * @param pPBECipherSpec the PBESpec
     * @return true/false
     */
    public boolean validPBECipherSpec(final GordianPBECipherSpec&lt;? extends GordianKeySpec&gt; pPBECipherSpec) {
        /* Check basic validity */
<span class="pc bpc" id="L353" title="2 of 4 branches missed.">        if (pPBECipherSpec == null || !pPBECipherSpec.isValid()) {</span>
<span class="nc" id="L354">            return false;</span>
        }

        /* Digest if specified must be SHA512 currently */
<span class="fc" id="L358">        final GordianPBESpec myPBESpec = pPBECipherSpec.getPBESpec();</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (myPBESpec instanceof GordianPBEDigestAndCountSpec myCountSpec) {</span>
<span class="fc" id="L360">            final GordianDigestSpec mySpec = myCountSpec.getDigestSpec();</span>
<span class="fc" id="L361">            return GordianDigestSpecBuilder.sha2(GordianLength.LEN_512).equals(mySpec);</span>
        }

        /* OK */
<span class="fc" id="L365">        return true;</span>
    }

    @Override
    public List&lt;GordianSymCipherSpec&gt; listAllSupportedSymCipherSpecs(final GordianSymKeySpec pSpec) {
<span class="fc" id="L370">        return listAllSymCipherSpecs(pSpec)</span>
<span class="fc" id="L371">                .stream()</span>
<span class="fc" id="L372">                .filter(s -&gt; supportedSymCipherSpecs().test(s))</span>
<span class="fc" id="L373">                .collect(Collectors.toCollection(ArrayList::new));</span>
    }

    @Override
    public List&lt;GordianSymKeySpec&gt; listAllSupportedSymKeySpecs(final GordianLength pKeyLen) {
<span class="fc" id="L378">        return listAllSymKeySpecs(pKeyLen)</span>
<span class="fc" id="L379">                .stream()</span>
<span class="fc" id="L380">                .filter(supportedSymKeySpecs())</span>
<span class="fc" id="L381">                .collect(Collectors.toCollection(ArrayList::new));</span>
    }

    @Override
    public List&lt;GordianSymKeyType&gt; listAllSupportedSymKeyTypes() {
<span class="fc" id="L386">        return Arrays.stream(GordianSymKeyType.values())</span>
<span class="fc" id="L387">                .filter(supportedSymKeyTypes())</span>
<span class="fc" id="L388">                .collect(Collectors.toCollection(ArrayList::new));</span>
    }

    @Override
    public List&lt;GordianStreamCipherSpec&gt; listAllSupportedStreamCipherSpecs(final GordianLength pKeyLen) {
<span class="fc" id="L393">        final List&lt;GordianStreamCipherSpec&gt; myResult = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        for (GordianStreamKeySpec mySpec : listAllSupportedStreamKeySpecs(pKeyLen)) {</span>
            /* Add the standard cipher */
<span class="fc" id="L396">            final GordianStreamCipherSpec myCipherSpec = GordianStreamCipherSpecBuilder.stream(mySpec);</span>
<span class="fc" id="L397">            myResult.add(myCipherSpec);</span>

            /* Add the AAD Cipher if supported */
<span class="fc bfc" id="L400" title="All 2 branches covered.">            if (mySpec.supportsAEAD()) {</span>
<span class="fc" id="L401">                final GordianStreamCipherSpec myAADSpec = GordianStreamCipherSpecBuilder.stream(mySpec, true);</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">                if (supportedStreamCipherSpecs().test(myAADSpec)) {</span>
<span class="fc" id="L403">                    myResult.add(myAADSpec);</span>
                }
            }
<span class="fc" id="L406">        }</span>
<span class="fc" id="L407">        return myResult;</span>
    }

    @Override
    public List&lt;GordianStreamKeySpec&gt; listAllSupportedStreamKeySpecs(final GordianLength pKeyLen) {
<span class="fc" id="L412">        return listAllStreamKeySpecs(pKeyLen)</span>
<span class="fc" id="L413">                .stream()</span>
<span class="fc" id="L414">                .filter(supportedStreamKeySpecs())</span>
<span class="fc" id="L415">                .collect(Collectors.toCollection(ArrayList::new));</span>
    }

    @Override
    public List&lt;GordianStreamKeyType&gt; listAllSupportedStreamKeyTypes() {
<span class="nc" id="L420">        return Arrays.stream(GordianStreamKeyType.values())</span>
<span class="nc" id="L421">                .filter(supportedStreamKeyTypes())</span>
<span class="nc" id="L422">                .collect(Collectors.toCollection(ArrayList::new));</span>
    }

    @Override
    public List&lt;GordianSymKeySpec&gt; listAllSymKeySpecs(final GordianLength pKeyLen) {
        /* Create the array list */
<span class="fc" id="L428">        final List&lt;GordianSymKeySpec&gt; myList = new ArrayList&lt;&gt;();</span>

        /* Check that the keyLength is supported */
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        if (!GordianKeyLengths.isSupportedLength(pKeyLen)) {</span>
<span class="nc" id="L432">            return myList;</span>
        }

        /* For each symKey type */
<span class="fc bfc" id="L436" title="All 2 branches covered.">        for (final GordianSymKeyType myType : GordianSymKeyType.values()) {</span>
            /* For each supported block length */
<span class="fc bfc" id="L438" title="All 2 branches covered.">            for (final GordianLength myBlkLen : myType.getSupportedBlockLengths()) {</span>
                /* Add spec if valid for blkLen and keyLen */
<span class="fc bfc" id="L440" title="All 2 branches covered.">                if (myType.validBlockAndKeyLengths(myBlkLen, pKeyLen)) {</span>
<span class="fc" id="L441">                    myList.add(new GordianSymKeySpec(myType, myBlkLen, pKeyLen));</span>
                }
            }
        }

        /* Return the list */
<span class="fc" id="L447">        return myList;</span>
    }

    @Override
    public List&lt;GordianSymCipherSpec&gt; listAllSymCipherSpecs(final GordianSymKeySpec pSpec) {
        /* Create the array list */
<span class="fc" id="L453">        final List&lt;GordianSymCipherSpec&gt; myList = new ArrayList&lt;&gt;();</span>

        /* Loop through the modes */
<span class="fc bfc" id="L456" title="All 2 branches covered.">        for (GordianCipherMode myMode : GordianCipherMode.values()) {</span>
            /* If the mode has padding */
<span class="fc bfc" id="L458" title="All 2 branches covered.">            if (myMode.hasPadding()) {</span>
                /* Loop through the paddings */
<span class="fc bfc" id="L460" title="All 2 branches covered.">                for (GordianPadding myPadding : GordianPadding.values()) {</span>
<span class="fc" id="L461">                    myList.add(new GordianSymCipherSpec(pSpec, myMode, myPadding));</span>
                }

                /* else no padding */
            } else {
<span class="fc" id="L466">                myList.add(new GordianSymCipherSpec(pSpec, myMode, GordianPadding.NONE));</span>
            }
        }

        /* Return the list */
<span class="fc" id="L471">        return myList;</span>
    }

    /**
     * List all possible streamKeySpecs for the keyLength.
     * @param pKeyLen the keyLength
     * @return the list
     */
    private static List&lt;GordianStreamKeySpec&gt; listAllStreamKeySpecs(final GordianLength pKeyLen) {
        /* Create the array list */
<span class="fc" id="L481">        final List&lt;GordianStreamKeySpec&gt; myList = new ArrayList&lt;&gt;();</span>

        /* Check that the keyLength is supported */
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        if (!GordianKeyLengths.isSupportedLength(pKeyLen)) {</span>
<span class="nc" id="L485">            return myList;</span>
        }

        /* For each streamKey type */
<span class="fc bfc" id="L489" title="All 2 branches covered.">        for (final GordianStreamKeyType myType : GordianStreamKeyType.values()) {</span>
            /* if valid for keyLength */
<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (myType.validForKeyLength(pKeyLen)) {</span>
                /* If we need a subType */
<span class="fc bfc" id="L493" title="All 2 branches covered.">                if (myType.needsSubKeyType()) {</span>
                    /* Add all valid subKeyTypes */
<span class="fc" id="L495">                    myList.addAll(listStreamSubKeys(myType, pKeyLen));</span>

                    /* Else just add the spec */
                } else {
<span class="fc" id="L499">                    myList.add(new GordianStreamKeySpec(myType, pKeyLen));</span>
                }
            }
        }

        /* Return the list */
<span class="fc" id="L505">        return myList;</span>
    }

    /**
     * List all possible subKeyTypes Specs.
     * @param pKeyType the keyType
     * @param pKeyLen the keyLength
     * @return the list
     */
    private static List&lt;GordianStreamKeySpec&gt; listStreamSubKeys(final GordianStreamKeyType pKeyType,
                                                                final GordianLength pKeyLen) {
        /* Create the array list */
<span class="fc" id="L517">        final List&lt;GordianStreamKeySpec&gt; myList = new ArrayList&lt;&gt;();</span>

        /* Loop through the subKeyTypes */
<span class="fc bfc" id="L520" title="All 2 branches covered.">        for (GordianStreamSubKeyType mySubKeyType : listStreamSubKeys(pKeyType)) {</span>
            /* Add valid subKeySpec */
<span class="fc" id="L522">            final GordianStreamKeySpec mySpec = new GordianStreamKeySpec(pKeyType, pKeyLen, mySubKeyType);</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if (mySpec.isValid()) {</span>
<span class="fc" id="L524">                myList.add(mySpec);</span>
            }
<span class="fc" id="L526">        }</span>

        /* Return the list */
<span class="fc" id="L529">        return myList;</span>
    }

    /**
     * List all possible subKeyTypes.
     * @param pKeyType the keyType
     * @return the list
     */
    private static List&lt;GordianStreamSubKeyType&gt; listStreamSubKeys(final GordianStreamKeyType pKeyType) {
        /* Switch on keyType */
<span class="pc bpc" id="L539" title="1 of 10 branches missed.">        switch (pKeyType) {</span>
            case SALSA20:
<span class="fc" id="L541">                return Arrays.asList(GordianSalsa20Key.values());</span>
            case CHACHA20:
<span class="fc" id="L543">                return Arrays.asList(GordianChaCha20Key.values());</span>
            case VMPC:
<span class="fc" id="L545">                return Arrays.asList(GordianVMPCKey.values());</span>
            case SKEINXOF:
<span class="fc" id="L547">                return Arrays.asList(GordianSkeinXofKey.values());</span>
            case BLAKE2XOF:
<span class="fc" id="L549">                return Arrays.asList(GordianBlakeXofKey.values());</span>
            case ELEPHANT:
<span class="fc" id="L551">                return Arrays.asList(GordianElephantKey.values());</span>
            case ISAP:
<span class="fc" id="L553">                return Arrays.asList(GordianISAPKey.values());</span>
            case ROMULUS:
<span class="fc" id="L555">                return Arrays.asList(GordianRomulusKey.values());</span>
            case SPARKLE:
<span class="fc" id="L557">                return Arrays.asList(GordianSparkleKey.values());</span>
            default:
<span class="nc" id="L559">                return Collections.emptyList();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianCoreWrapper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.core.cipher</a> &gt; <span class="el_source">GordianCoreWrapper.java</span></div><h1>GordianCoreWrapper.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.core.cipher;

import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.base.GordianKeySpec;
import net.sourceforge.joceanus.gordianknot.api.base.GordianLength;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianCipherParameters;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianSymKeySpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianWrapper;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairFactory;
import net.sourceforge.joceanus.gordianknot.api.key.GordianKey;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPair;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairSpec;
import net.sourceforge.joceanus.gordianknot.api.mac.GordianMacSpec;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianDataConverter;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianDataException;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianLogicException;
import net.sourceforge.joceanus.gordianknot.impl.core.key.GordianCoreKey;
import net.sourceforge.joceanus.gordianknot.impl.core.key.GordianCoreKeyGenerator;
import net.sourceforge.joceanus.gordianknot.impl.core.keypair.GordianCoreKeyPairGenerator;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.util.Arrays;

import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

/**
 * GordianKnot base for WrapCipher.
 * &lt;p&gt;
 * This class uses a variant of RFC5649 to wrap keyData. It has been modified so that it does not
 * require a 128-block cipher.
 */
public class GordianCoreWrapper
        implements GordianWrapper {
    /**
     * Wrap repeat count.
     */
    private static final int WRAP_COUNT = 6;

    /**
     * Integrity value.
     */
    private static final byte INTEGRITY_VALUE1 = (byte) 0xA6;

    /**
     * Integrity value.
     */
    private static final byte INTEGRITY_VALUE2 = (byte) 0x59;

    /**
     * Integrity modulo.
     */
    private static final int INTEGRITY_MODULO = 4;

    /**
     * The Security Factory.
     */
    private final GordianBaseFactory theFactory;

    /**
     * Underlying key.
     */
    private final GordianKey&lt;GordianSymKeySpec&gt; theKey;

    /**
     * Underlying cipher.
     */
    private final GordianCoreCipher&lt;GordianSymKeySpec&gt; theCipher;

    /**
     * The block size.
     */
    private final int theBlockLen;

    /**
     * Constructor.
     * @param pFactory the Security Factory
     * @param pKey the key
     * @param pCipher the underlying cipher
     */
    GordianCoreWrapper(final GordianBaseFactory pFactory,
                       final GordianKey&lt;GordianSymKeySpec&gt; pKey,
<span class="fc" id="L99">                       final GordianCoreCipher&lt;GordianSymKeySpec&gt; pCipher) {</span>
<span class="fc" id="L100">        theFactory = pFactory;</span>
<span class="fc" id="L101">        theKey = pKey;</span>
<span class="fc" id="L102">        theCipher = pCipher;</span>
<span class="fc" id="L103">        theBlockLen = getKeySpec().getBlockLength().getByteLength() &gt;&gt; 1;</span>
<span class="fc" id="L104">    }</span>

    /**
     * Constructor.
     * @param pFactory the Security Factory
     * @param pBlockLen the blockLength
     */
    protected GordianCoreWrapper(final GordianBaseFactory pFactory,
<span class="fc" id="L112">                                 final int pBlockLen) {</span>
<span class="fc" id="L113">        theFactory = pFactory;</span>
<span class="fc" id="L114">        theKey = null;</span>
<span class="fc" id="L115">        theCipher = null;</span>
<span class="fc" id="L116">        theBlockLen = pBlockLen &gt;&gt; 1;</span>
<span class="fc" id="L117">    }</span>

    @Override
    public GordianSymKeySpec getKeySpec() {
<span class="fc" id="L121">        return theCipher.getKeyType();</span>
    }

    /**
     * Obtain the factory.
     * @return the factory
     */
    protected GordianBaseFactory getFactory() {
<span class="nc" id="L129">        return theFactory;</span>
    }

    @Override
    public byte[] secureKey(final GordianKey&lt;?&gt; pKeyToSecure) throws GordianException {
        /* Secure the bytes */
<span class="fc" id="L135">        final byte[] myBytes = secureBytes(((GordianCoreKey&lt;?&gt;) pKeyToSecure).getKeyBytes());</span>

        /* Create the ASN1 */
<span class="fc" id="L138">        final AlgorithmIdentifier myAlgId = theFactory.getIdentifierForSpec(pKeyToSecure.getKeyType());</span>
<span class="fc" id="L139">        final GordianWrappedKeyASN1 myASN1 = new GordianWrappedKeyASN1(myAlgId, myBytes);</span>
<span class="fc" id="L140">        return myASN1.getEncodedBytes();</span>
    }

    @Override
    public &lt;T extends GordianKeySpec&gt; GordianKey&lt;T&gt; deriveKey(final byte[] pSecuredKey,
                                                              final T pKeyType) throws GordianException {
        /* Parse the ASN1 */
<span class="fc" id="L147">        final GordianWrappedKeyASN1 myASN1 = GordianWrappedKeyASN1.getInstance(pSecuredKey);</span>
<span class="fc" id="L148">        final AlgorithmIdentifier myAlgId = myASN1.getKeySpecId();</span>
<span class="fc" id="L149">        final byte[] myWrappedKey = myASN1.getWrappedKey();</span>

        /* Check the algorithmId */
<span class="fc" id="L152">        final GordianKeySpec mySpec = theFactory.getKeySpecForIdentifier(myAlgId);</span>
<span class="pc bpc" id="L153" title="2 of 4 branches missed.">        if (mySpec == null || !mySpec.equals(pKeyType)) {</span>
<span class="nc" id="L154">            throw new GordianDataException(&quot;Incorrect KeySpec&quot;);</span>
        }

        /* Unwrap the bytes */
<span class="fc" id="L158">        final byte[] myBytes = deriveBytes(myWrappedKey);</span>

        /* Access the relevant keyGenerator */
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        final GordianCoreKeyGenerator&lt;T&gt; myGenerator = pKeyType instanceof GordianMacSpec</span>
<span class="nc" id="L162">                ? (GordianCoreKeyGenerator&lt;T&gt;) theFactory.getMacFactory().getKeyGenerator(pKeyType)</span>
<span class="fc" id="L163">                : (GordianCoreKeyGenerator&lt;T&gt;) theFactory.getCipherFactory().getKeyGenerator(pKeyType);</span>

        /* Generate the key */
<span class="fc" id="L166">        return myGenerator.buildKeyFromBytes(myBytes);</span>
    }

    @Override
    public byte[] securePrivateKey(final GordianKeyPair pKeyPairToSecure) throws GordianException {
        /* Access the KeyPair Generator */
<span class="nc" id="L172">        final GordianKeyPairFactory myFactory = theFactory.getAsyncFactory().getKeyPairFactory();</span>
<span class="nc" id="L173">        final GordianCoreKeyPairGenerator myGenerator = (GordianCoreKeyPairGenerator) myFactory.getKeyPairGenerator(pKeyPairToSecure.getKeyPairSpec());</span>
<span class="nc" id="L174">        final PKCS8EncodedKeySpec myPKCS8Key = myGenerator.getPKCS8Encoding(pKeyPairToSecure);</span>
<span class="nc" id="L175">        return secureBytes(myPKCS8Key.getEncoded());</span>
    }

    @Override
    public GordianKeyPair deriveKeyPair(final X509EncodedKeySpec pPublicKeySpec,
                                        final byte[] pSecuredPrivateKey) throws GordianException {
        /* Access the PKCS8Encoding */
<span class="nc" id="L182">        final PKCS8EncodedKeySpec myPrivate = derivePrivateKeySpec(pSecuredPrivateKey);</span>

        /* Determine and check the keyPairSpec */
<span class="nc" id="L185">        final GordianKeyPairFactory myFactory = theFactory.getAsyncFactory().getKeyPairFactory();</span>
<span class="nc" id="L186">        final GordianKeyPairSpec myKeySpec = myFactory.determineKeyPairSpec(pPublicKeySpec);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (!myKeySpec.equals(myFactory.determineKeyPairSpec(myPrivate))) {</span>
<span class="nc" id="L188">            throw new GordianLogicException(&quot;Mismatch on keySpecs&quot;);</span>
        }

        /* Derive the keyPair */
<span class="nc" id="L192">        final GordianCoreKeyPairGenerator myGenerator = (GordianCoreKeyPairGenerator) myFactory.getKeyPairGenerator(myKeySpec);</span>
<span class="nc" id="L193">        return myGenerator.deriveKeyPair(pPublicKeySpec, myPrivate);</span>
    }

    /**
     * derive private key.
      * @param pSecuredPrivateKey the secured privateKey
     * @return the derived key
     * @throws GordianException on error
     */
    private PKCS8EncodedKeySpec derivePrivateKeySpec(final byte[] pSecuredPrivateKey) throws GordianException {
        /* Derive the keySpec */
<span class="nc" id="L204">        final byte[] myBytes = deriveBytes(pSecuredPrivateKey);</span>
<span class="nc" id="L205">        return new PKCS8EncodedKeySpec(myBytes);</span>
    }

    @Override
    public byte[] secureBytes(final byte[] pBytesToSecure) throws GordianException {
        /* Determine number of blocks */
<span class="fc" id="L211">        final int myDataLen = pBytesToSecure.length;</span>
<span class="fc" id="L212">        int myNumBlocks = myDataLen</span>
                / theBlockLen;

        /* Calculate padding length */
        final int myTrueLen;
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (myDataLen % theBlockLen == 0) {</span>
<span class="fc" id="L218">            myTrueLen = myDataLen;</span>
        } else {
<span class="fc" id="L220">            myNumBlocks++;</span>
<span class="fc" id="L221">            myTrueLen = myNumBlocks</span>
                    * theBlockLen;
        }

        /* Determine semantics of the initial block */
<span class="fc" id="L226">        final byte[] myByteLen = GordianDataConverter.integerToByteArray(myDataLen);</span>
<span class="fc" id="L227">        int myCheckLen = theBlockLen - Integer.BYTES;</span>
<span class="fc" id="L228">        int myHdrLen = theBlockLen;</span>

        /* Handle 64-bit ciphers */
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (myCheckLen == 0) {</span>
<span class="fc" id="L232">            myCheckLen = theBlockLen;</span>
<span class="fc" id="L233">            myHdrLen += Integer.BYTES;</span>
<span class="fc" id="L234">            myNumBlocks++;</span>
        }

        /* Add a block for random data */
<span class="fc" id="L238">        myNumBlocks++;</span>
<span class="fc" id="L239">        myHdrLen += theBlockLen;</span>

        /* Allocate buffer for data and encryption */
<span class="fc" id="L242">        final int myBufferLen = theBlockLen &lt;&lt; 1;</span>
<span class="fc" id="L243">        final byte[] myData = new byte[myTrueLen</span>
                + myHdrLen];
<span class="fc" id="L245">        final byte[] myBuffer = new byte[myBufferLen];</span>
<span class="fc" id="L246">        final byte[] myResult = new byte[myBufferLen];</span>
<span class="fc" id="L247">        final byte[] myRandom = new byte[theBlockLen];</span>

        /* Build the initial block */
<span class="fc bfc" id="L250" title="All 2 branches covered.">        for (int i = 0; i &lt; myCheckLen; i++) {</span>
<span class="fc" id="L251">            myData[i] = getIntegrityValue(i);</span>
        }
<span class="fc" id="L253">        System.arraycopy(myByteLen, 0, myData, myCheckLen, Integer.BYTES);</span>
<span class="fc" id="L254">        theFactory.getRandomSource().getRandom().nextBytes(myRandom);</span>
<span class="fc" id="L255">        System.arraycopy(myRandom, 0, myData, myCheckLen + Integer.BYTES, theBlockLen);</span>
<span class="fc" id="L256">        System.arraycopy(pBytesToSecure, 0, myData, myHdrLen, myDataLen);</span>

        /* Initialise the cipher */
<span class="fc" id="L259">        initCipherForWrapping();</span>

        /* Loop WRAP_COUNT times */
<span class="fc" id="L262">        int myCount = 1;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">        for (int myCycle = 0; myCycle &lt; WRAP_COUNT; myCycle++) {</span>
            /* Loop through the data blocks */
<span class="fc bfc" id="L265" title="All 2 branches covered.">            for (int myBlock = 1, myOffset = theBlockLen; myBlock &lt;= myNumBlocks; myBlock++, myOffset += theBlockLen) {</span>
                /* Build the data to be encrypted */
<span class="fc" id="L267">                System.arraycopy(myData, 0, myBuffer, 0, theBlockLen);</span>
<span class="fc" id="L268">                System.arraycopy(myData, myOffset, myBuffer, theBlockLen, theBlockLen);</span>

                /* Encrypt the byte array */
<span class="fc" id="L271">                iterateCipher(myBuffer, myBufferLen, myResult);</span>

                /* Adjust the result using the count as a mask */
<span class="fc bfc" id="L274" title="All 2 branches covered.">                for (int myMask = myCount++, myIndex = myBufferLen - 1; myMask != 0; myMask &gt;&gt;&gt;= Byte.SIZE, myIndex--) {</span>
<span class="fc" id="L275">                    myResult[myIndex] ^= (byte) myMask;</span>
                }

                /* Restore encrypted data */
<span class="fc" id="L279">                System.arraycopy(myResult, 0, myData, 0, theBlockLen);</span>
<span class="fc" id="L280">                System.arraycopy(myResult, theBlockLen, myData, myOffset, theBlockLen);</span>
            }
        }

        /* Return the wrapped data */
<span class="fc" id="L285">        return myData;</span>
    }

    @Override
    public byte[] deriveBytes(final byte[] pSecuredBytes,
                              final int pOffset) throws GordianException {
        /* Determine number of blocks */
<span class="fc" id="L292">        int myDataLen = pSecuredBytes.length</span>
                - theBlockLen - pOffset;
<span class="fc" id="L294">        final int myNumBlocks = myDataLen</span>
                / theBlockLen;

        /* Data must be a multiple of BlockLength */
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (myNumBlocks * theBlockLen != myDataLen) {</span>
<span class="nc" id="L299">            throw new GordianDataException(&quot;Invalid data length&quot;);</span>
        }

        /* Allocate buffers for data and encryption */
<span class="fc" id="L303">        final int myBufferLen = theBlockLen &lt;&lt; 1;</span>
<span class="fc" id="L304">        final byte[] myData = new byte[pSecuredBytes.length - pOffset];</span>
<span class="fc" id="L305">        System.arraycopy(pSecuredBytes, pOffset, myData, 0, pSecuredBytes.length - pOffset);</span>
<span class="fc" id="L306">        final byte[] myBuffer = new byte[myBufferLen];</span>
<span class="fc" id="L307">        final byte[] myResult = new byte[myBufferLen];</span>

        /* Initialise the cipher */
<span class="fc" id="L310">        initCipherForUnwrapping();</span>

        /* Loop WRAP_COUNT times */
<span class="fc" id="L313">        int myCount = myNumBlocks * WRAP_COUNT;</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        for (int myCycle = WRAP_COUNT; myCycle &gt; 0; myCycle--) {</span>
            /* Loop through the data blocks */
<span class="fc" id="L316">            for (int myBlock = myNumBlocks, myOffset = theBlockLen</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">                    * myBlock; myBlock &gt;= 1; myBlock--, myOffset -= theBlockLen) {</span>
                /* Build the data to be decrypted */
<span class="fc" id="L319">                System.arraycopy(myData, 0, myBuffer, 0, theBlockLen);</span>
<span class="fc" id="L320">                System.arraycopy(myData, myOffset, myBuffer, theBlockLen, theBlockLen);</span>

                /* Adjust the buffer using the count as a mask */
<span class="fc bfc" id="L323" title="All 2 branches covered.">                for (int myMask = myCount--, myIndex = myBufferLen - 1; myMask != 0; myMask &gt;&gt;&gt;= Byte.SIZE, myIndex--) {</span>
<span class="fc" id="L324">                    myBuffer[myIndex] ^= (byte) myMask;</span>
                }

                /* Decrypt the byte array */
<span class="fc" id="L328">                iterateCipher(myBuffer, myBufferLen, myResult);</span>

                /* Restore decrypted data */
<span class="fc" id="L331">                System.arraycopy(myResult, 0, myData, 0, theBlockLen);</span>
<span class="fc" id="L332">                System.arraycopy(myResult, theBlockLen, myData, myOffset, theBlockLen);</span>
            }
        }

        /* Handle 64-bit ciphers */
<span class="fc" id="L337">        int myCheckLen = theBlockLen - Integer.BYTES;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (myCheckLen == 0) {</span>
<span class="fc" id="L339">            myCheckLen = theBlockLen;</span>
<span class="fc" id="L340">            myDataLen -= theBlockLen;</span>
        }

        /* Adjust for random data */
<span class="fc" id="L344">        myDataLen -= theBlockLen;</span>

        /* Check initialisation value */
<span class="fc" id="L347">        int checkFail = 0;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        for (int myInit = 0; myInit &lt; myCheckLen; myInit++) {</span>
<span class="fc" id="L349">            checkFail |= myData[myInit] ^ getIntegrityValue(myInit);</span>
        }

        /* Obtain encoded length */
<span class="fc" id="L353">        final byte[] myByteLen = Arrays.copyOfRange(myData, myCheckLen, myCheckLen + Integer.BYTES);</span>
<span class="fc" id="L354">        final int myEncodedLen = GordianDataConverter.byteArrayToInteger(myByteLen);</span>

        /* Obtain zeroLen and check that it is valid */
<span class="fc" id="L357">        final int myZeroLen = myDataLen - myEncodedLen;</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        checkFail |= myZeroLen &lt; 0 ? 1 : 0;</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        checkFail |= myZeroLen &gt;= theBlockLen ? 2 : 0;</span>

        /* Check trailing bytes */
<span class="pc bpc" id="L362" title="1 of 4 branches missed.">        for (int myZeros = myZeroLen, myLoc = myData.length - 1; myZeros &gt; 0 &amp;&amp; myLoc &gt; 0; myZeros--, myLoc--) {</span>
            /* Check that byte is zero */
<span class="fc" id="L364">            checkFail |= myData[myLoc];</span>
        }

        /* Return unwrapped data */
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (checkFail == 0) {</span>
<span class="fc" id="L369">            return Arrays.copyOfRange(myData, myCheckLen + Integer.BYTES + theBlockLen, myData.length</span>
                    - myZeroLen);
        }

        /* Reject if checks fail */
<span class="nc" id="L374">        throw new GordianDataException(&quot;Integrity checks failed&quot;);</span>
    }

    /**
     * Determine integrity value for position.
     * @param pIndex the index
     * @return the integrity value
     */
    private static byte getIntegrityValue(final int pIndex) {
<span class="fc bfc" id="L383" title="All 2 branches covered.">        return (pIndex + 1) % INTEGRITY_MODULO &lt; 2</span>
<span class="fc" id="L384">               ? INTEGRITY_VALUE1</span>
<span class="fc" id="L385">               : INTEGRITY_VALUE2;</span>
    }

    /**
     * Initialise cipher for wrapping.
     * @throws GordianException on error
     */
    protected void initCipherForWrapping() throws GordianException {
<span class="fc" id="L393">        theCipher.initForEncrypt(GordianCipherParameters.key(theKey));</span>
<span class="fc" id="L394">    }</span>

    /**
     * Initialise cipher for unwrapping.
     * @throws GordianException on error
     */
    protected void initCipherForUnwrapping() throws GordianException {
<span class="fc" id="L401">        theCipher.initForDecrypt(GordianCipherParameters.key(theKey));</span>
<span class="fc" id="L402">    }</span>

    /**
     * Perform Cipher operation.
     * @param pInBuffer the input buffer
     * @param pBufferLen the buffer length
     * @param pResult the results buffer
     * @throws GordianException on erro
     */
    protected void iterateCipher(final byte[] pInBuffer,
                                 final int pBufferLen,
                                 final byte[] pResult) throws GordianException {
<span class="fc" id="L414">        theCipher.finish(pInBuffer, 0, pBufferLen, pResult, 0);</span>
<span class="fc" id="L415">    }</span>

    @Override
    public int getKeyWrapLength(final GordianKey&lt;?&gt; pKey) {
        /* Obtain the id of the keySpec */
<span class="fc" id="L420">        final GordianKeySpec mySpec = pKey.getKeyType();</span>
<span class="fc" id="L421">        final AlgorithmIdentifier myAlgId = theFactory.getIdentifierForSpec(mySpec);</span>

        /* Determine wrapped key length */
<span class="fc" id="L424">        final int myDataLen = getDataWrapLength(mySpec.getKeyLength().getByteLength());</span>

        /* return the calculated length */
<span class="fc" id="L427">        return GordianWrappedKeyASN1.getEncodedLength(myAlgId, myDataLen);</span>
    }

    @Override
    public int getDataWrapLength(final int pDataLength) {
<span class="fc" id="L432">        final GordianLength myBlockLen = getKeySpec().getBlockLength();</span>
<span class="fc" id="L433">        return getKeyWrapLength(pDataLength, myBlockLen)</span>
<span class="fc" id="L434">                + getKeyWrapExpansion(myBlockLen);</span>
    }

    @Override
    public int getPrivateKeyWrapLength(final GordianKeyPair pKeyPair) throws GordianException {
        /* Determine and check the keySpec */
<span class="nc" id="L440">        final GordianKeyPairFactory myFactory = theFactory.getAsyncFactory().getKeyPairFactory();</span>
<span class="nc" id="L441">        final GordianCoreKeyPairGenerator myGenerator = (GordianCoreKeyPairGenerator) myFactory.getKeyPairGenerator(pKeyPair.getKeyPairSpec());</span>
<span class="nc" id="L442">        final PKCS8EncodedKeySpec myPrivateKey = myGenerator.getPKCS8Encoding(pKeyPair);</span>
<span class="nc" id="L443">        return getDataWrapLength(myPrivateKey.getEncoded().length);</span>
    }

    /**
     * Obtain initial wrapLength for a particular dataLength and BlockSize.
     * @param pDataLength the data length
     * @param pBlockLen the number of bits in the blockLen
     * @return the keyWrap expansion
     */
    public static int getKeyWrapLength(final int pDataLength,
                                       final GordianLength pBlockLen) {
<span class="fc" id="L454">        final int myBlockLen = pBlockLen.getByteLength() &gt;&gt; 1;</span>
<span class="fc" id="L455">        final int myNumBlocks = (pDataLength + myBlockLen - 1) / myBlockLen;</span>
<span class="fc" id="L456">        return myNumBlocks * myBlockLen;</span>
    }

    /**
     * Obtain keyWrapExpansion for a blockLen.
     * @param pBlockLen the number of bits in the blockLen
     * @return the keyWrap expansion
     */
    public static int getKeyWrapExpansion(final GordianLength pBlockLen) {
<span class="fc" id="L465">        final int myBlockLen = pBlockLen.getByteLength() &gt;&gt; 1;</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">        final int myNumBlocks = 1 + (myBlockLen &lt;= Integer.BYTES</span>
<span class="fc" id="L467">                                      ? 2</span>
<span class="fc" id="L468">                                      : 1);</span>
<span class="fc" id="L469">        return myNumBlocks * myBlockLen;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
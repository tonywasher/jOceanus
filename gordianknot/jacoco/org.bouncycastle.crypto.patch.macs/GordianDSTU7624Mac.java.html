<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianDSTU7624Mac.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">org.bouncycastle.crypto.patch.macs</a> &gt; <span class="el_source">GordianDSTU7624Mac.java</span></div><h1>GordianDSTU7624Mac.java</h1><pre class="source lang-java linenums">package org.bouncycastle.crypto.patch.macs;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.Mac;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.engines.DSTU7624Engine;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.util.Arrays;

/**
 * Implementation of DSTU7624 MAC mode
 */
public class GordianDSTU7624Mac
        implements Mac {
    private final static int BITS_IN_BYTE = 8;

    private byte[] buf;
    private int bufOff;

    private int macSize;
    private int blockSize;
    private DSTU7624Engine engine;

    private byte[] c, cTemp, kDelta;

    public GordianDSTU7624Mac(int blockBitLength,
<span class="fc" id="L28">                              int q) {</span>
<span class="fc" id="L29">        this.engine = new DSTU7624Engine(blockBitLength);</span>
<span class="fc" id="L30">        this.blockSize = blockBitLength / BITS_IN_BYTE;</span>
<span class="fc" id="L31">        this.macSize = q / BITS_IN_BYTE;</span>
<span class="fc" id="L32">        this.c = new byte[blockSize];</span>
<span class="fc" id="L33">        this.kDelta = new byte[blockSize];</span>
<span class="fc" id="L34">        this.cTemp = new byte[blockSize];</span>
<span class="fc" id="L35">        this.buf = new byte[blockSize];</span>
<span class="fc" id="L36">    }</span>

    public void init(CipherParameters params)
            throws IllegalArgumentException {
<span class="pc bpc" id="L40" title="1 of 2 branches missed.">        if (params instanceof KeyParameter) {</span>
<span class="fc" id="L41">            engine.init(true, params);</span>
<span class="fc" id="L42">            reset();</span>
        } else {
<span class="nc" id="L44">            throw new IllegalArgumentException(&quot;Invalid parameter passed to DSTU7624Mac&quot;);</span>
        }
<span class="fc" id="L46">    }</span>

    public String getAlgorithmName() {
<span class="nc" id="L49">        return &quot;DSTU7624Mac&quot;;</span>
    }

    public int getMacSize() {
<span class="fc" id="L53">        return macSize;</span>
    }

    public void update(byte in) {
<span class="nc bnc" id="L57" title="All 2 branches missed.">        if (bufOff == buf.length) {</span>
<span class="nc" id="L58">            processBlock(buf, 0);</span>
<span class="nc" id="L59">            bufOff = 0;</span>
        }

<span class="nc" id="L62">        buf[bufOff++] = in;</span>
<span class="nc" id="L63">    }</span>

    public void update(byte[] in, int inOff, int len) {
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        if (len &lt; 0) {</span>
<span class="nc" id="L67">            throw new IllegalArgumentException(</span>
                    &quot;can't have a negative input length!&quot;);
        }

<span class="fc" id="L71">        int blockSize = engine.getBlockSize();</span>
<span class="fc" id="L72">        int gapLen = blockSize - bufOff;</span>

<span class="fc bfc" id="L74" title="All 2 branches covered.">        if (len &gt; gapLen) {</span>
<span class="fc" id="L75">            System.arraycopy(in, inOff, buf, bufOff, gapLen);</span>

<span class="fc" id="L77">            processBlock(buf, 0);</span>

<span class="fc" id="L79">            bufOff = 0;</span>
<span class="fc" id="L80">            len -= gapLen;</span>
<span class="fc" id="L81">            inOff += gapLen;</span>

<span class="fc bfc" id="L83" title="All 2 branches covered.">            while (len &gt; blockSize) {</span>
<span class="fc" id="L84">                processBlock(in, inOff);</span>

<span class="fc" id="L86">                len -= blockSize;</span>
<span class="fc" id="L87">                inOff += blockSize;</span>
            }
        }

<span class="fc" id="L91">        System.arraycopy(in, inOff, buf, bufOff, len);</span>

<span class="fc" id="L93">        bufOff += len;</span>
<span class="fc" id="L94">    }</span>

    private void processBlock(byte[] in, int inOff) {
<span class="fc" id="L97">        xor(c, 0, in, inOff, cTemp);</span>

<span class="fc" id="L99">        engine.processBlock(cTemp, 0, c, 0);</span>
<span class="fc" id="L100">    }</span>

    public int doFinal(byte[] out, int outOff)
            throws DataLengthException, IllegalStateException {
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">        if (bufOff % buf.length != 0) {</span>
            /* Pad using Poly1305 style padding */
<span class="fc" id="L106">            buf[bufOff] = 1;</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            for (int i = bufOff + 1; i &lt; buf.length; i++) {</span>
<span class="fc" id="L108">                buf[i] = 0;</span>
            }
        }

        // Last block
<span class="fc" id="L113">        xor(c, 0, buf, 0, cTemp);</span>
<span class="fc" id="L114">        xor(cTemp, 0, kDelta, 0, c);</span>
<span class="fc" id="L115">        engine.processBlock(c, 0, c, 0);</span>

<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (macSize + outOff &gt; out.length) {</span>
<span class="nc" id="L118">            throw new OutputLengthException(&quot;output buffer too short&quot;);</span>
        }

<span class="fc" id="L121">        System.arraycopy(c, 0, out, outOff, macSize);</span>
<span class="fc" id="L122">        reset();</span>

<span class="fc" id="L124">        return macSize;</span>
    }

    public void reset() {
<span class="fc" id="L128">        Arrays.fill(c, (byte) 0x00);</span>
<span class="fc" id="L129">        Arrays.fill(cTemp, (byte) 0x00);</span>
<span class="fc" id="L130">        Arrays.fill(kDelta, (byte) 0x00);</span>
<span class="fc" id="L131">        Arrays.fill(buf, (byte) 0x00);</span>
<span class="fc" id="L132">        engine.reset();</span>
<span class="fc" id="L133">        engine.processBlock(kDelta, 0, kDelta, 0);</span>
<span class="fc" id="L134">        bufOff = 0;</span>
<span class="fc" id="L135">    }</span>

    private void xor(byte[] x, int xOff, byte[] y, int yOff, byte[] x_xor_y) {

<span class="pc bpc" id="L139" title="3 of 6 branches missed.">        if (x.length - xOff &lt; blockSize || y.length - yOff &lt; blockSize || x_xor_y.length &lt; blockSize) {</span>
<span class="nc" id="L140">            throw new IllegalArgumentException(&quot;some of input buffers too short&quot;);</span>
        }
<span class="fc bfc" id="L142" title="All 2 branches covered.">        for (int byteIndex = 0; byteIndex &lt; blockSize; byteIndex++) {</span>
<span class="fc" id="L143">            x_xor_y[byteIndex] = (byte) (x[byteIndex + xOff] ^ y[byteIndex + yOff]);</span>
        }
<span class="fc" id="L145">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JcaSignature.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">io.github.tonywasher.joceanus.gordianknot.impl.jca</a> &gt; <span class="el_source">JcaSignature.java</span></div><h1>JcaSignature.java</h1><pre class="source lang-java linenums">/*
 * GordianKnot: Security Suite
 * Copyright 2012-2026. Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.github.tonywasher.joceanus.gordianknot.impl.jca;

import io.github.tonywasher.joceanus.gordianknot.api.base.GordianException;
import io.github.tonywasher.joceanus.gordianknot.api.base.GordianLength;
import io.github.tonywasher.joceanus.gordianknot.api.digest.GordianDigestSpec;
import io.github.tonywasher.joceanus.gordianknot.api.digest.GordianDigestType;
import io.github.tonywasher.joceanus.gordianknot.api.keypair.GordianEdwardsElliptic;
import io.github.tonywasher.joceanus.gordianknot.api.keypair.GordianKeyPair;
import io.github.tonywasher.joceanus.gordianknot.api.keypair.GordianKeyPairType;
import io.github.tonywasher.joceanus.gordianknot.api.keypair.GordianXMSSKeySpec;
import io.github.tonywasher.joceanus.gordianknot.api.sign.GordianSignParams;
import io.github.tonywasher.joceanus.gordianknot.api.sign.GordianSignatureSpec;
import io.github.tonywasher.joceanus.gordianknot.api.sign.GordianSignatureType;
import io.github.tonywasher.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import io.github.tonywasher.joceanus.gordianknot.impl.core.exc.GordianCryptoException;
import io.github.tonywasher.joceanus.gordianknot.impl.core.sign.GordianCoreSignature;
import org.bouncycastle.jcajce.spec.ContextParameterSpec;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.Signature;
import java.security.SignatureException;

/**
 * Jca implementation of signature.
 */
public abstract class JcaSignature
        extends GordianCoreSignature {
    /**
     * The Signature error.
     */
    private static final String SIG_ERROR = &quot;Signature error&quot;;

    /**
     * The RSA PSS MGF1 Algorithm.
     */
    private static final String RSA_PSSMGF1_ALGOBASE = &quot;withRSAandMGF1&quot;;

    /**
     * The RSA PSS SHAKE128 Algorithm.
     */
    private static final String RSA_PSS128_ALGOBASE = &quot;withRSAandSHAKE128&quot;;

    /**
     * The RSA PSS SHAKE256 Algorithm.
     */
    private static final String RSA_PSS256_ALGOBASE = &quot;withRSAandSHAKE256&quot;;

    /**
     * The RSA PSS PureSHAKE Algorithm.
     */
    private static final String RSA_PSSSHAKE_ALGOBASE = &quot;withRSA/PSS&quot;;

    /**
     * The RSA X9.31 Algorithm.
     */
    private static final String RSA_X931_ALGOBASE = &quot;withRSA/X9.31&quot;;

    /**
     * The RSA ISO9796d2 Algorithm.
     */
    private static final String RSA_ISO9796D2_ALGOBASE = &quot;withRSA/ISO9796-2&quot;;

    /**
     * The RSA preHash Algorithm.
     */
    private static final String RSA_PREHASH_ALGOBASE = &quot;withRSAEncryption&quot;;

    /**
     * The ECDSA Signature.
     */
    private static final String EC_DSA_ALGOBASE = &quot;withECDSA&quot;;

    /**
     * The ECDDSA Signature.
     */
    private static final String EC_DDSA_ALGOBASE = &quot;withECDDSA&quot;;

    /**
     * The DSA Signature.
     */
    private static final String DSA_ALGOBASE = &quot;withDSA&quot;;

    /**
     * The DDSA Signature.
     */
    private static final String DDSA_ALGOBASE = &quot;withDDSA&quot;;

    /**
     * The ECNR Signature.
     */
    private static final String EC_NR_ALGOBASE = &quot;withECNR&quot;;

    /**
     * The SM2 Signature.
     */
    private static final String EC_SM2_ALGOBASE = &quot;WITHSM2&quot;;

    /**
     * The DSTU Signature.
     */
    private static final String DSTU_SIGN = &quot;DSTU4145&quot;;

    /**
     * The PQC Hash prefix.
     */
    private static final String PQC_HASH_PFX = &quot;HASH-&quot;;

    /**
     * The RSA Signer.
     */
    private Signature theSigner;

    /**
     * Constructor.
     *
     * @param pFactory the factory
     * @param pSpec    the signature Spec
     */
    JcaSignature(final GordianBaseFactory pFactory,
                 final GordianSignatureSpec pSpec) {
<span class="fc" id="L139">        super(pFactory, pSpec);</span>
<span class="fc" id="L140">    }</span>

    /**
     * Set the signer.
     *
     * @param pSigner the signer.
     */
    protected void setSigner(final Signature pSigner) {
<span class="fc" id="L148">        theSigner = pSigner;</span>
<span class="fc" id="L149">    }</span>

    /**
     * Obtain the signer.
     *
     * @return the signer.
     */
    protected Signature getSigner() {
<span class="fc" id="L157">        return theSigner;</span>
    }

    @Override
    public void initForSigning(final GordianSignParams pParams) throws GordianException {
        /* Initialise detail */
<span class="fc" id="L163">        super.initForSigning(pParams);</span>
<span class="fc" id="L164">        final JcaKeyPair myPair = getKeyPair();</span>
<span class="fc" id="L165">        final byte[] myContext = getContext();</span>
<span class="fc" id="L166">        JcaKeyPair.checkKeyPair(myPair);</span>

        /* Initialise for signing */
        try {
            /* Determine whether we should use random for signatures */
<span class="fc" id="L171">            final boolean useRandom = getSignatureSpec().getKeyPairType().useRandomForSignatures();</span>

            /* Initialise the signing */
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (useRandom) {</span>
<span class="fc" id="L175">                getSigner().initSign(myPair.getPrivateKey().getPrivateKey(), getRandom());</span>
            } else {
<span class="fc" id="L177">                getSigner().initSign(myPair.getPrivateKey().getPrivateKey());</span>
            }

            /* If we support context */
<span class="fc bfc" id="L181" title="All 2 branches covered.">            if (getSignatureSpec().supportsContext()) {</span>
                /* Declare the context to the signer */
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">                final ContextParameterSpec mySpec = myContext == null ? null : new ContextParameterSpec(myContext);</span>
<span class="fc" id="L184">                getSigner().setParameter(mySpec);</span>
            }

            /* Catch exceptions */
<span class="nc" id="L188">        } catch (InvalidKeyException</span>
                 | InvalidAlgorithmParameterException e) {
<span class="nc" id="L190">            throw new GordianCryptoException(SIG_ERROR, e);</span>
<span class="fc" id="L191">        }</span>
<span class="fc" id="L192">    }</span>

    @Override
    public void initForVerify(final GordianSignParams pParams) throws GordianException {
        /* Initialise detail */
<span class="fc" id="L197">        super.initForVerify(pParams);</span>
<span class="fc" id="L198">        final JcaKeyPair myPair = getKeyPair();</span>
<span class="fc" id="L199">        final byte[] myContext = getContext();</span>
<span class="fc" id="L200">        JcaKeyPair.checkKeyPair(myPair);</span>

        /* Initialise for signing */
        try {
            /* Initialise for verification */
<span class="fc" id="L205">            getSigner().initVerify(myPair.getPublicKey().getPublicKey());</span>

            /* If we support context */
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (getSignatureSpec().supportsContext()) {</span>
                /* Declare the context to the signer */
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">                final ContextParameterSpec mySpec = myContext == null ? null : new ContextParameterSpec(myContext);</span>
<span class="fc" id="L211">                getSigner().setParameter(mySpec);</span>
            }

            /* Catch exceptions */
<span class="nc" id="L215">        } catch (InvalidKeyException</span>
                 | InvalidAlgorithmParameterException e) {
<span class="nc" id="L217">            throw new GordianCryptoException(SIG_ERROR, e);</span>
<span class="fc" id="L218">        }</span>
<span class="fc" id="L219">    }</span>

    @Override
    public void update(final byte[] pBytes,
                       final int pOffset,
                       final int pLength) {
        try {
<span class="fc" id="L226">            theSigner.update(pBytes, pOffset, pLength);</span>
<span class="nc" id="L227">        } catch (SignatureException e) {</span>
<span class="nc" id="L228">            throw new IllegalArgumentException(e);</span>
<span class="fc" id="L229">        }</span>
<span class="fc" id="L230">    }</span>

    @Override
    public void update(final byte pByte) {
        try {
<span class="fc" id="L235">            theSigner.update(pByte);</span>
<span class="nc" id="L236">        } catch (SignatureException e) {</span>
<span class="nc" id="L237">            throw new IllegalArgumentException(e);</span>
<span class="fc" id="L238">        }</span>
<span class="fc" id="L239">    }</span>

    @Override
    public byte[] sign() throws GordianException {
        /* Check that we are in signing mode */
<span class="fc" id="L244">        checkMode(GordianSignatureMode.SIGN);</span>

        /* Protect against exception */
        try {
<span class="fc" id="L248">            return getSigner().sign();</span>

<span class="nc" id="L250">        } catch (SignatureException e) {</span>
<span class="nc" id="L251">            throw new GordianCryptoException(SIG_ERROR, e);</span>
        }
    }

    @Override
    public boolean verify(final byte[] pSignature) throws GordianException {
        /* Check that we are in verify mode */
<span class="fc" id="L258">        checkMode(GordianSignatureMode.VERIFY);</span>

        /* Protect against exception */
        try {
<span class="fc" id="L262">            return getSigner().verify(pSignature);</span>
<span class="nc" id="L263">        } catch (SignatureException e) {</span>
<span class="nc" id="L264">            throw new GordianCryptoException(SIG_ERROR, e);</span>
        }
    }

    @Override
    public void reset() {
        /* NoOp */
<span class="nc" id="L271">    }</span>

    @Override
    protected JcaKeyPair getKeyPair() {
<span class="fc" id="L275">        return (JcaKeyPair) super.getKeyPair();</span>
    }

    /**
     * RSA signature.
     */
    static class JcaRSASignature
            extends JcaSignature {
        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         * @throws GordianException on error
         */
        JcaRSASignature(final GordianBaseFactory pFactory,
                        final GordianSignatureSpec pSignatureSpec) throws GordianException {
            /* Initialise class */
<span class="fc" id="L293">            super(pFactory, pSignatureSpec);</span>

            /* Create the signature class */
<span class="fc" id="L296">            final String myDigest = JcaDigest.getSignAlgorithm(pSignatureSpec.getDigestSpec());</span>
<span class="fc" id="L297">            setSigner(getJavaSignature(myDigest + getSignatureBase(pSignatureSpec), false));</span>
<span class="fc" id="L298">        }</span>
    }

    /**
     * Obtain Signer base.
     *
     * @param pSignatureSpec the signatureSpec
     * @return the base
     */
    static String getSignatureBase(final GordianSignatureSpec pSignatureSpec) {
        /* Handle SM2 explicitly */
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if (GordianKeyPairType.SM2.equals(pSignatureSpec.getKeyPairType())) {</span>
<span class="fc" id="L310">            return EC_SM2_ALGOBASE;</span>
        }

        /* Note if we are DSA */
<span class="fc" id="L314">        final boolean isDSA = GordianKeyPairType.DSA.equals(pSignatureSpec.getKeyPairType());</span>
<span class="fc" id="L315">        final boolean isSHAKE = GordianDigestType.SHAKE.equals(pSignatureSpec.getDigestSpec().getDigestType());</span>

        /* Switch on signature type */
<span class="pc bpc" id="L318" title="1 of 10 branches missed.">        switch (pSignatureSpec.getSignatureType()) {</span>
            case PSSMGF1:
<span class="fc" id="L320">                return RSA_PSSMGF1_ALGOBASE;</span>
            case PSS128:
<span class="fc bfc" id="L322" title="All 2 branches covered.">                return isSHAKE ? RSA_PSSSHAKE_ALGOBASE : RSA_PSS128_ALGOBASE;</span>
            case PSS256:
<span class="fc bfc" id="L324" title="All 2 branches covered.">                return isSHAKE ? RSA_PSSSHAKE_ALGOBASE : RSA_PSS256_ALGOBASE;</span>
            case X931:
<span class="fc" id="L326">                return RSA_X931_ALGOBASE;</span>
            case ISO9796D2:
<span class="fc" id="L328">                return RSA_ISO9796D2_ALGOBASE;</span>
            case PREHASH:
<span class="fc" id="L330">                return RSA_PREHASH_ALGOBASE;</span>
            case DSA:
<span class="fc bfc" id="L332" title="All 2 branches covered.">                return isDSA</span>
<span class="fc" id="L333">                        ? DSA_ALGOBASE</span>
<span class="fc" id="L334">                        : EC_DSA_ALGOBASE;</span>
            case DDSA:
<span class="fc bfc" id="L336" title="All 2 branches covered.">                return isDSA</span>
<span class="fc" id="L337">                        ? DDSA_ALGOBASE</span>
<span class="fc" id="L338">                        : EC_DDSA_ALGOBASE;</span>
            case NR:
<span class="fc" id="L340">                return EC_NR_ALGOBASE;</span>
            default:
<span class="nc" id="L342">                return null;</span>
        }
    }

    /**
     * DSA signer.
     */
    static class JcaDSASignature
            extends JcaSignature {
        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         * @throws GordianException on error
         */
        JcaDSASignature(final GordianBaseFactory pFactory,
                        final GordianSignatureSpec pSignatureSpec) throws GordianException {
            /* Initialise class */
<span class="fc" id="L361">            super(pFactory, pSignatureSpec);</span>

            /* Create the signature class */
<span class="fc" id="L364">            final String myDigest = JcaDigest.getSignAlgorithm(pSignatureSpec.getDigestSpec());</span>
<span class="fc" id="L365">            setSigner(getJavaSignature(myDigest + getSignatureBase(pSignatureSpec), false));</span>
<span class="fc" id="L366">        }</span>
    }

    /**
     * GOST signature.
     */
    static class JcaGOSTSignature
            extends JcaSignature {
        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         * @throws GordianException on error
         */
        JcaGOSTSignature(final GordianBaseFactory pFactory,
                         final GordianSignatureSpec pSignatureSpec) throws GordianException {
            /* Initialise class */
<span class="fc" id="L384">            super(pFactory, pSignatureSpec);</span>

            /* Create the signature class */
<span class="fc" id="L387">            setSigner(getJavaSignature(getSignature(pSignatureSpec), false));</span>
<span class="fc" id="L388">        }</span>

        /**
         * Obtain Signer base.
         *
         * @param pSignatureSpec the signatureSpec
         * @return the base
         */
        private static String getSignature(final GordianSignatureSpec pSignatureSpec) {
            /* Handle DSTU explicitly */
<span class="fc bfc" id="L398" title="All 2 branches covered.">            if (GordianKeyPairType.DSTU4145.equals(pSignatureSpec.getKeyPairType())) {</span>
<span class="fc" id="L399">                return DSTU_SIGN;</span>
            }

            /* Obtain the digest length */
<span class="fc" id="L403">            final GordianLength myLength = pSignatureSpec.getDigestSpec().getDigestLength();</span>

            /* Build the algorithm */
<span class="fc" id="L406">            return &quot;GOST3411-2012-&quot;</span>
<span class="fc" id="L407">                    + myLength.getLength()</span>
                    + &quot;withECGOST3410-2012-&quot;
<span class="fc" id="L409">                    + myLength.getLength();</span>
        }
    }

    /**
     * SLHDSA signature.
     */
    static class JcaSLHDSASignature
            extends JcaSignature {
        /**
         * Base name.
         */
        private static final String BASE_NAME = &quot;SLH-DSA&quot;;

        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         */
        JcaSLHDSASignature(final GordianBaseFactory pFactory,
                           final GordianSignatureSpec pSignatureSpec) {
            /* Initialise class */
<span class="fc" id="L432">            super(pFactory, pSignatureSpec);</span>
<span class="fc" id="L433">        }</span>

        @Override
        public void initForSigning(final GordianSignParams pParams) throws GordianException {
            /* Determine the required signer */
<span class="fc" id="L438">            final GordianKeyPair myPair = pParams.getKeyPair();</span>
<span class="fc" id="L439">            JcaKeyPair.checkKeyPair(myPair);</span>
<span class="fc" id="L440">            final String mySignName = getAlgorithmForKeyPair(myPair);</span>
<span class="fc" id="L441">            setSigner(getJavaSignature(mySignName, false));</span>

            /* pass on call */
<span class="fc" id="L444">            super.initForSigning(pParams);</span>
<span class="fc" id="L445">        }</span>

        @Override
        public void initForVerify(final GordianSignParams pParams) throws GordianException {
            /* Determine the required signer */
<span class="fc" id="L450">            final GordianKeyPair myPair = pParams.getKeyPair();</span>
<span class="fc" id="L451">            JcaKeyPair.checkKeyPair(myPair);</span>
<span class="fc" id="L452">            final String mySignName = getAlgorithmForKeyPair(myPair);</span>
<span class="fc" id="L453">            setSigner(getJavaSignature(mySignName, false));</span>

            /* pass on call */
<span class="fc" id="L456">            super.initForVerify(pParams);</span>
<span class="fc" id="L457">        }</span>

        /**
         * Obtain algorithmName for keyPair.
         *
         * @param pKeyPair the keyPair
         * @return the name
         */
        private static String getAlgorithmForKeyPair(final GordianKeyPair pKeyPair) {
            /* Build the algorithm */
<span class="fc" id="L467">            final boolean isHash = pKeyPair.getKeyPairSpec().getSLHDSAKeySpec().isHash();</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">            return isHash ? PQC_HASH_PFX + BASE_NAME : BASE_NAME;</span>
        }
    }

    /**
     * MLDSA signature.
     */
    static class JcaMLDSASignature
            extends JcaSignature {
        /**
         * Base name.
         */
        private static final String BASE_NAME = &quot;ML-DSA&quot;;

        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         */
        JcaMLDSASignature(final GordianBaseFactory pFactory,
                          final GordianSignatureSpec pSignatureSpec) {
            /* Initialise class */
<span class="fc" id="L491">            super(pFactory, pSignatureSpec);</span>
<span class="fc" id="L492">        }</span>

        @Override
        public void initForSigning(final GordianSignParams pParams) throws GordianException {
            /* Determine the required signer */
<span class="fc" id="L497">            final GordianKeyPair myPair = pParams.getKeyPair();</span>
<span class="fc" id="L498">            JcaKeyPair.checkKeyPair(myPair);</span>
<span class="fc" id="L499">            final String mySignName = getAlgorithmForKeyPair(myPair);</span>
<span class="fc" id="L500">            setSigner(getJavaSignature(mySignName, false));</span>

            /* pass on call */
<span class="fc" id="L503">            super.initForSigning(pParams);</span>
<span class="fc" id="L504">        }</span>

        @Override
        public void initForVerify(final GordianSignParams pParams) throws GordianException {
            /* Determine the required signer */
<span class="fc" id="L509">            final GordianKeyPair myPair = pParams.getKeyPair();</span>
<span class="fc" id="L510">            JcaKeyPair.checkKeyPair(myPair);</span>
<span class="fc" id="L511">            final String mySignName = getAlgorithmForKeyPair(myPair);</span>
<span class="fc" id="L512">            setSigner(getJavaSignature(mySignName, false));</span>

            /* pass on call */
<span class="fc" id="L515">            super.initForVerify(pParams);</span>
<span class="fc" id="L516">        }</span>

        /**
         * Obtain algorithmName for keyPair.
         *
         * @param pKeyPair the keyPair
         * @return the name
         */
        private static String getAlgorithmForKeyPair(final GordianKeyPair pKeyPair) {
            /* Build the algorithm */
<span class="fc" id="L526">            final boolean isHash = pKeyPair.getKeyPairSpec().getMLDSAKeySpec().isHash();</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">            return isHash ? PQC_HASH_PFX + BASE_NAME : BASE_NAME;</span>
        }
    }

    /**
     * Falcon signature.
     */
    static class JcaFalconSignature
            extends JcaSignature {
        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         * @throws GordianException on error
         */
        JcaFalconSignature(final GordianBaseFactory pFactory,
                           final GordianSignatureSpec pSignatureSpec) throws GordianException {
            /* Initialise class */
<span class="fc" id="L546">            super(pFactory, pSignatureSpec);</span>

            /* Create the signature class */
<span class="fc" id="L549">            setSigner(getJavaSignature(&quot;FALCON&quot;, true));</span>
<span class="fc" id="L550">        }</span>
    }

    /**
     * Mayo signature.
     */
    static class JcaMayoSignature
            extends JcaSignature {
        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         * @throws GordianException on error
         */
        JcaMayoSignature(final GordianBaseFactory pFactory,
                         final GordianSignatureSpec pSignatureSpec) throws GordianException {
            /* Initialise class */
<span class="fc" id="L568">            super(pFactory, pSignatureSpec);</span>

            /* Create the signature class */
<span class="fc" id="L571">            setSigner(getJavaSignature(&quot;MAYO&quot;, true));</span>
<span class="fc" id="L572">        }</span>
    }

    /**
     * Snova signature.
     */
    static class JcaSnovaSignature
            extends JcaSignature {
        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         * @throws GordianException on error
         */
        JcaSnovaSignature(final GordianBaseFactory pFactory,
                          final GordianSignatureSpec pSignatureSpec) throws GordianException {
            /* Initialise class */
<span class="fc" id="L590">            super(pFactory, pSignatureSpec);</span>

            /* Create the signature class */
<span class="fc" id="L593">            setSigner(getJavaSignature(&quot;SNOVA&quot;, true));</span>
<span class="fc" id="L594">        }</span>
    }

    /**
     * Picnic signature.
     */
    static class JcaPicnicSignature
            extends JcaSignature {
        /**
         * SIgnature base.
         */
        private static final String BASE_NAME = &quot;PICNIC&quot;;

        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         * @throws GordianException on error
         */
        JcaPicnicSignature(final GordianBaseFactory pFactory,
                           final GordianSignatureSpec pSignatureSpec) throws GordianException {
            /* Initialise class */
<span class="fc" id="L617">            super(pFactory, pSignatureSpec);</span>

            /* Create the signature class */
<span class="fc" id="L620">            final String myName = determineSignatureName(pSignatureSpec);</span>
<span class="fc" id="L621">            setSigner(getJavaSignature(myName, true));</span>
<span class="fc" id="L622">        }</span>

        /**
         * Determine signatureName.
         *
         * @param pSignatureSpec the signatureSpec
         * @return the algorithm name
         */
        private static String determineSignatureName(final GordianSignatureSpec pSignatureSpec) {
            /* If we do not have a digest */
<span class="fc bfc" id="L632" title="All 2 branches covered.">            if (pSignatureSpec.getSignatureSpec() == null) {</span>
<span class="fc" id="L633">                return BASE_NAME;</span>
            }

            /* Switch on digest Type */
<span class="pc bpc" id="L637" title="1 of 4 branches missed.">            switch (pSignatureSpec.getDigestSpec().getDigestType()) {</span>
                case SHA2:
<span class="fc" id="L639">                    return &quot;SHA512With&quot; + BASE_NAME;</span>
                case SHA3:
<span class="fc" id="L641">                    return &quot;SHA3-512With&quot; + BASE_NAME;</span>
                case SHAKE:
<span class="fc" id="L643">                    return &quot;SHAKE256With&quot; + BASE_NAME;</span>
                default:
<span class="nc" id="L645">                    throw new IllegalArgumentException(&quot;Bad SignatureSpec&quot;);</span>
            }
        }

    }

    /**
     * XMSS signature.
     */
    static class JcaXMSSSignature
            extends JcaSignature {
        /**
         * Is this a preHash signature?
         */
        private final boolean preHash;

        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         */
        JcaXMSSSignature(final GordianBaseFactory pFactory,
                         final GordianSignatureSpec pSignatureSpec) {
            /* Initialise class */
<span class="fc" id="L670">            super(pFactory, pSignatureSpec);</span>

            /* Determine preHash */
<span class="fc" id="L673">            preHash = GordianSignatureType.PREHASH.equals(pSignatureSpec.getSignatureType());</span>
<span class="fc" id="L674">        }</span>

        @Override
        public void initForSigning(final GordianSignParams pParams) throws GordianException {
            /* Determine the required signer */
<span class="fc" id="L679">            final GordianKeyPair myPair = pParams.getKeyPair();</span>
<span class="fc" id="L680">            JcaKeyPair.checkKeyPair(myPair);</span>
<span class="fc" id="L681">            final String mySignName = getAlgorithmForKeyPair(myPair);</span>
<span class="fc" id="L682">            setSigner(getJavaSignature(mySignName, true));</span>

            /* pass on call */
<span class="fc" id="L685">            super.initForSigning(pParams);</span>
<span class="fc" id="L686">        }</span>

        @Override
        public void initForVerify(final GordianSignParams pParams) throws GordianException {
            /* Determine the required signer */
<span class="fc" id="L691">            final GordianKeyPair myPair = pParams.getKeyPair();</span>
<span class="fc" id="L692">            JcaKeyPair.checkKeyPair(myPair);</span>
<span class="fc" id="L693">            final String mySignName = getAlgorithmForKeyPair(myPair);</span>
<span class="fc" id="L694">            setSigner(getJavaSignature(mySignName, true));</span>

            /* pass on call */
<span class="fc" id="L697">            super.initForVerify(pParams);</span>
<span class="fc" id="L698">        }</span>

        /**
         * Obtain algorithmName for keyPair.
         *
         * @param pKeyPair the keyPair
         * @return the name
         * @throws GordianException on error
         */
        private String getAlgorithmForKeyPair(final GordianKeyPair pKeyPair) throws GordianException {
            /* Determine the required signer */
<span class="fc" id="L709">            final GordianXMSSKeySpec myXMSSKeySpec = pKeyPair.getKeyPairSpec().getXMSSKeySpec();</span>
<span class="fc" id="L710">            final GordianDigestSpec myDigestSpec = myXMSSKeySpec.getDigestType().getDigestSpec();</span>
<span class="fc" id="L711">            final String myDigest = JcaDigest.getAlgorithm(myDigestSpec);</span>

            /* Create builder */
<span class="fc" id="L714">            final StringBuilder myBuilder = new StringBuilder();</span>
<span class="fc" id="L715">            myBuilder.append(myXMSSKeySpec.getKeyType().name())</span>
<span class="fc" id="L716">                    .append('-')</span>
<span class="fc" id="L717">                    .append(myDigest);</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">            if (preHash) {</span>
<span class="fc" id="L719">                myBuilder.insert(0, &quot;with&quot;)</span>
<span class="fc" id="L720">                        .insert(0, myDigest);</span>
            }

            /* Build the algorithm */
<span class="fc" id="L724">            return myBuilder.toString();</span>
        }
    }

    /**
     * EdDSA signature.
     */
    static class JcaEdDSASignature
            extends JcaSignature {
        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         */
        JcaEdDSASignature(final GordianBaseFactory pFactory,
                          final GordianSignatureSpec pSignatureSpec) {
            /* Initialise class */
<span class="fc" id="L742">            super(pFactory, pSignatureSpec);</span>
<span class="fc" id="L743">        }</span>

        @Override
        public void initForSigning(final GordianSignParams pParams) throws GordianException {
            /* Determine the required signer */
<span class="fc" id="L748">            final GordianKeyPair myPair = pParams.getKeyPair();</span>
<span class="fc" id="L749">            JcaKeyPair.checkKeyPair(myPair);</span>
<span class="fc" id="L750">            final String mySignName = getAlgorithmForKeyPair(myPair);</span>
<span class="fc" id="L751">            setSigner(getJavaSignature(mySignName, false));</span>

            /* pass on call */
<span class="fc" id="L754">            super.initForSigning(pParams);</span>
<span class="fc" id="L755">        }</span>

        @Override
        public void initForVerify(final GordianSignParams pParams) throws GordianException {
            /* Determine the required signer */
<span class="fc" id="L760">            final GordianKeyPair myPair = pParams.getKeyPair();</span>
<span class="fc" id="L761">            JcaKeyPair.checkKeyPair(myPair);</span>
<span class="fc" id="L762">            final String mySignName = getAlgorithmForKeyPair(myPair);</span>
<span class="fc" id="L763">            setSigner(getJavaSignature(mySignName, false));</span>

            /* pass on call */
<span class="fc" id="L766">            super.initForVerify(pParams);</span>
<span class="fc" id="L767">        }</span>

        /**
         * Obtain algorithmName for keyPair.
         *
         * @param pKeyPair the keyPair
         * @return the name
         */
        private static String getAlgorithmForKeyPair(final GordianKeyPair pKeyPair) {
            /* Determine the required signer */
<span class="fc" id="L777">            final GordianEdwardsElliptic myEdwards = pKeyPair.getKeyPairSpec().getEdwardsElliptic();</span>
<span class="fc" id="L778">            final boolean is25519 = myEdwards.is25519();</span>

            /* Build the algorithm */
<span class="fc bfc" id="L781" title="All 2 branches covered.">            return is25519 ? &quot;Ed25519&quot; : &quot;Ed448&quot;;</span>
        }
    }

    /**
     * LMS signature.
     */
    static class JcaLMSSignature
            extends JcaSignature {
        /**
         * Constructor.
         *
         * @param pFactory       the factory
         * @param pSignatureSpec the signatureSpec
         * @throws GordianException on error
         */
        JcaLMSSignature(final GordianBaseFactory pFactory,
                        final GordianSignatureSpec pSignatureSpec) throws GordianException {
            /* Initialise class */
<span class="fc" id="L800">            super(pFactory, pSignatureSpec);</span>

            /* Create the signature class */
<span class="fc" id="L803">            setSigner(getJavaSignature(&quot;LMS&quot;, true));</span>
<span class="fc" id="L804">        }</span>
    }

    /**
     * Create the BouncyCastle Signature via JCA.
     *
     * @param pAlgorithm  the Algorithm
     * @param postQuantum is this a postQuantum algorithm?
     * @return the KeyPairGenerator
     * @throws GordianException on error
     */
    private static Signature getJavaSignature(final String pAlgorithm,
                                              final boolean postQuantum) throws GordianException {
        /* Protect against exceptions */
        try {
            /* Return a Signature for the algorithm */
<span class="fc bfc" id="L820" title="All 2 branches covered.">            return Signature.getInstance(pAlgorithm, postQuantum</span>
<span class="fc" id="L821">                    ? JcaProvider.BCPQPROV</span>
<span class="fc" id="L822">                    : JcaProvider.BCPROV);</span>

            /* Catch exceptions */
<span class="nc" id="L825">        } catch (NoSuchAlgorithmException e) {</span>
            /* Throw the exception */
<span class="nc" id="L827">            throw new GordianCryptoException(&quot;Failed to create Signature&quot;, e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianCRMBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.core.keystore</a> &gt; <span class="el_source">GordianCRMBuilder.java</span></div><h1>GordianCRMBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.core.keystore;

import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.base.GordianLength;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigest;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigestFactory;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigestSpec;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigestSpecBuilder;
import net.sourceforge.joceanus.gordianknot.api.factory.GordianAsyncFactory;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPair;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairFactory;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairGenerator;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairSpec;
import net.sourceforge.joceanus.gordianknot.api.keyset.GordianKeySet;
import net.sourceforge.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStorePair;
import net.sourceforge.joceanus.gordianknot.api.mac.GordianMac;
import net.sourceforge.joceanus.gordianknot.api.mac.GordianMacFactory;
import net.sourceforge.joceanus.gordianknot.api.mac.GordianMacSpec;
import net.sourceforge.joceanus.gordianknot.api.sign.GordianSignParams;
import net.sourceforge.joceanus.gordianknot.api.sign.GordianSignature;
import net.sourceforge.joceanus.gordianknot.api.sign.GordianSignatureSpec;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianASN1Util;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianRandomSource;
import net.sourceforge.joceanus.gordianknot.impl.core.cert.GordianCoreCertificate;
import net.sourceforge.joceanus.gordianknot.impl.core.digest.GordianCoreDigestFactory;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianDataException;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianIOException;
import net.sourceforge.joceanus.gordianknot.impl.core.keystore.GordianCRMEncryptor.GordianCRMResult;
import net.sourceforge.joceanus.gordianknot.impl.core.sign.GordianCoreSignatureFactory;
import org.bouncycastle.asn1.ASN1Object;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.BERSet;
import org.bouncycastle.asn1.DERBitString;
import org.bouncycastle.asn1.DERNull;
import org.bouncycastle.asn1.DERTaggedObject;
import org.bouncycastle.asn1.cmp.PBMParameter;
import org.bouncycastle.asn1.cms.EncryptedContentInfo;
import org.bouncycastle.asn1.cms.EnvelopedData;
import org.bouncycastle.asn1.crmf.AttributeTypeAndValue;
import org.bouncycastle.asn1.crmf.CertReqMsg;
import org.bouncycastle.asn1.crmf.CertRequest;
import org.bouncycastle.asn1.crmf.CertTemplateBuilder;
import org.bouncycastle.asn1.crmf.PKMACValue;
import org.bouncycastle.asn1.crmf.POPOPrivKey;
import org.bouncycastle.asn1.crmf.POPOSigningKey;
import org.bouncycastle.asn1.crmf.ProofOfPossession;
import org.bouncycastle.asn1.crmf.SubsequentMessage;
import org.bouncycastle.asn1.nist.NISTObjectIdentifiers;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.BasicConstraints;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.ExtensionsGenerator;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;

import java.io.IOException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

/**
 * CRM Builder.
 */
public class GordianCRMBuilder {
    /**
     * AttrOID branch.
     */
<span class="fc" id="L86">    public static final ASN1ObjectIdentifier ATTROID = GordianASN1Util.EXTOID.branch(&quot;4&quot;);</span>

    /**
     * AttrOID branch.
     */
<span class="fc" id="L91">    public static final ASN1ObjectIdentifier MACVALUEATTROID = ATTROID.branch(&quot;1&quot;);</span>

    /**
     * The # of hash iterations .
     */
    private static final int PBM_ITERATIONS = 10000;

    /**
     * The gateway.
     */
    private final GordianBaseKeyStoreGateway theGateway;

    /**
     * Constructor.
     * @param pGateway the gateway
     */
<span class="fc" id="L107">    GordianCRMBuilder(final GordianBaseKeyStoreGateway pGateway) {</span>
<span class="fc" id="L108">        theGateway = pGateway;</span>
<span class="fc" id="L109">    }</span>

    /**
     * Create a Certificate request.
     * @param pKeyPair the keyStore entry
     * @param pRequestId the reqId
     * @return the certificate request message
     * @throws GordianException on error
     */
    public CertReqMsg createCertificateRequest(final GordianKeyStorePair pKeyPair,
                                               final int pRequestId) throws GordianException {
        /* Access the certificate */
<span class="fc" id="L121">        final GordianCoreCertificate myCert = (GordianCoreCertificate) pKeyPair.getCertificateChain().get(0);</span>

        /* Create the Certificate request */
<span class="fc" id="L124">        final CertRequest myCertReq = createCertRequest(myCert, pRequestId);</span>

        /* Create the ProofOfPossession */
<span class="fc" id="L127">        final ProofOfPossession myProof = createKeyPairProofOfPossession(pKeyPair, myCert, myCertReq);</span>

        /* Create control if necessary */
<span class="fc" id="L130">        AttributeTypeAndValue[] myAttrs = null;</span>
<span class="fc" id="L131">        final X500Name myName = myCert.getSubjectName();</span>
<span class="fc" id="L132">        final byte[] myMACSecret = theGateway.getMACSecret(myName);</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (myMACSecret != null) {</span>
            /* Create the PKMACValue Control */
<span class="fc" id="L135">            final PKMACValue myMACValue = createPKMACValue(myMACSecret, myCertReq.getCertTemplate().getPublicKey());</span>
<span class="fc" id="L136">            myAttrs = new AttributeTypeAndValue[] { new AttributeTypeAndValue(MACVALUEATTROID, myMACValue) };</span>
        }

        /* Create a CRMF */
<span class="fc" id="L140">        return new CertReqMsg(myCertReq, myProof, myAttrs);</span>
    }

    /**
     * Create a Certificate request.
     * @param pCertificate the local certificate
     * @param pRequestId the reqId
     * @return the certificate request
     * @throws GordianException on error
     */
    private static CertRequest createCertRequest(final GordianCoreCertificate pCertificate,
                                                 final int pRequestId) throws GordianException {
        /* Protect against exceptions */
        try {
            /* Create the Certificate template Builder */
<span class="fc" id="L155">            final CertTemplateBuilder myBuilder = new CertTemplateBuilder();</span>

            /* Record certificate name */
<span class="fc" id="L158">            myBuilder.setSubject(pCertificate.getSubject().getName());</span>

            /* Record certificate publicKey */
<span class="fc" id="L161">            final X509EncodedKeySpec myX509 = pCertificate.getX509KeySpec();</span>
<span class="fc" id="L162">            final SubjectPublicKeyInfo myPublicInfo = SubjectPublicKeyInfo.getInstance(myX509.getEncoded());</span>
<span class="fc" id="L163">            myBuilder.setPublicKey(myPublicInfo);</span>

            /* record extensions */
<span class="fc" id="L166">            final ExtensionsGenerator myGenerator = new ExtensionsGenerator();</span>
<span class="fc" id="L167">            myGenerator.addExtension(Extension.keyUsage, true, pCertificate.getUsage().getKeyUsage());</span>
<span class="fc" id="L168">            myGenerator.addExtension(Extension.basicConstraints, false, new BasicConstraints(false));</span>
<span class="fc" id="L169">            myBuilder.setExtensions(myGenerator.generate());</span>

            /* Create the Certificate request */
<span class="fc" id="L172">            return new CertRequest(pRequestId, myBuilder.build(), null);</span>

<span class="nc" id="L174">        } catch (IOException e) {</span>
<span class="nc" id="L175">            throw new GordianIOException(&quot;Failed to create Certificate request&quot;, e);</span>
        }
    }

    /**
     * Create KeyPair Proof of Possession.
     * @param pKeyPair the keyStore entry
     * @param pCertificate the local certificate
     * @param pCertRequest the certificate request
     * @return the proof of possession
     * @throws GordianException on error
     */
    private ProofOfPossession createKeyPairProofOfPossession(final GordianKeyStorePair pKeyPair,
                                                             final GordianCoreCertificate pCertificate,
                                                             final CertRequest pCertRequest) throws GordianException {
        /* Try to send a signed proof */
<span class="fc" id="L191">        final GordianKeyPair myKeyPair = pKeyPair.getKeyPair();</span>
<span class="fc" id="L192">        final GordianKeyPairSpec mySpec = myKeyPair.getKeyPairSpec();</span>
<span class="fc" id="L193">        final GordianSignatureSpec mySignSpec = theGateway.getFactory().getAsyncFactory().getSignatureFactory().defaultForKeyPair(mySpec);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (mySignSpec != null) {</span>
<span class="fc" id="L195">            return createKeyPairSignedProof(myKeyPair, mySignSpec, pCertRequest);</span>
        }

        /* Send encrypted key via targeted encryption or request encrypted certificate */
<span class="fc" id="L199">        final GordianCoreCertificate myTarget = theGateway.getTarget();</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        return myTarget != null</span>
<span class="nc" id="L201">                ? createTargetedProofOfPossession(myKeyPair, pCertificate)</span>
<span class="fc" id="L202">                : new ProofOfPossession(ProofOfPossession.TYPE_KEY_ENCIPHERMENT, new POPOPrivKey(SubsequentMessage.encrCert));</span>
    }

    /**
     * Create Targeted Proof of Possession.
     * @param pKeyPair the keyPair
     * @param pCertificate the local certificate
     * @return the proof of possession
     * @throws GordianException on error
     */
    private ProofOfPossession createTargetedProofOfPossession(final GordianKeyPair pKeyPair,
                                                              final GordianCoreCertificate pCertificate) throws GordianException {
        /* Obtain the PKCS8Encoding of the private key */
<span class="nc" id="L215">        final GordianKeyPairFactory myFactory = theGateway.getFactory().getAsyncFactory().getKeyPairFactory();</span>
<span class="nc" id="L216">        final GordianKeyPairSpec mySpec = pKeyPair.getKeyPairSpec();</span>
<span class="nc" id="L217">        final GordianKeyPairGenerator myGenerator = myFactory.getKeyPairGenerator(mySpec);</span>
<span class="nc" id="L218">        final PKCS8EncodedKeySpec myPKCS8Encoding = myGenerator.getPKCS8Encoding(pKeyPair);</span>

        /* Prepare for encryption */
<span class="nc" id="L221">        final GordianCRMEncryptor myEncryptor = theGateway.getEncryptor();</span>
<span class="nc" id="L222">        final GordianCoreCertificate myTarget = theGateway.getTarget();</span>
<span class="nc" id="L223">        final GordianCRMResult myResult = myEncryptor.prepareForEncryption(myTarget);</span>

        /* Derive the keySet from the key */
<span class="nc" id="L226">        final GordianKeySet myKeySet = myResult.getKeySet();</span>

        /* Create the encrypted data */
<span class="nc" id="L229">        final EncryptedContentInfo myInfo = GordianCRMEncryptor.buildEncryptedContentInfo(myKeySet, myPKCS8Encoding, pCertificate);</span>

        /* Create the Proof of possession */
<span class="nc" id="L232">        final EnvelopedData myEnvData = new EnvelopedData(null, new BERSet(myResult.getRecipient()), myInfo, (BERSet) null);</span>
<span class="nc" id="L233">        return new ProofOfPossession(ProofOfPossession.TYPE_KEY_ENCIPHERMENT, new XPOPOPrivKey(myEnvData));</span>
    }

    /**
     * Create a Signed KeyPair Proof of Possession.
     * @param pKeyPair the keyPair
     * @param pSignSpec the signatureSpec
     * @param pCertRequest the certificate request
     * @return the proof of possession
     * @throws GordianException on error
     */
    ProofOfPossession createKeyPairSignedProof(final GordianKeyPair pKeyPair,
                                               final GordianSignatureSpec pSignSpec,
                                               final CertRequest pCertRequest) throws GordianException {
        /* Create the signer */
<span class="fc" id="L248">        final GordianAsyncFactory myFactory = theGateway.getFactory().getAsyncFactory();</span>
<span class="fc" id="L249">        final GordianCoreSignatureFactory mySignFactory = (GordianCoreSignatureFactory) myFactory.getSignatureFactory();</span>
<span class="fc" id="L250">        final GordianSignature mySigner = mySignFactory.createSigner(pSignSpec);</span>
<span class="fc" id="L251">        final AlgorithmIdentifier myAlgId = mySignFactory.getIdentifierForSpecAndKeyPair(pSignSpec, pKeyPair);</span>

        /* Build the signed proof */
<span class="fc" id="L254">        return createSignedProof(pKeyPair, myAlgId, mySigner, pCertRequest);</span>
    }

    /**
     * Create a Signed Proof of Possession.
     * @param pKeyPair the keyPair
     * @param pAlgId the algorithmId
     * @param pSigner the signer
     * @param pCertRequest the certificate request
     * @return the proof of possession
     * @throws GordianException on error
     */
    private static ProofOfPossession createSignedProof(final GordianKeyPair pKeyPair,
                                                       final AlgorithmIdentifier pAlgId,
                                                       final GordianSignature pSigner,
                                                       final CertRequest pCertRequest) throws GordianException {
        /* Protect against exceptions */
        try {
            /* Create the signature */
<span class="fc" id="L273">            pSigner.initForSigning(GordianSignParams.keyPair(pKeyPair));</span>
<span class="fc" id="L274">            pSigner.update(pCertRequest.getEncoded());</span>
<span class="fc" id="L275">            final byte[] mySignature = pSigner.sign();</span>

            /* Build the signing key */
<span class="fc" id="L278">            final POPOSigningKey myKey = new POPOSigningKey(null, pAlgId, new DERBitString(mySignature));</span>
<span class="fc" id="L279">            return new ProofOfPossession(myKey);</span>

<span class="nc" id="L281">        } catch (IOException e) {</span>
<span class="nc" id="L282">            throw new GordianIOException(&quot;Failed to create Signed Proof of Possession&quot;, e);</span>
        }
    }

    /**
     * Extended POPOPrivKey to allow encryptedKey.
     */
    static class XPOPOPrivKey extends POPOPrivKey {
        /**
         * The encrypted key.
         */
        private final EnvelopedData theKey;

        /**
         * Constructor.
         * @param pEncryptedKey the encryptedKey.
         */
        XPOPOPrivKey(final EnvelopedData pEncryptedKey) {
<span class="nc" id="L300">            super((PKMACValue) null);</span>
<span class="nc" id="L301">            theKey = pEncryptedKey;</span>
<span class="nc" id="L302">        }</span>

        @Override
        public ASN1Primitive toASN1Primitive() {
<span class="nc" id="L306">            return new DERTaggedObject(false, encryptedKey, theKey);</span>
        }
    }

    /**
     * Create MACValue.
     * @param pSecret the secret
     * @param pData the data to calculate over
     * @return the MACValue
     * @throws GordianException on error
     */
    public PKMACValue createPKMACValue(final byte[] pSecret,
                                       final ASN1Object pData) throws GordianException {
<span class="fc" id="L319">        final PBMParameter myParams = generatePBMParameters();</span>
<span class="fc" id="L320">        return calculatePKMacValue(theGateway.getFactory(), pSecret, pData, myParams);</span>
    }

    /**
     * Check PKMACValue.
     * @param pSecret the secret
     * @param pData the data to calculate over
     * @param pMACValue the supplied MACValue
     * @throws GordianException on error
     */
    public void checkPKMACValue(final byte[] pSecret,
                                final ASN1Object pData,
                                final PKMACValue pMACValue) throws GordianException {
<span class="fc" id="L333">        final PBMParameter myParams = PBMParameter.getInstance(pMACValue.getAlgId().getParameters());</span>
<span class="fc" id="L334">        final PKMACValue myMACValue = calculatePKMacValue(theGateway.getFactory(), pSecret, pData, myParams);</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if (!pMACValue.equals(myMACValue)) {</span>
<span class="nc" id="L336">            throw new GordianDataException(&quot;Invalid PKMacValue&quot;);</span>
        }
<span class="fc" id="L338">    }</span>

    /**
     * Create PBMParameters.
     * @return the PBMParameters
     */
    private PBMParameter generatePBMParameters() {
        /* Create the salt value */
<span class="fc" id="L346">        final byte[] mySalt = new byte[GordianLength.LEN_256.getByteLength()];</span>
<span class="fc" id="L347">        final GordianRandomSource mySource = theGateway.getFactory().getRandomSource();</span>
<span class="fc" id="L348">        mySource.getRandom().nextBytes(mySalt);</span>

        /* Access algorithm ids */
<span class="fc" id="L351">        final AlgorithmIdentifier myHashId = new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha256, DERNull.INSTANCE);</span>
<span class="fc" id="L352">        final AlgorithmIdentifier myMacId = new AlgorithmIdentifier(PKCSObjectIdentifiers.id_hmacWithSHA256, DERNull.INSTANCE);</span>

        /* Create the PBMParameter */
<span class="fc" id="L355">        return new PBMParameter(mySalt, myHashId, PBM_ITERATIONS, myMacId);</span>
    }

    /**
     * Calculate PKMacValue.
     * @param pFactory the factory
     * @param pSecret the secret value
     * @param pObject the object
     * @param pParams the PBM Parameters
     * @return the PKMacValue
     * @throws GordianException on error
     */
    private static PKMACValue calculatePKMacValue(final GordianBaseFactory pFactory,
                                                  final byte[] pSecret,
                                                  final ASN1Object pObject,
                                                  final PBMParameter pParams) throws GordianException {
        /* Protect against exceptions */
        try {
            /* Create the digest */
<span class="fc" id="L374">            final GordianCoreDigestFactory myDigests = (GordianCoreDigestFactory) pFactory.getDigestFactory();</span>
<span class="fc" id="L375">            final GordianDigestSpec myDigestSpec = myDigests.getDigestSpecForIdentifier(pParams.getOwf());</span>
<span class="fc" id="L376">            final GordianDigest myDigest = myDigests.createDigest(myDigestSpec);</span>

            /* Run through the first iteration */
<span class="fc" id="L379">            myDigest.update(pSecret);</span>
<span class="fc" id="L380">            myDigest.update(pParams.getSalt().getOctets());</span>
<span class="fc" id="L381">            byte[] myKey = new byte[myDigest.getDigestSize()];</span>
<span class="fc" id="L382">            myKey = myDigest.finish(myKey);</span>

            /* Loop through the remaining iterations */
<span class="fc" id="L385">            final int numIterations = pParams.getIterationCount().intValueExact() - 1;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            for (int i = 0; i &lt; numIterations; i++) {</span>
<span class="fc" id="L387">                myKey = myDigest.finish(myKey);</span>
            }

            /* Create the mac */
<span class="fc" id="L391">            final GordianMacFactory myMacs = pFactory.getMacFactory();</span>
<span class="fc" id="L392">            final GordianMacSpec myMacSpec = (GordianMacSpec) pFactory.getKeySpecForIdentifier(pParams.getMac());</span>
<span class="fc" id="L393">            final GordianMac myMac = myMacs.createMac(myMacSpec);</span>
<span class="fc" id="L394">            myMac.initKeyBytes(myKey);</span>

            /* Create the result */
<span class="fc" id="L397">            myMac.update(pObject.toASN1Primitive().getEncoded());</span>
<span class="fc" id="L398">            final byte[] myResult = myMac.finish();</span>
<span class="fc" id="L399">            return new PKMACValue(pParams, new DERBitString(myResult));</span>

            /* Handle exceptions */
<span class="nc" id="L402">        } catch (IOException e) {</span>
<span class="nc" id="L403">            throw new GordianIOException(&quot;Failed to calculate PKMACValue&quot;, e);</span>
        }
    }

    /**
     * Calculate AckValue.
     * @param pCertificate the certificate
     * @return the AckValue
     * @throws GordianException on error
     */
    public byte[] calculateAckValue(final GordianCoreCertificate pCertificate) throws GordianException {
        /* Access the MACSecret */
<span class="fc" id="L415">        final X500Name mySubject = pCertificate.getSubjectName();</span>
<span class="fc" id="L416">        final byte[] myMACSecret = theGateway.getMACSecret(mySubject);</span>

        /* Create the digest */
<span class="fc" id="L419">        final GordianBaseFactory myFactory = theGateway.getFactory();</span>
<span class="fc" id="L420">        final GordianDigestFactory myDigests = myFactory.getDigestFactory();</span>
<span class="fc" id="L421">        final GordianDigest myDigest = myDigests.createDigest(GordianDigestSpecBuilder.sha2(GordianLength.LEN_256));</span>

        /* Calculate the digest */
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        if (myMACSecret != null) {</span>
<span class="fc" id="L425">            myDigest.update(myMACSecret);</span>
        }
<span class="fc" id="L427">        myDigest.update(pCertificate.getEncoded());</span>
<span class="fc" id="L428">        return myDigest.finish();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
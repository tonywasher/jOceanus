<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianCoreKeyStore.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.core.keystore</a> &gt; <span class="el_source">GordianCoreKeyStore.java</span></div><h1>GordianCoreKeyStore.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.core.keystore;

import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.base.GordianKeySpec;
import net.sourceforge.joceanus.gordianknot.api.cert.GordianCertificate;
import net.sourceforge.joceanus.gordianknot.api.cert.GordianCertificateId;
import net.sourceforge.joceanus.gordianknot.api.key.GordianKey;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPair;
import net.sourceforge.joceanus.gordianknot.api.keyset.GordianKeySet;
import net.sourceforge.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry;
import net.sourceforge.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStoreCertificate;
import net.sourceforge.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStoreKey;
import net.sourceforge.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStorePair;
import net.sourceforge.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStoreSet;
import net.sourceforge.joceanus.gordianknot.api.lock.GordianPasswordLockSpec;
import net.sourceforge.joceanus.gordianknot.api.zip.GordianZipFactory;
import net.sourceforge.joceanus.gordianknot.api.zip.GordianZipLock;
import net.sourceforge.joceanus.gordianknot.api.zip.GordianZipWriteFile;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import net.sourceforge.joceanus.gordianknot.impl.core.cert.GordianCoreCertificate;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianDataException;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianIOException;
import net.sourceforge.joceanus.gordianknot.impl.core.keystore.GordianCoreKeyStoreEntry.GordianCoreKeyStoreCertificate;
import net.sourceforge.joceanus.gordianknot.impl.core.keystore.GordianKeyStoreElement.GordianKeyStoreCertificateElement;
import net.sourceforge.joceanus.gordianknot.impl.core.keystore.GordianKeyStoreElement.GordianKeyStoreCertificateHolder;
import net.sourceforge.joceanus.gordianknot.impl.core.keystore.GordianKeyStoreElement.GordianKeyStoreKeyElement;
import net.sourceforge.joceanus.gordianknot.impl.core.keystore.GordianKeyStoreElement.GordianKeyStorePairElement;
import net.sourceforge.joceanus.gordianknot.impl.core.keystore.GordianKeyStoreElement.GordianKeyStoreSetElement;
import org.bouncycastle.asn1.cms.IssuerAndSerialNumber;
import org.bouncycastle.asn1.x500.X500Name;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;

/**
 * KeyStore implementation.
 * &lt;p&gt;
 * It should be noted that this implementation is based upon a number of assumptions.
 * &lt;/p&gt;
 * &lt;ol&gt;
 *     &lt;li&gt;The combination of Subject Name/Subject Id is viewed as a unique identifier for a public key. Multiple Certificates for the same subject,
 *     issued by different authorities must describe the same publicKey. It is expected that different publicKeys for the same subjectName
 *     WILL have different subjectIDs.&lt;/li&gt;
 *     &lt;li&gt;An issuerCertificate will only issue a single certificate at a time for a subjectName/subjectID combination.
 *     If two such certificates are received, the later one will overwrite the first one, (assuming the publicKey is the same).
 *     No attempt will be made to determine a BETTER certificate (e.g. longer validity)&lt;/li&gt;
 * &lt;/ol&gt;
 */
public class GordianCoreKeyStore
        implements GordianBaseKeyStore {
    /**
     * The ZipFile entry name.
     */
    static final String ZIPENTRY = &quot;KeyStore&quot;;

    /**
     * The factory.
     */
    private final GordianBaseFactory theFactory;

    /**
     * The passwordLockSpec.
     */
    private final GordianPasswordLockSpec thePasswordLockSpec;

    /**
     * The map of certificates by Subject.
     */
    private final Map&lt;GordianCertificateId, Map&lt;GordianCertificateId, GordianCertificate&gt;&gt; theSubjectCerts;

    /**
     * The map of certificates by Issuer.
     */
    private final Map&lt;GordianCertificateId, Map&lt;GordianCertificateId, GordianCertificate&gt;&gt; theIssuerCerts;

    /**
     * The aliases.
     */
    private final Map&lt;String, GordianKeyStoreEntry&gt; theAliases;

    /**
     * Constructor.
     * @param pFactory the factory
     * @param pSpec the passwordLockSpec
     */
    GordianCoreKeyStore(final GordianBaseFactory pFactory,
<span class="fc" id="L113">                        final GordianPasswordLockSpec pSpec) {</span>
        /* Store parameters */
<span class="fc" id="L115">        theFactory = pFactory;</span>
<span class="fc" id="L116">        thePasswordLockSpec = pSpec;</span>

        /* Create the maps */
<span class="fc" id="L119">        theSubjectCerts = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L120">        theIssuerCerts = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L121">        theAliases = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L122">    }</span>

    @Override
    public GordianBaseFactory getFactory() {
<span class="fc" id="L126">        return theFactory;</span>
    }

    /**
     * Obtain the passwordLockSpec.
     * @return the passwordLockSpec
     */
    public GordianPasswordLockSpec getPasswordLockSpec() {
<span class="fc" id="L134">        return thePasswordLockSpec;</span>
    }

    @Override
    public Map&lt;GordianCertificateId, Map&lt;GordianCertificateId, GordianCertificate&gt;&gt; getSubjectMapOfMaps() {
<span class="fc" id="L139">        return theSubjectCerts;</span>
    }

    /**
     * Obtain the issuerMapofMaps.
     * @return the map
     */
    private Map&lt;GordianCertificateId, Map&lt;GordianCertificateId, GordianCertificate&gt;&gt; getIssuerMapOfMaps() {
<span class="fc" id="L147">        return theIssuerCerts;</span>
    }

    @Override
    public Map&lt;String, GordianKeyStoreEntry&gt; getAliasMap() {
<span class="fc" id="L152">        return theAliases;</span>
    }

    @Override
    public GordianCertificate getCertificate(final GordianKeyStoreCertificateKey pKey) {
<span class="fc" id="L157">        final Map&lt;GordianCertificateId, GordianCertificate&gt; myCertMap = theSubjectCerts.get(pKey.getSubject());</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        return myCertMap == null ? null : myCertMap.get(pKey.getIssuer());</span>
    }

    @Override
    public List&lt;String&gt; getAliases() {
<span class="nc" id="L163">        return new ArrayList&lt;&gt;(theAliases.keySet());</span>
    }

    @Override
    public boolean containsAlias(final String pAlias) {
<span class="fc" id="L168">        return theAliases.containsKey(pAlias);</span>
    }

    @Override
    public int size() {
<span class="fc" id="L173">        return theAliases.size();</span>
    }

    @Override
    public void deleteEntry(final String pAlias) {
        /* Remove the existing entry */
<span class="fc" id="L179">        final GordianKeyStoreEntry myEntry = theAliases.remove(pAlias);</span>

        /* Nothing more to do unless we are removing a certificate */
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (!(myEntry instanceof GordianKeyStoreCertificateHolder)) {</span>
<span class="fc" id="L183">            return;</span>
        }

        /* Access the certificate */
<span class="fc" id="L187">        final GordianKeyStoreCertificateHolder myCertHolder = (GordianKeyStoreCertificateHolder) myEntry;</span>
<span class="fc" id="L188">        final GordianCertificate myCert = getCertificate(myCertHolder.getCertificateKey());</span>

        /* If the certificate is not referenced by any other alias */
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (getCertificateAlias(myCert) == null) {</span>
            /* Remove the certificate from the maps */
<span class="fc" id="L193">            removeCertificate(myCert);</span>
        }
<span class="fc" id="L195">    }</span>

    /**
     * Remove certificate from maps.
     * @param pCertificate the certificate to remove
     */
    private void removeCertificate(final GordianCertificate pCertificate) {
        /* Access the ids of the certificate */
<span class="fc" id="L203">        final GordianCertificateId mySubjectId = pCertificate.getSubject();</span>
<span class="fc" id="L204">        final GordianCertificateId myIssuerId = pCertificate.getIssuer();</span>

        /* If it is not referenced as issuer by any other certificate */
<span class="fc" id="L207">        Map&lt;GordianCertificateId, GordianCertificate&gt; myIssuedMap = theIssuerCerts.get(mySubjectId);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (isWithoutIssue(myIssuedMap)) {</span>
            /* If the certificate is not self-signed */
<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (!pCertificate.isSelfSigned()) {</span>
                /* Remove the certificate from the issuer map */
<span class="fc" id="L212">                myIssuedMap = theIssuerCerts.get(myIssuerId);</span>
<span class="fc" id="L213">                myIssuedMap.remove(mySubjectId);</span>

                /* If the issuer now has no issued certificates */
<span class="fc bfc" id="L216" title="All 2 branches covered.">                if (isWithoutIssue(myIssuedMap)) {</span>
                    /* Purge orphan issuers */
<span class="fc" id="L218">                    purgeOrphanIssuers(myIssuerId);</span>
                }
            }

            /* Remove the certificate from the subject map */
<span class="fc" id="L223">            final Map&lt;GordianCertificateId, GordianCertificate&gt; myCertMap = theSubjectCerts.get(mySubjectId);</span>
<span class="fc" id="L224">            myCertMap.remove(myIssuerId);</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">            if (myCertMap.isEmpty()) {</span>
<span class="fc" id="L226">                theSubjectCerts.remove(mySubjectId);</span>
            }
        }
<span class="fc" id="L229">    }</span>

    /**
     * Determine whether an issuer has no children (other than self).
     * @param pIssuer the issuer Map
     * @return true/false
     */
    private static boolean isWithoutIssue(final Map&lt;GordianCertificateId, GordianCertificate&gt; pIssuer) {
        /* If the map is null or empty then there are no children */
<span class="fc bfc" id="L238" title="All 4 branches covered.">        if (pIssuer == null || pIssuer.isEmpty()) {</span>
<span class="fc" id="L239">            return true;</span>
        }

        /* If there is only one certificate in the map */
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (pIssuer.size() == 1) {</span>
            /* If the single certificate is self-signed then we are childless */
<span class="fc" id="L245">            final GordianCertificate myCert = pIssuer.values().iterator().next();</span>
<span class="fc" id="L246">            return myCert.isSelfSigned();</span>
        }

        /* Not childless */
<span class="fc" id="L250">        return false;</span>
    }

    /**
     * Purge orphan issuers.
     * @param pIssuerId the issuerId to purge
     */
    private void purgeOrphanIssuers(final GordianCertificateId pIssuerId) {
        /* Remove the entry */
<span class="fc" id="L259">        theIssuerCerts.remove(pIssuerId);</span>

        /* Look for all issuers */
<span class="fc" id="L262">        final Map&lt;GordianCertificateId, GordianCertificate&gt; myCertMap = theSubjectCerts.get(pIssuerId);</span>

        /* Loop through all the certificates */
<span class="fc bfc" id="L265" title="All 2 branches covered.">        for (GordianCertificate myCert : myCertMap.values()) {</span>
            /* If the certificate is not referenced by any other alias */
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (getCertificateAlias(myCert) == null) {</span>
                /* Remove the certificate from the maps */
<span class="fc" id="L269">                removeCertificate(myCert);</span>
            }
<span class="fc" id="L271">        }</span>
<span class="fc" id="L272">    }</span>

    @Override
    public void setCertificate(final String pAlias,
                               final GordianCertificate pCertificate) throws GordianException {
        /* Check the alias */
<span class="fc" id="L278">        checkAlias(pAlias);</span>

        /* Check that we are not about to replace a non-certificate */
<span class="fc" id="L281">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L282" title="3 of 4 branches missed.">        if (myEntry != null</span>
                &amp;&amp; !(myEntry instanceof GordianCoreKeyStoreCertificate)) {
<span class="nc" id="L284">            throw new GordianDataException(&quot;Alias already exists for non-certificate&quot;);</span>
        }

        /* Remove any existing entry */
<span class="fc" id="L288">        deleteEntry(pAlias);</span>

        /* Set the new value */
<span class="fc" id="L291">        final GordianKeyStoreCertificateElement myCert = new GordianKeyStoreCertificateElement(pCertificate);</span>
<span class="fc" id="L292">        theAliases.put(pAlias, myCert);</span>

        /* Store certificate */
<span class="fc" id="L295">        storeCertificate(pCertificate);</span>
<span class="fc" id="L296">    }</span>

    @Override
    public void setKeyPair(final String pAlias,
                           final GordianKeyPair pKeyPair,
                           final char[] pPassword,
                           final List&lt;GordianCertificate&gt; pCertificateChain) throws GordianException {
        /* Check the alias */
<span class="fc" id="L304">        checkAlias(pAlias);</span>

        /* Make sure that the keyPair has a private key */
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (pKeyPair.isPublicOnly()) {</span>
<span class="nc" id="L308">            throw new GordianDataException(&quot;Private Key missing&quot;);</span>
        }

        /* Make sure that we have a valid certificate chain */
<span class="fc" id="L312">        checkChain(pKeyPair, pCertificateChain);</span>

        /* Remove any existing entry */
<span class="fc" id="L315">        deleteEntry(pAlias);</span>

        /* Set the new value */
<span class="fc" id="L318">        final GordianKeyStorePairElement myPair = new GordianKeyStorePairElement(theFactory, thePasswordLockSpec, pKeyPair, pPassword, pCertificateChain);</span>
<span class="fc" id="L319">        theAliases.put(pAlias, myPair);</span>

        /* Store all the certificates in the chain */
<span class="fc bfc" id="L322" title="All 2 branches covered.">        for (GordianCertificate myCert : pCertificateChain) {</span>
<span class="fc" id="L323">            storeCertificate(myCert);</span>
<span class="fc" id="L324">        }</span>
<span class="fc" id="L325">    }</span>

    @Override
    public void updateCertificateChain(final String pAlias,
                                       final List&lt;GordianCertificate&gt; pCertificateChain) throws GordianException {
        /* Obtain the keyStore Entry */
<span class="fc" id="L331">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if (!(myEntry instanceof GordianKeyStorePairElement)) {</span>
<span class="nc" id="L333">            throw new GordianDataException(&quot;Entry not found&quot;);</span>
        }
<span class="fc" id="L335">        final GordianKeyStorePairElement myKeyPairElement = (GordianKeyStorePairElement) myEntry;</span>

        /* Access old keyPair */
<span class="fc" id="L338">        final List&lt;GordianCertificate&gt; myChain = myKeyPairElement.buildChain(this);</span>
<span class="fc" id="L339">        final GordianKeyPair myKeyPair = myChain.get(0).getKeyPair();</span>

        /* Make sure that we have a valid certificate chain */
<span class="fc" id="L342">        checkChain(myKeyPair, pCertificateChain);</span>

        /* Access old certificate */
<span class="fc" id="L345">        final GordianCertificate myOldCert = getCertificate(myKeyPairElement.getCertificateKey());</span>

        /* If the certificate is not referenced by any other alias */
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">        if (getCertificateAlias(myOldCert) == null) {</span>
            /* Remove the certificate from the maps */
<span class="nc" id="L350">            removeCertificate(myOldCert);</span>
        }

        /* Update the chain */
<span class="fc" id="L354">        myKeyPairElement.updateChain(pCertificateChain);</span>

        /* Store all the certificates in the chain */
<span class="fc bfc" id="L357" title="All 2 branches covered.">        for (GordianCertificate myCert : pCertificateChain) {</span>
<span class="fc" id="L358">            storeCertificate(myCert);</span>
<span class="fc" id="L359">        }</span>
<span class="fc" id="L360">    }</span>

    @Override
    public &lt;T extends GordianKeySpec&gt; void setKey(final String pAlias,
                                                  final GordianKey&lt;T&gt; pKey,
                                                  final char[] pPassword) throws GordianException {
        /* Check the alias */
<span class="fc" id="L367">        checkAlias(pAlias);</span>

        /* Remove any existing entry */
<span class="fc" id="L370">        deleteEntry(pAlias);</span>

        /* Set the new value */
<span class="fc" id="L373">        final GordianKeyStoreKeyElement&lt;T&gt; myKey = new GordianKeyStoreKeyElement&lt;&gt;(theFactory, thePasswordLockSpec, pKey, pPassword);</span>
<span class="fc" id="L374">        theAliases.put(pAlias, myKey);</span>
<span class="fc" id="L375">    }</span>

    @Override
    public void setKeySet(final String pAlias,
                          final GordianKeySet pKeySet,
                          final char[] pPassword) throws GordianException {
        /* Check the alias */
<span class="fc" id="L382">        checkAlias(pAlias);</span>

        /* Remove any existing entry */
<span class="fc" id="L385">        deleteEntry(pAlias);</span>

        /* Set the new value */
<span class="fc" id="L388">        final GordianKeyStoreSetElement mySet = new GordianKeyStoreSetElement(theFactory, thePasswordLockSpec, pKeySet, pPassword);</span>
<span class="fc" id="L389">        theAliases.put(pAlias, mySet);</span>
<span class="fc" id="L390">    }</span>

    /**
     * Check that the alias is valid.
     * @param pAlias the alias
     */
    private static void checkAlias(final String pAlias) {
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">        if (pAlias == null) {</span>
<span class="nc" id="L398">            throw new NullPointerException();</span>
        }
<span class="fc" id="L400">    }</span>

    @Override
    public &lt;T extends GordianKeyStoreEntry&gt; boolean entryInstanceOf(final String pAlias,
                                                                    final Class&lt;T&gt; pClazz) {
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (pClazz.isAssignableFrom(GordianKeyStoreCertificate.class)) {</span>
<span class="nc" id="L406">            return isCertificateEntry(pAlias);</span>
        }
<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (pClazz.isAssignableFrom(GordianKeyStorePair.class)) {</span>
<span class="fc" id="L409">            return isKeyPairEntry(pAlias);</span>
        }
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (pClazz.isAssignableFrom(GordianKeyStoreKey.class)) {</span>
<span class="fc" id="L412">            return isKeyEntry(pAlias);</span>
        }
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (pClazz.isAssignableFrom(GordianKeyStoreSet.class)) {</span>
<span class="fc" id="L415">            return isKeySetEntry(pAlias);</span>
        }
<span class="nc" id="L417">        return false;</span>
    }

    @Override
    public boolean isCertificateEntry(final String pAlias) {
<span class="fc" id="L422">        return theAliases.get(pAlias) instanceof GordianKeyStoreCertificateElement;</span>
    }

    @Override
    public boolean isKeyPairEntry(final String pAlias) {
<span class="fc" id="L427">        return theAliases.get(pAlias) instanceof GordianKeyStorePairElement;</span>
    }

    @Override
    public boolean isKeyEntry(final String pAlias) {
<span class="fc" id="L432">        return theAliases.get(pAlias) instanceof GordianKeyStoreKeyElement;</span>
    }

    @Override
    public boolean isKeySetEntry(final String pAlias) {
<span class="fc" id="L437">        return theAliases.get(pAlias) instanceof GordianKeyStoreSetElement;</span>
    }

    @Override
    public GordianKeyStoreEntry getEntry(final String pAlias,
                                         final char[] pPassword) throws GordianException {
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        if (isCertificateEntry(pAlias)) {</span>
<span class="nc" id="L444">            return getKeyStoreCertificate(pAlias);</span>
        }
<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (isKeyPairEntry(pAlias)) {</span>
<span class="fc" id="L447">            return getKeyStorePair(pAlias, pPassword);</span>
        }
<span class="fc bfc" id="L449" title="All 2 branches covered.">        if (isKeyEntry(pAlias)) {</span>
<span class="fc" id="L450">            return getKeyStoreKey(pAlias, pPassword);</span>
        }
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        return isKeySetEntry(pAlias)</span>
<span class="fc" id="L453">                ? getKeyStoreSet(pAlias, pPassword)</span>
<span class="nc" id="L454">                : null;</span>
    }

    @Override
    public GordianCertificate getCertificate(final String pAlias) {
<span class="nc" id="L459">        final GordianKeyStoreCertificate myCert = getKeyStoreCertificate(pAlias);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">        if (myCert != null) {</span>
<span class="nc" id="L461">            return myCert.getCertificate();</span>
        }
<span class="nc" id="L463">        final List&lt;GordianCertificate&gt; myChain = getCertificateChain(pAlias);</span>
<span class="nc bnc" id="L464" title="All 4 branches missed.">        return myChain == null || myChain.isEmpty() ? null : myChain.get(0);</span>
    }

    /**
     * Obtain the keyStorePairCertificate.
     * @param pAlias the alias
     * @return the certificate entry (or null)
     */
    private GordianKeyStoreCertificate getKeyStoreCertificate(final String pAlias) {
<span class="nc" id="L473">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">        return myEntry instanceof GordianKeyStoreCertificateElement myElement</span>
<span class="nc" id="L475">                ? myElement.buildEntry(this)</span>
<span class="nc" id="L476">                : null;</span>
    }

    @Override
    public GordianKeyPair getKeyPair(final String pAlias,
                                     final char[] pPassword) throws GordianException {
<span class="fc" id="L482">        final GordianKeyStorePair myPair = getKeyStorePair(pAlias, pPassword);</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">        return myPair == null ? null : myPair.getKeyPair();</span>
    }

    @Override
    public List&lt;GordianCertificate&gt; getCertificateChain(final String pAlias) {
<span class="fc" id="L488">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">        return myEntry instanceof GordianKeyStorePairElement myElement</span>
<span class="fc" id="L490">                ? myElement.buildChain(this)</span>
<span class="nc" id="L491">                : null;</span>
    }

    /**
     * Obtain the keyStorePair.
     * @param pAlias the alias
     * @param pPassword the password
     * @return the keyPair entry (or null)
     */
    private GordianKeyStorePair getKeyStorePair(final String pAlias,
                                                final char[] pPassword) throws GordianException {
<span class="fc" id="L502">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        return myEntry instanceof GordianKeyStorePairElement myElement</span>
<span class="fc" id="L504">                ? myElement.buildEntry(this, pPassword)</span>
<span class="nc" id="L505">                : null;</span>
    }

    @Override
    public &lt;T extends GordianKeySpec&gt; GordianKey&lt;T&gt; getKey(final String pAlias,
                                                           final char[] pPassword) throws GordianException {
<span class="fc" id="L511">        final GordianKeyStoreKey&lt;T&gt; myKey = getKeyStoreKey(pAlias, pPassword);</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        return myKey == null ? null : myKey.getKey();</span>
    }

    /**
     * Obtain the keyStoreKey.
     * @param &lt;T&gt; the keyType
     * @param pAlias the alias
     * @param pPassword the password
     * @return the key entry (or null)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;T extends GordianKeySpec&gt; GordianKeyStoreKey&lt;T&gt; getKeyStoreKey(final String pAlias,
                                                                            final char[] pPassword) throws GordianException {
<span class="fc" id="L525">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        return myEntry instanceof GordianKeyStoreKeyElement</span>
<span class="fc" id="L527">                ? ((GordianKeyStoreKeyElement&lt;T&gt;) myEntry).buildEntry(this, pPassword)</span>
<span class="nc" id="L528">                : null;</span>
    }

    @Override
    public GordianKeySet getKeySet(final String pAlias,
                                   final char[] pPassword) throws GordianException {
<span class="fc" id="L534">        final GordianKeyStoreSet mySet = getKeyStoreSet(pAlias, pPassword);</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        return mySet == null ? null : mySet.getKeySet();</span>
    }

    /**
     * Obtain the keyStoreKeySet.
     * @param pAlias the alias
     * @param pPassword the password
     * @return the keySet entry (or null)
     */
    private GordianKeyStoreSet getKeyStoreSet(final String pAlias,
                                              final char[] pPassword) throws GordianException {
<span class="fc" id="L546">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        return myEntry instanceof GordianKeyStoreSetElement myElement</span>
<span class="fc" id="L548">                ? myElement.buildEntry(this, pPassword)</span>
<span class="nc" id="L549">                : null;</span>
    }

    @Override
    public LocalDate getCreationDate(final String pAlias) {
<span class="nc" id="L554">        final GordianKeyStoreEntry myEntry = theAliases.get(pAlias);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">        return myEntry != null ? myEntry.getCreationDate() : null;</span>
    }

    @Override
    public String getCertificateAlias(final GordianCertificate pCertificate) {
        /* Loop through the alias entries */
<span class="fc bfc" id="L561" title="All 2 branches covered.">        for (Entry&lt;String, GordianKeyStoreEntry&gt; myRecord : theAliases.entrySet()) {</span>
            /* Check for match on certificate entry */
<span class="fc" id="L563">            final GordianKeyStoreEntry myEntry = myRecord.getValue();</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            if (myEntry instanceof GordianKeyStoreCertificateHolder myHolder) {</span>
<span class="fc" id="L565">                final GordianKeyStoreCertificateKey myKey = myHolder.getCertificateKey();</span>
<span class="fc" id="L566">                final GordianCertificate myCert = getCertificate(myKey);</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">                if (pCertificate.equals(myCert)) {</span>
<span class="fc" id="L568">                    return myRecord.getKey();</span>
                }
            }
<span class="fc" id="L571">        }</span>

        /* Not found */
<span class="fc" id="L574">        return null;</span>
    }

    @Override
    public void storeCertificate(final GordianCertificate pCertificate) {
        /* Access the ids */
<span class="fc" id="L580">        final GordianCertificateId mySubjectId = pCertificate.getSubject();</span>
<span class="fc" id="L581">        final GordianCertificateId myIssuerId = pCertificate.getIssuer();</span>

        /* Add the certificate to the list of certificates for this subject */
<span class="fc" id="L584">        Map&lt;GordianCertificateId, GordianCertificate&gt; myMap = theSubjectCerts.computeIfAbsent(mySubjectId, i -&gt; new LinkedHashMap&lt;&gt;());</span>
<span class="fc" id="L585">        myMap.put(myIssuerId, pCertificate);</span>

        /* Add the certificate to the list of certificates for this issuer */
<span class="fc" id="L588">        myMap = theIssuerCerts.computeIfAbsent(myIssuerId, i -&gt; new LinkedHashMap&lt;&gt;());</span>
<span class="fc" id="L589">        myMap.put(mySubjectId, pCertificate);</span>
<span class="fc" id="L590">    }</span>

    /**
     * Check validity of certificate chain.
     * @param pKeyPair the keyPair
     * @param pChain the certificate chain
     * @throws GordianException on error
     */
    private void checkChain(final GordianKeyPair pKeyPair,
                            final List&lt;GordianCertificate&gt; pChain) throws GordianException {
        /* Make sure that we have a chain */
<span class="pc bpc" id="L601" title="2 of 4 branches missed.">        if (pChain == null || pChain.isEmpty()) {</span>
<span class="nc" id="L602">            throw new GordianDataException(&quot;Empty chain&quot;);</span>
        }

        /* Make sure that the keyPair matches end-entity certificate */
<span class="fc" id="L606">        final GordianCoreCertificate myCert = (GordianCoreCertificate) pChain.get(0);</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">        if (!myCert.checkMatchingPublicKey(pKeyPair)) {</span>
<span class="nc" id="L608">            throw new GordianDataException(&quot;End-entity certificate does not match keyPair&quot;);</span>
        }

        /* Loop through the certificates */
<span class="fc" id="L612">        final int mySize = pChain.size();</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">        for (int i = 0; i &lt; mySize - 1; i++) {</span>
            /* Access the certificate */
<span class="fc" id="L615">            final GordianCoreCertificate myTestCert = (GordianCoreCertificate) pChain.get(i);</span>
<span class="fc" id="L616">            final GordianCoreCertificate mySignerCert = (GordianCoreCertificate) pChain.get(i + 1);</span>

            /* Check the hierarchy */
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">            if (!myTestCert.validateCertificate(mySignerCert)) {</span>
<span class="nc" id="L620">                throw new GordianDataException(&quot;Invalid certificate in path&quot;);</span>
            }

            /* Look up any existing certificate for the signer */
<span class="fc" id="L624">            final Map&lt;GordianCertificateId, GordianCertificate&gt; myMap = theSubjectCerts.get(mySignerCert.getSubject());</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">            if (myMap != null) {</span>
<span class="fc" id="L626">                final GordianCoreCertificate myExisting = (GordianCoreCertificate) myMap.values().iterator().next();</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">                if (!myExisting.checkMatchingPublicKey(mySignerCert.getKeyPair())) {</span>
<span class="nc" id="L628">                    throw new GordianDataException(&quot;Intermediate certificate does not match existing keyPair&quot;);</span>
                }
            }
        }

        /* Check that we are anchored by a root certificate */
<span class="fc" id="L634">        final GordianCertificate myRoot = pChain.get(mySize - 1);</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">        if (!((GordianCoreCertificate) myRoot).validateRootCertificate()) {</span>
<span class="nc" id="L636">            throw new GordianDataException(&quot;Invalid root certificate&quot;);</span>
        }

        /* Check that the root is known if the depth is greater than 1 */
<span class="pc bpc" id="L640" title="1 of 4 branches missed.">        if (mySize &gt; 1 &amp;&amp; getCertificateAlias(myRoot) == null) {</span>
<span class="nc" id="L641">            throw new GordianDataException(&quot;Unknown root certificate&quot;);</span>
        }
<span class="fc" id="L643">    }</span>

    @Override
    public String findIssuerCert(final IssuerAndSerialNumber pIssuer) throws GordianException {
        /* Loop through the alias entries */
<span class="nc" id="L648">        final X500Name myIssuer = pIssuer.getName();</span>
<span class="nc" id="L649">        final BigInteger mySerial = pIssuer.getSerialNumber().getValue();</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">        for (Entry&lt;String, GordianKeyStoreEntry&gt; myEntry : theAliases.entrySet()) {</span>
            /* If this is a keyPair(Set) entry */
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (myEntry.getValue() instanceof GordianKeyStorePairElement myPair) {</span>
                /* Access details */
<span class="nc" id="L654">                final GordianKeyStoreCertificateKey myCertKey =  myPair.getCertificateChain().get(0);</span>
<span class="nc" id="L655">                final GordianCoreCertificate myCert = (GordianCoreCertificate) getCertificate(myCertKey);</span>

                /* Return alias if we have a match */
<span class="nc bnc" id="L658" title="All 2 branches missed.">                if (myIssuer.equals(myCert.getIssuer().getName())</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">                    &amp;&amp; mySerial.equals(myCert.getSerialNo())) {</span>
<span class="nc" id="L660">                    return myEntry.getKey();</span>
                }
            }
<span class="nc" id="L663">        }</span>

        /* Reject request */
<span class="nc" id="L666">        throw new GordianDataException(&quot;Issuer not found&quot;);</span>
    }

    @Override
    public void storeToFile(final File pFile,
                            final char[] pPassword) throws GordianException {
        try {
<span class="nc" id="L673">            storeToStream(new FileOutputStream(pFile), pPassword);</span>
<span class="nc" id="L674">        } catch (IOException e) {</span>
<span class="nc" id="L675">            throw new GordianIOException(&quot;Failed to store to file&quot;, e);</span>
<span class="nc" id="L676">        }</span>
<span class="nc" id="L677">    }</span>

    @Override
    public void storeToStream(final OutputStream pOutputStream,
                              final char[] pPassword) throws GordianException {
        /* Access the Factories */
<span class="fc" id="L683">        final GordianZipFactory myZipFactory = theFactory.getZipFactory();</span>

        /* Create the lock */
<span class="fc" id="L686">        final GordianZipLock myLock = myZipFactory.factoryZipLock(pPassword);</span>

        /* Create the Zip file */
<span class="fc" id="L689">        try (GordianZipWriteFile myZipFile = myZipFactory.createZipFile(myLock, pOutputStream)) {</span>
            /* Create the XML representation */
<span class="fc" id="L691">            final GordianKeyStoreDocument myDocument = new GordianKeyStoreDocument(this);</span>

            /* Write the document to the file */
<span class="fc" id="L694">            myZipFile.writeXMLDocument(new File(ZIPENTRY), myDocument.getDocument());</span>

            /* Catch Exceptions */
<span class="nc" id="L697">        } catch (IOException e) {</span>
<span class="nc" id="L698">            throw new GordianIOException(&quot;Failed to store to stream&quot;, e);</span>
<span class="fc" id="L699">        }</span>
<span class="fc" id="L700">    }</span>

    @Override
    public boolean equals(final Object pThat) {
        /* Handle the trivial case */
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        if (pThat == this) {</span>
<span class="nc" id="L706">            return true;</span>
        }
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">        if (pThat == null) {</span>
<span class="nc" id="L709">            return false;</span>
        }

        /* Ensure object is correct class */
<span class="fc" id="L713">        return pThat instanceof GordianCoreKeyStore myThat</span>
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">                &amp;&amp; theSubjectCerts.equals(myThat.getSubjectMapOfMaps())</span>
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">                &amp;&amp; theIssuerCerts.equals(myThat.getIssuerMapOfMaps())</span>
<span class="pc bpc" id="L716" title="2 of 4 branches missed.">                &amp;&amp; theAliases.equals(myThat.getAliasMap());</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L721">        return Objects.hash(theSubjectCerts, theIssuerCerts, theAliases);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
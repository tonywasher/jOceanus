<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianCoreKeyStoreGateway.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.core.keystore</a> &gt; <span class="el_source">GordianCoreKeyStoreGateway.java</span></div><h1>GordianCoreKeyStoreGateway.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.core.keystore;

import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.cert.GordianCertificate;
import net.sourceforge.joceanus.gordianknot.api.cert.GordianKeyPairUse;
import net.sourceforge.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry;
import net.sourceforge.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStorePair;
import net.sourceforge.joceanus.gordianknot.api.zip.GordianZipLock;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianDataConverter;
import net.sourceforge.joceanus.gordianknot.impl.core.cert.GordianCoreCertificate;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianDataException;
import net.sourceforge.joceanus.gordianknot.impl.core.keystore.GordianPEMObject.GordianPEMObjectType;
import net.sourceforge.joceanus.gordianknot.impl.core.zip.GordianCoreZipLock;
import org.bouncycastle.asn1.ASN1Object;
import org.bouncycastle.asn1.crmf.CertReqMsg;
import org.bouncycastle.asn1.crmf.PKMACValue;
import org.bouncycastle.asn1.x500.X500Name;

import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;

/**
 * keyStoreGateway implementation.
 */
public class GordianCoreKeyStoreGateway
        implements GordianBaseKeyStoreGateway {
    /**
     * The factory.
     */
    private final GordianBaseFactory theFactory;

    /**
     * The keyStoreMgr.
     */
    private final GordianCoreKeyStoreManager theKeyStoreMgr;

    /**
     * The keyStore.
     */
    private final GordianCoreKeyStore theKeyStore;

    /**
     * The encryptor.
     */
    private final GordianCRMEncryptor theEncryptor;

    /**
     * The builder.
     */
    private final GordianCRMBuilder theBuilder;

    /**
     * The parser.
     */
    private final GordianCRMParser theParser;

    /**
     * The next messageId.
     */
    private final AtomicInteger theNextId;

    /**
     * The requestMap.
     */
    private final Map&lt;Integer, GordianRequestCache&gt; theRequestMap;

    /**
     * The responseMap.
     */
    private final Map&lt;Integer, GordianCoreCertificate&gt; theResponseMap;

    /**
     * The encryption target certificate.
     */
    private GordianCoreCertificate theTarget;

    /**
     * The secret MAC key resolver.
     */
    private Function&lt;X500Name, String&gt; theMACSecretResolver;

    /**
     * The keyPairCertifier.
     */
    private GordianKeyStorePair theKeyPairCertifier;

    /**
     * The password callback.
     */
    private Function&lt;String, char[]&gt; thePasswordResolver;

    /**
     * The lock callback.
     */
    private GordianLockResolver theLockResolver;

    /**
     * Constructor.
     * @param pFactory the factory
     * @param pKeyStoreMgr the keyStoreMgr
     */
    GordianCoreKeyStoreGateway(final GordianBaseFactory pFactory,
<span class="fc" id="L127">                               final GordianCoreKeyStoreManager pKeyStoreMgr) {</span>
        /* Store parameters */
<span class="fc" id="L129">        theFactory = pFactory;</span>
<span class="fc" id="L130">        theKeyStoreMgr = pKeyStoreMgr;</span>
<span class="fc" id="L131">        theKeyStore = theKeyStoreMgr.getKeyStore();</span>

        /* Create underlying classes */
<span class="fc" id="L134">        theEncryptor = new GordianCRMEncryptor(theFactory);</span>
<span class="fc" id="L135">        theBuilder = new GordianCRMBuilder(this);</span>
<span class="fc" id="L136">        theParser = new GordianCRMParser(this, theBuilder);</span>
<span class="fc" id="L137">        theNextId = new AtomicInteger(1);</span>
<span class="fc" id="L138">        theRequestMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L139">        theResponseMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L140">    }</span>

    @Override
    public GordianBaseFactory getFactory() {
<span class="fc" id="L144">        return theFactory;</span>
    }

    @Override
    public GordianCoreKeyStore getKeyStore() {
<span class="fc" id="L149">        return theKeyStore;</span>
    }

    @Override
    public GordianCoreKeyStoreManager getKeyStoreManager() {
<span class="fc" id="L154">        return theKeyStoreMgr;</span>
    }

    @Override
    public GordianCRMEncryptor getEncryptor() {
<span class="fc" id="L159">        return theEncryptor;</span>
    }

    @Override
    public GordianKeyStorePair getSigner() {
<span class="fc" id="L164">        return theKeyPairCertifier;</span>
    }

    @Override
    public byte[] getMACSecret(final X500Name pName) {
<span class="fc" id="L169">        final String mySecret = theMACSecretResolver.apply(pName);</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        return mySecret == null ? null : GordianDataConverter.stringToByteArray(mySecret);</span>
    }

    @Override
    public GordianCoreCertificate getTarget() {
<span class="fc" id="L175">        return theTarget;</span>
    }

    @Override
    public Function&lt;String, char[]&gt; getPasswordResolver() {
<span class="nc" id="L180">        return thePasswordResolver;</span>
    }

    @Override
    public void exportEntry(final String pAlias,
                            final OutputStream pStream,
                            final GordianZipLock pLock) throws GordianException {
<span class="fc" id="L187">        final char[] myPassword = thePasswordResolver.apply(pAlias);</span>
<span class="fc" id="L188">        final GordianKeyStoreEntry myEntry = theKeyStore.getEntry(pAlias, myPassword);</span>
<span class="fc" id="L189">        final GordianPEMCoder myCoder = new GordianPEMCoder(theKeyStore);</span>
<span class="fc" id="L190">        myCoder.exportKeyStoreEntry(myEntry, pStream, (GordianCoreZipLock) pLock);</span>
<span class="fc" id="L191">    }</span>

    @Override
    public void setEncryptionTarget(final String pAlias) throws GordianException {
<span class="nc" id="L195">        final List&lt;GordianCertificate&gt; myKeyPairChain = theKeyStore.getCertificateChain(pAlias);</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (myKeyPairChain != null) {</span>
<span class="nc" id="L197">            theTarget = (GordianCoreCertificate) myKeyPairChain.get(0);</span>
<span class="nc" id="L198">            return;</span>
        }
<span class="nc" id="L200">        throw new GordianDataException(&quot;Encryption target not found&quot;);</span>
    }

    @Override
    public void setMACSecretResolver(final Function&lt;X500Name, String&gt; pResolver) {
<span class="fc" id="L205">        theMACSecretResolver = pResolver;</span>
<span class="fc" id="L206">    }</span>

    @Override
    public void createCertificateRequest(final String pAlias,
                                         final OutputStream pStream) throws GordianException {
        /* Access the requested entry */
<span class="fc" id="L212">        final char[] myPassword = thePasswordResolver.apply(pAlias);</span>
<span class="fc" id="L213">        final GordianKeyStoreEntry myEntry = theKeyStore.getEntry(pAlias, myPassword);</span>

        /* If it is a keyPair */
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (myEntry instanceof GordianKeyStorePair myKeyPair) {</span>
            /* Create the certificate request */
<span class="fc" id="L218">            final int myReqId = theNextId.getAndIncrement();</span>
<span class="fc" id="L219">            final CertReqMsg myCertReq = theBuilder.createCertificateRequest(myKeyPair, myReqId);</span>

            /* Store details in requestMap */
<span class="fc" id="L222">            theRequestMap.put(myReqId, new GordianRequestCache(pAlias, myKeyPair));</span>

            /* Write request to output stream */
<span class="fc" id="L225">            final GordianPEMParser myParser = new GordianPEMParser();</span>
<span class="fc" id="L226">            final GordianPEMObject myPEMObject = GordianPEMCoder.createPEMObject(GordianPEMObjectType.CERTREQ, myCertReq);</span>
<span class="fc" id="L227">            myParser.writePEMFile(pStream, Collections.singletonList(myPEMObject));</span>

            /* else reject request */
<span class="fc" id="L230">        } else {</span>
<span class="nc" id="L231">            throw new GordianDataException(&quot;Alias not found&quot;);</span>
        }
<span class="fc" id="L233">    }</span>

    @Override
    public void setCertifier(final String pAlias) throws GordianException {
<span class="fc" id="L237">        final char[] myPassword = thePasswordResolver.apply(pAlias);</span>
<span class="fc" id="L238">        final GordianKeyStoreEntry myEntry = theKeyStore.getEntry(pAlias, myPassword);</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (myEntry instanceof GordianKeyStorePair myPair) {</span>
<span class="fc" id="L240">            final GordianCertificate myCert = myPair.getCertificateChain().get(0);</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            if (myCert.getUsage().hasUse(GordianKeyPairUse.CERTIFICATE)) {</span>
<span class="fc" id="L242">                theKeyPairCertifier = myPair;</span>
<span class="fc" id="L243">                return;</span>
            }
        }
<span class="nc" id="L246">        throw new GordianDataException(&quot;Invalid keyPairCertifier&quot;);</span>
    }

    @Override
    public void setPasswordResolver(final Function&lt;String, char[]&gt; pResolver) {
<span class="fc" id="L251">        thePasswordResolver = pResolver;</span>
<span class="fc" id="L252">    }</span>

    @Override
    public void setLockResolver(final GordianLockResolver pResolver) {
<span class="fc" id="L256">        theLockResolver = pResolver;</span>
<span class="fc" id="L257">    }</span>

    @Override
    public void processCertificateRequest(final InputStream pInStream,
                                          final OutputStream pOutStream) throws GordianException {
        /* Decode the certificate request */
<span class="fc" id="L263">        final GordianPEMParser myParser = new GordianPEMParser();</span>
<span class="fc" id="L264">        final List&lt;GordianPEMObject&gt; myObjects = myParser.parsePEMFile(pInStream);</span>
<span class="fc" id="L265">        final CertReqMsg myCertReq = GordianPEMCoder.decodeCertRequest(myObjects);</span>

        /* Determine responseId and sign certificate */
<span class="fc" id="L268">        final int myRespId = theNextId.getAndIncrement();</span>
<span class="fc" id="L269">        final List&lt;GordianCertificate&gt; myChain = theParser.processCertificateRequest(myCertReq);</span>

        /* Create the certificate response */
<span class="fc" id="L272">        final int myReqId = myCertReq.getCertReq().getCertReqId().intValueExact();</span>
<span class="fc" id="L273">        final GordianCertResponseASN1 myResponse = GordianCertResponseASN1.createCertResponse(myReqId, myRespId, myChain);</span>

        /* Create PKMACValue if required */
<span class="fc" id="L276">        final X500Name mySubject = myCertReq.getCertReq().getCertTemplate().getSubject();</span>
<span class="fc" id="L277">        final byte[] myMACSecret = getMACSecret(mySubject);</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (myMACSecret != null) {</span>
<span class="fc" id="L279">            final ASN1Object myMACData = myResponse.getMACData();</span>
<span class="fc" id="L280">            final PKMACValue myMACValue = theBuilder.createPKMACValue(myMACSecret, myMACData);</span>
<span class="fc" id="L281">            myResponse.setMACValue(myMACValue);</span>
        }

        /* Access the new certificate */
<span class="fc" id="L285">        final GordianCoreCertificate myCert = (GordianCoreCertificate) myChain.get(0);</span>

        /* If the certificate requires encryption */
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (GordianCRMParser.requiresEncryption(myCertReq)) {</span>
            /* Encrypt the certificate */
<span class="fc" id="L290">            myResponse.encryptCertificate(theEncryptor);</span>

            /* Store in the response cache */
<span class="fc" id="L293">            theResponseMap.put(myRespId, myCert);</span>

            /* else store the certificate */
        } else {
<span class="fc" id="L297">            theKeyStore.setCertificate(getCertificateAlias(myRespId), myCert);</span>
        }

        /* Write out the response */
<span class="fc" id="L301">        final GordianPEMObject myPEMObject = GordianPEMCoder.createPEMObject(GordianPEMObjectType.CERTRESP, myResponse);</span>
<span class="fc" id="L302">        myParser.writePEMFile(pOutStream, Collections.singletonList(myPEMObject));</span>
<span class="fc" id="L303">    }</span>

    @Override
    public Integer processCertificateResponse(final InputStream pInStream,
                                              final OutputStream pOutStream) throws GordianException {
        /* Decode the certificate response */
<span class="fc" id="L309">        final GordianPEMParser myParser = new GordianPEMParser();</span>
<span class="fc" id="L310">        final List&lt;GordianPEMObject&gt; myObjects = myParser.parsePEMFile(pInStream);</span>
<span class="fc" id="L311">        final GordianCertResponseASN1 myResponse = GordianPEMCoder.decodeCertResponse(myObjects);</span>

        /* Access the original keyPair for the request */
<span class="fc" id="L314">        final GordianRequestCache myCache = theRequestMap.get(myResponse.getReqId());</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">        if (myCache == null) {</span>
<span class="nc" id="L316">            throw new GordianDataException(&quot;Unrecognised request Id&quot;);</span>
        }
<span class="fc" id="L318">        theRequestMap.remove(myResponse.getReqId());</span>

        /* Process the certificate response */
<span class="fc" id="L321">        theParser.processCertificateResponse(myResponse, myCache.getKeyPair());</span>
<span class="fc" id="L322">        final GordianCertificate[] myChain = myResponse.getCertificateChain(theEncryptor);</span>

        /* Update the keyStore with the new certificate chain */
<span class="fc" id="L325">        final List&lt;GordianCertificate&gt; myList = List.of(myChain);</span>
<span class="fc" id="L326">        theKeyStore.updateCertificateChain(myCache.getAlias(), myList);</span>

        /* calculate the Digest value */
<span class="fc" id="L329">        final byte[] myDigest = theBuilder.calculateAckValue((GordianCoreCertificate) myChain[0]);</span>
<span class="fc" id="L330">        final GordianCertAckASN1 myAck = new GordianCertAckASN1(myResponse.getRespId(), myDigest);</span>

        /* Write out the response */
<span class="fc" id="L333">        final GordianPEMObject myPEMObject = GordianPEMCoder.createPEMObject(GordianPEMObjectType.CERTACK, myAck);</span>
<span class="fc" id="L334">        myParser.writePEMFile(pOutStream, Collections.singletonList(myPEMObject));</span>

        /* Return the response id */
<span class="fc" id="L337">        return myResponse.getRespId();</span>
    }

    @Override
    public void processCertificateAck(final InputStream pInStream) throws GordianException {
        /* Decode the certificate ack */
<span class="fc" id="L343">        final GordianPEMParser myParser = new GordianPEMParser();</span>
<span class="fc" id="L344">        final List&lt;GordianPEMObject&gt; myObjects = myParser.parsePEMFile(pInStream);</span>
<span class="fc" id="L345">        final GordianCertAckASN1 myAck = GordianPEMCoder.decodeCertAck(myObjects);</span>
<span class="fc" id="L346">        final Integer myRespId = myAck.getRespId();</span>

        /* Access the original certificate for the ack */
<span class="fc" id="L349">        final GordianCoreCertificate myCert = theResponseMap.get(myRespId);</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (myCert == null) {</span>
<span class="nc" id="L351">            throw new GordianDataException(&quot;Unrecognised response Id&quot;);</span>
        }
<span class="fc" id="L353">        theResponseMap.remove(myRespId);</span>

        /* Check the Digest value */
<span class="fc" id="L356">        final byte[]  myDigest = theBuilder.calculateAckValue(myCert);</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        if (!Arrays.equals(myDigest, myAck.getDigestValue())) {</span>
<span class="nc" id="L358">            throw new GordianDataException(&quot;Invalid Digest&quot;);</span>
        }

        /* Store the certificate */
<span class="fc" id="L362">        theKeyStore.setCertificate(getCertificateAlias(myRespId), myCert);</span>
<span class="fc" id="L363">    }</span>

        @Override
    public GordianKeyStoreEntry importEntry(final InputStream pStream) throws GordianException {
<span class="fc" id="L367">        final GordianPEMCoder myCoder = new GordianPEMCoder(theKeyStore);</span>
<span class="fc" id="L368">        myCoder.setLockResolver(theLockResolver);</span>
<span class="fc" id="L369">        return myCoder.importKeyStoreEntry(pStream);</span>
    }

    @Override
    public List&lt;GordianKeyStoreEntry&gt; importCertificates(final InputStream pStream) throws GordianException {
<span class="nc" id="L374">        final GordianPEMCoder myCoder = new GordianPEMCoder(theKeyStore);</span>
<span class="nc" id="L375">        return myCoder.importCertificates(pStream);</span>
    }

    /**
     * Get certificate alias.
     * @param pRespId the response id
     * @return the alias
     */
    public String getCertificateAlias(final Integer pRespId) {
<span class="fc" id="L384">        return &quot;AllocatedCertificate_&quot; + pRespId;</span>
    }

    /**
     * RequestMapCache.
     */
    static final class GordianRequestCache {
         /**
         * The alias.
         */
        private final String theAlias;

        /**
         * The KeyPair.
         */
        private final GordianKeyStorePair theKeyPair;

        /**
         * Constructor.
         * @param pAlias the alias
         * @param pKeyPair the keyPair
         */
        GordianRequestCache(final String pAlias,
<span class="fc" id="L407">                            final GordianKeyStorePair pKeyPair) {</span>
<span class="fc" id="L408">            theAlias = pAlias;</span>
<span class="fc" id="L409">            theKeyPair = pKeyPair;</span>
<span class="fc" id="L410">        }</span>

        /**
         * Obtain the alias.
         * @return the alias
         */
        String getAlias() {
<span class="fc" id="L417">            return theAlias;</span>
        }

        /**
         * Obtain the keyPair.
         * @return the keyPair
         */
        GordianKeyStorePair getKeyPair() {
<span class="fc" id="L425">            return theKeyPair;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
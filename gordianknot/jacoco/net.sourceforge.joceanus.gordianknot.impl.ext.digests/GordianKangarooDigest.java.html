<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianKangarooDigest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.ext.digests</a> &gt; <span class="el_source">GordianKangarooDigest.java</span></div><h1>GordianKangarooDigest.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.ext.digests;

import net.sourceforge.joceanus.gordianknot.api.base.GordianLength;
import net.sourceforge.joceanus.gordianknot.impl.ext.params.GordianKeccakParameters;

import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.Xof;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Pack;

/**
 * Kangaroo. Donated to BouncyCastle.
 */
public abstract class GordianKangarooDigest
        implements Digest {
    /**
     * Default digest length.
     */
    private static final int DIGESTLEN = 32;

    /**
     * Private constructor.
     */
    private GordianKangarooDigest() {
    }

    /**
     * KangarooTwelve.
     */
    public static class GordianKangarooTwelve
            extends GordianKangarooBase {
        /**
         * # of rounds.
         */
        private static final int ROUNDS = 12;

        /**
         * Constructor.
         */
        public GordianKangarooTwelve() {
<span class="fc" id="L57">            this(DIGESTLEN);</span>
<span class="fc" id="L58">        }</span>

        /**
         * Constructor.
         * @param pLength the digest length
         */
        public GordianKangarooTwelve(final int pLength) {
<span class="fc" id="L65">            super(GordianLength.LEN_128.getLength(), ROUNDS, pLength);</span>
<span class="fc" id="L66">        }</span>

        @Override
        public String getAlgorithmName() {
<span class="fc" id="L70">            return getClass().getSimpleName();</span>
        }
    }

    /**
     * MarsupilamiFourteen.
     */
    public static class GordianMarsupilamiFourteen
            extends GordianKangarooBase {
        /**
         * # of rounds.
         */
        private static final int ROUNDS = 14;

        /**
         * Constructor.
         */
        public GordianMarsupilamiFourteen() {
<span class="nc" id="L88">            this(DIGESTLEN);</span>
<span class="nc" id="L89">        }</span>

        /**
         * Constructor.
         * @param pLength the digest length
         */
        public GordianMarsupilamiFourteen(final int pLength) {
<span class="fc" id="L96">            super(GordianLength.LEN_256.getLength(), ROUNDS, pLength);</span>
<span class="fc" id="L97">        }</span>

        @Override
        public String getAlgorithmName() {
<span class="fc" id="L101">            return getClass().getSimpleName();</span>
        }
    }

    /**
     * The Kangaroo Base.
     */
    public abstract static class GordianKangarooBase
            implements Digest, Xof {
        /**
         * Block Size.
         */
        private static final int BLKSIZE = 8192;

        /**
         * Single marker.
         */
<span class="fc" id="L118">        private static final byte[] SINGLE = new byte[] { 7 };</span>

        /**
         * Intermediate marker.
         */
<span class="fc" id="L123">        private static final byte[] INTERMEDIATE = new byte[] { 0xb };</span>

        /**
         * Final marker.
         */
<span class="fc" id="L128">        private static final byte[] FINAL = new byte[] { -1, -1, 6 };</span>

        /**
         * First marker.
         */
<span class="fc" id="L133">        private static final byte[] FIRST = new byte[] { 3, 0, 0, 0, 0, 0, 0, 0 };</span>

        /**
         * The single byte buffer.
         */
<span class="fc" id="L138">        private final byte[] singleByte = new byte[1];</span>

        /**
         * The Tree Sponge.
         */
        private final GordianKangarooSponge theTree;

        /**
         * The Leaf Sponge.
         */
        private final GordianKangarooSponge theLeaf;

        /**
         * The chain length.
         */
        private final int theChainLen;

        /**
         * The personalisation.
         */
        private byte[] thePersonal;

        /**
         * Are we squeezing?.
         */
        private boolean squeezing;

        /**
         * The current node.
         */
        private int theCurrNode;

        /**
         * The data processed in the current node.
         */
        private int theProcessed;

        /**
         * Constructor.
         * @param pStrength the strength
         * @param pRounds the rounds.
         * @param pLength the digest length
         */
        GordianKangarooBase(final int pStrength,
                            final int pRounds,
<span class="fc" id="L183">                            final int pLength) {</span>
            /* Create underlying digests */
<span class="fc" id="L185">            theTree = new GordianKangarooSponge(pStrength, pRounds);</span>
<span class="fc" id="L186">            theLeaf = new GordianKangarooSponge(pStrength, pRounds);</span>
<span class="fc" id="L187">            theChainLen = pStrength &gt;&gt; 2;</span>

            /* Build personalisation */
<span class="fc" id="L190">            buildPersonal(null);</span>
<span class="fc" id="L191">        }</span>

        /**
         * Constructor.
         * @param pPersonal the personalisation
         */
        private void buildPersonal(final byte[] pPersonal) {
            /* Build personalisation */
<span class="fc bfc" id="L199" title="All 2 branches covered.">            final int myLen = pPersonal == null ? 0 : pPersonal.length;</span>
<span class="fc" id="L200">            final byte[] myEnc = lengthEncode(myLen);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            thePersonal = pPersonal  == null</span>
<span class="fc" id="L202">                    ? new byte[myLen + myEnc.length]</span>
<span class="fc" id="L203">                    : Arrays.copyOf(pPersonal, myLen + myEnc.length);</span>
<span class="fc" id="L204">            System.arraycopy(myEnc, 0, thePersonal, myLen, myEnc.length);</span>
<span class="fc" id="L205">        }</span>

        @Override
        public int getByteLength() {
<span class="fc" id="L209">            return theTree.theRateBytes;</span>
        }

        @Override
        public int getDigestSize() {
            //return theXofLen == 0 ? theChainLen &gt;&gt; 1 : (int) theXofLen;
<span class="fc" id="L215">            return theChainLen &gt;&gt; 1;</span>
        }

        /**
         * Initialise the digest.
         * @param pParams the parameters
         */
        public void init(final GordianKeccakParameters pParams) {
            /* Build the new personalisation */
<span class="fc" id="L224">            buildPersonal(pParams.getPersonalisation());</span>

            /* Reset everything */
<span class="fc" id="L227">            reset();</span>
<span class="fc" id="L228">        }</span>

        @Override
        public void update(final byte pIn) {
<span class="fc" id="L232">            singleByte[0] = pIn;</span>
<span class="fc" id="L233">            update(singleByte, 0, 1);</span>
<span class="fc" id="L234">        }</span>

        @Override
        public void update(final byte[] pIn,
                           final int pInOff,
                           final int pLen) {
<span class="fc" id="L240">            processData(pIn, pInOff, pLen);</span>
<span class="fc" id="L241">        }</span>

        @Override
        public int doFinal(final byte[] pOut,
                           final int pOutOffset) {
            /* finalise the digest */
<span class="fc" id="L247">            return doFinal(pOut, pOutOffset, getDigestSize());</span>
        }

        @Override
        public int doFinal(final byte[] pOut,
                           final int pOutOffset,
                           final int pOutLen) {
            /* Build the required output */
<span class="fc" id="L255">            final int length = doOutput(pOut, pOutOffset, pOutLen);</span>

            /* reset the underlying digest and return the length */
<span class="fc" id="L258">            reset();</span>
<span class="fc" id="L259">            return length;</span>
        }

        @Override
        public int doOutput(final byte[] pOut,
                            final int pOutOffset,
                            final int pOutLen) {
            /* If we are not currently squeezing, switch to squeezing */
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (!squeezing) {</span>
<span class="fc" id="L268">                switchToSqueezing();</span>
            }

            /* Reject if there is insufficient Xof remaining */
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">            if (pOutLen &lt; 0) {</span>
<span class="nc" id="L273">                throw new IllegalArgumentException(&quot;Invalid output length&quot;);</span>
            }

            /* Squeeze out the data and return the length */
<span class="fc" id="L277">            theTree.squeeze(pOut, pOutOffset, pOutLen);</span>
<span class="fc" id="L278">            return pOutLen;</span>
        }

        /**
         * Process data.
         * @param pIn the input buffer
         * @param pInOffSet the starting offset in the input buffer
         * @param pLen the length of data to process
         */
        private void processData(final byte[] pIn,
                                 final int pInOffSet,
                                 final int pLen) {
            /* Check validity */
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">            if (squeezing) {</span>
<span class="nc" id="L292">                throw new IllegalStateException(&quot;attempt to absorb while squeezing&quot;);</span>
            }

            /* Determine current sponge */
<span class="fc bfc" id="L296" title="All 2 branches covered.">            final GordianKangarooSponge mySponge = theCurrNode == 0 ? theTree : theLeaf;</span>

            /* Determine space in current block */
<span class="fc" id="L299">            final int mySpace = BLKSIZE - theProcessed;</span>

            /* If all data can be processed by the current sponge*/
<span class="fc bfc" id="L302" title="All 2 branches covered.">            if (mySpace &gt;= pLen) {</span>
                /* Absorb and return */
<span class="fc" id="L304">                mySponge.absorb(pIn, pInOffSet, pLen);</span>
<span class="fc" id="L305">                theProcessed += pLen;</span>
<span class="fc" id="L306">                return;</span>
            }

            /* Absorb as much as possible into current sponge */
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            if (mySpace &gt; 0) {</span>
<span class="fc" id="L311">                mySponge.absorb(pIn, pInOffSet, mySpace);</span>
<span class="fc" id="L312">                theProcessed += mySpace;</span>
            }

            /* Loop while we have data remaining */
<span class="fc" id="L316">            int myProcessed = mySpace;</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">            while (myProcessed &lt; pLen) {</span>
                /* Switch Leaf if the current sponge is full */
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">                if (theProcessed == BLKSIZE) {</span>
<span class="fc" id="L320">                    switchLeaf(true);</span>
                }

                /* Process next block */
<span class="fc" id="L324">                final int myDataLen = Math.min(pLen - myProcessed, BLKSIZE);</span>
<span class="fc" id="L325">                theLeaf.absorb(pIn, pInOffSet + myProcessed, myDataLen);</span>
<span class="fc" id="L326">                theProcessed += myDataLen;</span>
<span class="fc" id="L327">                myProcessed += myDataLen;</span>
<span class="fc" id="L328">            }</span>
<span class="fc" id="L329">        }</span>

        @Override
        public void reset() {
<span class="fc" id="L333">            theTree.initSponge();</span>
<span class="fc" id="L334">            theLeaf.initSponge();</span>
<span class="fc" id="L335">            theCurrNode = 0;</span>
<span class="fc" id="L336">            theProcessed = 0;</span>
<span class="fc" id="L337">            squeezing = false;</span>
<span class="fc" id="L338">        }</span>

        /**
         * Complete Leaf.
         * @param pMoreToCome is there more data to come? true/false
         */
        private void switchLeaf(final boolean pMoreToCome) {
            /* If we are the first node */
<span class="fc bfc" id="L346" title="All 2 branches covered.">            if (theCurrNode == 0) {</span>
                /* Absorb the padding */
<span class="fc" id="L348">                theTree.absorb(FIRST, 0, FIRST.length);</span>

                /* else intermediate node */
            } else {
                /* Absorb intermediate node marker */
<span class="fc" id="L353">                theLeaf.absorb(INTERMEDIATE, 0, INTERMEDIATE.length);</span>

                /* Complete the node */
<span class="fc" id="L356">                final byte[] myHash = new byte[theChainLen];</span>
<span class="fc" id="L357">                theLeaf.squeeze(myHash, 0, theChainLen);</span>
<span class="fc" id="L358">                theTree.absorb(myHash, 0, theChainLen);</span>

                /* Re-init the leaf */
<span class="fc" id="L361">                theLeaf.initSponge();</span>
            }

            /* Switch to next node */
<span class="fc bfc" id="L365" title="All 2 branches covered.">            if (pMoreToCome) {</span>
<span class="fc" id="L366">                theCurrNode++;</span>
            }
<span class="fc" id="L368">            theProcessed = 0;</span>
<span class="fc" id="L369">        }</span>

        /**
         * Switch to squeezing.
         */
        private void switchToSqueezing() {
            /* Absorb the personalisation */
<span class="fc" id="L376">            processData(thePersonal, 0, thePersonal.length);</span>

            /* Complete the absorption */
<span class="fc bfc" id="L379" title="All 2 branches covered.">            if (theCurrNode == 0) {</span>
<span class="fc" id="L380">                switchSingle();</span>
            } else {
<span class="fc" id="L382">                switchFinal();</span>
            }

            /* Set flag */
<span class="fc" id="L386">            squeezing = true;</span>
<span class="fc" id="L387">        }</span>

        /**
         * Switch single node to squeezing.
         */
        private void switchSingle() {
            /* Absorb single node marker */
<span class="fc" id="L394">            theTree.absorb(SINGLE, 0, 1);</span>

            /* Switch to squeezing */
<span class="fc" id="L397">            theTree.padAndSwitchToSqueezingPhase();</span>
<span class="fc" id="L398">        }</span>

        /**
         * Switch multiple node to squeezing.
         */
        private void switchFinal() {
            /* Complete the current leaf */
<span class="fc" id="L405">            switchLeaf(false);</span>

            /* Absorb length */
<span class="fc" id="L408">            final byte[] myLength = lengthEncode(theCurrNode);</span>
<span class="fc" id="L409">            theTree.absorb(myLength, 0, myLength.length);</span>

            /* Absorb final node marker */
<span class="fc" id="L412">            theTree.absorb(FINAL, 0, FINAL.length);</span>

            /* Switch to squeezing */
<span class="fc" id="L415">            theTree.padAndSwitchToSqueezingPhase();</span>
<span class="fc" id="L416">        }</span>

        /**
         * right Encode a length.
         * @param strLen the length to encode
         * @return the encoded length
         */
        private static byte[] lengthEncode(final long strLen) {
            /* Calculate # of bytes required to hold length */
<span class="fc" id="L425">            byte n = 0;</span>
<span class="fc" id="L426">            long v = strLen;</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">            if (v != 0) {</span>
<span class="fc" id="L428">                n = 1;</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">                while ((v &gt;&gt;= Byte.SIZE) != 0) {</span>
<span class="fc" id="L430">                    n++;</span>
                }
            }

            /* Allocate byte array and store length */
<span class="fc" id="L435">            final byte[] b = new byte[n + 1];</span>
<span class="fc" id="L436">            b[n] = n;</span>

            /* Encode the length */
<span class="fc bfc" id="L439" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L440">                b[i] = (byte) (strLen &gt;&gt; (Byte.SIZE * (n - i - 1)));</span>
            }

            /* Return the encoded length */
<span class="fc" id="L444">            return b;</span>
        }
    }

    /**
     * The Kangaroo Sponge.
     */
    @SuppressWarnings(&quot;checkstyle:MagicNumber&quot;)
    private static class GordianKangarooSponge {
        /**
         * The round constants.
         */
<span class="fc" id="L456">        private static long[] keccakRoundConstants = {</span>
                0x0000000000000001L, 0x0000000000008082L,
                0x800000000000808aL, 0x8000000080008000L, 0x000000000000808bL, 0x0000000080000001L, 0x8000000080008081L,
                0x8000000000008009L, 0x000000000000008aL, 0x0000000000000088L, 0x0000000080008009L, 0x000000008000000aL,
                0x000000008000808bL, 0x800000000000008bL, 0x8000000000008089L, 0x8000000000008003L, 0x8000000000008002L,
                0x8000000000000080L, 0x000000000000800aL, 0x800000008000000aL, 0x8000000080008081L, 0x8000000000008080L,
                0x0000000080000001L, 0x8000000080008008L
        };

        /**
         * The number of rounds.
         */
        private final int theRounds;

        /**
         * The rateBytes.
         */
        private final int theRateBytes;

        /**
         * The state.
         */
<span class="fc" id="L478">        private final long[] theState = new long[25];</span>

        /**
         * The queue.
         */
        private final byte[] theQueue;

        /**
         * The numnber of bytes in the queue.
         */
        private int bytesInQueue;

        /**
         * Are we squeezing?
         */
        private boolean squeezing;

        /**
         * Constructor.
         * @param pStrength the strength
         * @param pRounds the rounds.
         */
        GordianKangarooSponge(final int pStrength,
<span class="fc" id="L501">                              final int pRounds) {</span>
<span class="fc" id="L502">            theRateBytes = (1600 - (pStrength &lt;&lt; 1)) &gt;&gt; 3;</span>
<span class="fc" id="L503">            theRounds = pRounds;</span>
<span class="fc" id="L504">            theQueue = new byte[theRateBytes];</span>
<span class="fc" id="L505">            initSponge();</span>
<span class="fc" id="L506">        }</span>

        /**
         * Initialise the sponge.
         */
        private void initSponge() {
<span class="fc" id="L512">            Arrays.fill(theState, 0L);</span>
<span class="fc" id="L513">            Arrays.fill(theQueue, (byte) 0);</span>
<span class="fc" id="L514">            bytesInQueue = 0;</span>
<span class="fc" id="L515">            squeezing = false;</span>
<span class="fc" id="L516">        }</span>

        /**
         * Absorb data into sponge.
         * @param data the data buffer
         * @param off the starting offset in the buffer.
         * @param len the length of data to absorb
         */
        private void absorb(final byte[] data,
                            final int off,
                            final int len) {
            /* Sanity checks */
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">            if (squeezing) {</span>
<span class="nc" id="L529">                throw new IllegalStateException(&quot;attempt to absorb while squeezing&quot;);</span>
            }

            /* Loop through bytes */
<span class="fc" id="L533">            int count = 0;</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">            while (count &lt; len) {</span>
                /* Handle full buffer */
<span class="fc bfc" id="L536" title="All 2 branches covered.">                if (bytesInQueue == theRateBytes) {</span>
<span class="fc" id="L537">                    kangarooAbsorb(theQueue, 0);</span>
<span class="fc" id="L538">                    bytesInQueue = 0;</span>
                }

                /* If we have full blocks */
<span class="fc bfc" id="L542" title="All 4 branches covered.">                if (bytesInQueue == 0 &amp;&amp; count &lt;= (len - theRateBytes)) {</span>
                    /* Process full blocks */
                    do {
<span class="fc" id="L545">                        kangarooAbsorb(data, off + count);</span>
<span class="fc" id="L546">                        count += theRateBytes;</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">                    } while (count &lt;= (len - theRateBytes));</span>

                    /* else process partial blocks */
                } else {
<span class="fc" id="L551">                    final int partialBlock = Math.min(theRateBytes - bytesInQueue, len - count);</span>
<span class="fc" id="L552">                    System.arraycopy(data, off + count, theQueue, bytesInQueue, partialBlock);</span>

<span class="fc" id="L554">                    bytesInQueue += partialBlock;</span>
<span class="fc" id="L555">                    count += partialBlock;</span>
<span class="fc" id="L556">                }</span>
            }
<span class="fc" id="L558">        }</span>

        /**
         * Handle padding.
         */
        private void padAndSwitchToSqueezingPhase() {
            /* Fill any remaining space in queue with zeroes */
<span class="fc bfc" id="L565" title="All 2 branches covered.">            for (int i = bytesInQueue; i &lt; theRateBytes; i++) {</span>
<span class="fc" id="L566">                theQueue[i] = 0;</span>
            }
<span class="fc" id="L568">            theQueue[theRateBytes - 1] ^= 0x80;</span>
<span class="fc" id="L569">            kangarooAbsorb(theQueue, 0);</span>

<span class="fc" id="L571">            kangarooExtract();</span>
<span class="fc" id="L572">            bytesInQueue = theRateBytes;</span>
<span class="fc" id="L573">            squeezing = true;</span>
<span class="fc" id="L574">        }</span>

        /**
         * Squeeze data out.
         * @param output the output buffer
         * @param offset the offset in the output buffer
         * @param outputLength the output length
         */
        private void squeeze(final byte[] output,
                             final int offset,
                             final int outputLength) {
<span class="fc bfc" id="L585" title="All 2 branches covered.">            if (!squeezing) {</span>
<span class="fc" id="L586">                padAndSwitchToSqueezingPhase();</span>
            }

<span class="fc" id="L589">            int i = 0;</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">            while (i &lt; outputLength) {</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">                if (bytesInQueue == 0) {</span>
<span class="fc" id="L592">                    kangarooPermutation();</span>
<span class="fc" id="L593">                    kangarooExtract();</span>
<span class="fc" id="L594">                    bytesInQueue = theRateBytes;</span>
                }
<span class="fc" id="L596">                final int partialBlock = Math.min(bytesInQueue, outputLength - i);</span>
<span class="fc" id="L597">                System.arraycopy(theQueue, theRateBytes - bytesInQueue, output, offset + i, partialBlock);</span>
<span class="fc" id="L598">                bytesInQueue -= partialBlock;</span>
<span class="fc" id="L599">                i += partialBlock;</span>
<span class="fc" id="L600">            }</span>
<span class="fc" id="L601">        }</span>

        /**
         * Absorb a block of data.
         * @param data the data to absorb
         * @param off the starting offset in the data
         */
        private void kangarooAbsorb(final byte[] data,
                                    final int off) {
<span class="fc" id="L610">            final int count = theRateBytes &gt;&gt; 3;</span>
<span class="fc" id="L611">            int offSet = off;</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">            for (int i = 0; i &lt; count; ++i) {</span>
<span class="fc" id="L613">                theState[i] ^= Pack.littleEndianToLong(data, offSet);</span>
<span class="fc" id="L614">                offSet += 8;</span>
            }

<span class="fc" id="L617">            kangarooPermutation();</span>
<span class="fc" id="L618">        }</span>

        /**
         * Extract a block of data to the queue.
         */
        private void kangarooExtract() {
<span class="fc" id="L624">            Pack.longToLittleEndian(theState, 0, theRateBytes &gt;&gt; 3, theQueue, 0);</span>
<span class="fc" id="L625">        }</span>

        /**
         * Permutation (KP).
         */
        private void kangarooPermutation() {
<span class="fc" id="L631">            final long[] a = theState;</span>

<span class="fc" id="L633">            long a00 = a[ 0];</span>
<span class="fc" id="L634">            long a01 = a[ 1];</span>
<span class="fc" id="L635">            long a02 = a[ 2];</span>
<span class="fc" id="L636">            long a03 = a[ 3];</span>
<span class="fc" id="L637">            long a04 = a[ 4];</span>
<span class="fc" id="L638">            long a05 = a[ 5];</span>
<span class="fc" id="L639">            long a06 = a[ 6];</span>
<span class="fc" id="L640">            long a07 = a[ 7];</span>
<span class="fc" id="L641">            long a08 = a[ 8];</span>
<span class="fc" id="L642">            long a09 = a[ 9];</span>
<span class="fc" id="L643">            long a10 = a[10];</span>
<span class="fc" id="L644">            long a11 = a[11];</span>
<span class="fc" id="L645">            long a12 = a[12];</span>
<span class="fc" id="L646">            long a13 = a[13];</span>
<span class="fc" id="L647">            long a14 = a[14];</span>
<span class="fc" id="L648">            long a15 = a[15];</span>
<span class="fc" id="L649">            long a16 = a[16];</span>
<span class="fc" id="L650">            long a17 = a[17];</span>
<span class="fc" id="L651">            long a18 = a[18];</span>
<span class="fc" id="L652">            long a19 = a[19];</span>
<span class="fc" id="L653">            long a20 = a[20];</span>
<span class="fc" id="L654">            long a21 = a[21];</span>
<span class="fc" id="L655">            long a22 = a[22];</span>
<span class="fc" id="L656">            long a23 = a[23];</span>
<span class="fc" id="L657">            long a24 = a[24];</span>

<span class="fc" id="L659">            final int myBase = keccakRoundConstants.length - theRounds;</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">            for (int i = 0; i &lt; theRounds; i++) {</span>
                // theta
<span class="fc" id="L662">                long c0 = a00 ^ a05 ^ a10 ^ a15 ^ a20;</span>
<span class="fc" id="L663">                long c1 = a01 ^ a06 ^ a11 ^ a16 ^ a21;</span>
<span class="fc" id="L664">                final long c2 = a02 ^ a07 ^ a12 ^ a17 ^ a22;</span>
<span class="fc" id="L665">                final long c3 = a03 ^ a08 ^ a13 ^ a18 ^ a23;</span>
<span class="fc" id="L666">                final long c4 = a04 ^ a09 ^ a14 ^ a19 ^ a24;</span>

<span class="fc" id="L668">                final long d1 = (c1 &lt;&lt; 1 | c1 &gt;&gt;&gt; -1) ^ c4;</span>
<span class="fc" id="L669">                final long d2 = (c2 &lt;&lt; 1 | c2 &gt;&gt;&gt; -1) ^ c0;</span>
<span class="fc" id="L670">                final long d3 = (c3 &lt;&lt; 1 | c3 &gt;&gt;&gt; -1) ^ c1;</span>
<span class="fc" id="L671">                final long d4 = (c4 &lt;&lt; 1 | c4 &gt;&gt;&gt; -1) ^ c2;</span>
<span class="fc" id="L672">                final long d0 = (c0 &lt;&lt; 1 | c0 &gt;&gt;&gt; -1) ^ c3;</span>

<span class="fc" id="L674">                a00 ^= d1;</span>
<span class="fc" id="L675">                a05 ^= d1;</span>
<span class="fc" id="L676">                a10 ^= d1;</span>
<span class="fc" id="L677">                a15 ^= d1;</span>
<span class="fc" id="L678">                a20 ^= d1;</span>
<span class="fc" id="L679">                a01 ^= d2;</span>
<span class="fc" id="L680">                a06 ^= d2;</span>
<span class="fc" id="L681">                a11 ^= d2;</span>
<span class="fc" id="L682">                a16 ^= d2;</span>
<span class="fc" id="L683">                a21 ^= d2;</span>
<span class="fc" id="L684">                a02 ^= d3;</span>
<span class="fc" id="L685">                a07 ^= d3;</span>
<span class="fc" id="L686">                a12 ^= d3;</span>
<span class="fc" id="L687">                a17 ^= d3;</span>
<span class="fc" id="L688">                a22 ^= d3;</span>
<span class="fc" id="L689">                a03 ^= d4;</span>
<span class="fc" id="L690">                a08 ^= d4;</span>
<span class="fc" id="L691">                a13 ^= d4;</span>
<span class="fc" id="L692">                a18 ^= d4;</span>
<span class="fc" id="L693">                a23 ^= d4;</span>
<span class="fc" id="L694">                a04 ^= d0;</span>
<span class="fc" id="L695">                a09 ^= d0;</span>
<span class="fc" id="L696">                a14 ^= d0;</span>
<span class="fc" id="L697">                a19 ^= d0;</span>
<span class="fc" id="L698">                a24 ^= d0;</span>

                // rho/pi
<span class="fc" id="L701">                c1  = a01 &lt;&lt;  1 | a01 &gt;&gt;&gt; 63;</span>
<span class="fc" id="L702">                a01 = a06 &lt;&lt; 44 | a06 &gt;&gt;&gt; 20;</span>
<span class="fc" id="L703">                a06 = a09 &lt;&lt; 20 | a09 &gt;&gt;&gt; 44;</span>
<span class="fc" id="L704">                a09 = a22 &lt;&lt; 61 | a22 &gt;&gt;&gt;  3;</span>
<span class="fc" id="L705">                a22 = a14 &lt;&lt; 39 | a14 &gt;&gt;&gt; 25;</span>
<span class="fc" id="L706">                a14 = a20 &lt;&lt; 18 | a20 &gt;&gt;&gt; 46;</span>
<span class="fc" id="L707">                a20 = a02 &lt;&lt; 62 | a02 &gt;&gt;&gt;  2;</span>
<span class="fc" id="L708">                a02 = a12 &lt;&lt; 43 | a12 &gt;&gt;&gt; 21;</span>
<span class="fc" id="L709">                a12 = a13 &lt;&lt; 25 | a13 &gt;&gt;&gt; 39;</span>
<span class="fc" id="L710">                a13 = a19 &lt;&lt;  8 | a19 &gt;&gt;&gt; 56;</span>
<span class="fc" id="L711">                a19 = a23 &lt;&lt; 56 | a23 &gt;&gt;&gt;  8;</span>
<span class="fc" id="L712">                a23 = a15 &lt;&lt; 41 | a15 &gt;&gt;&gt; 23;</span>
<span class="fc" id="L713">                a15 = a04 &lt;&lt; 27 | a04 &gt;&gt;&gt; 37;</span>
<span class="fc" id="L714">                a04 = a24 &lt;&lt; 14 | a24 &gt;&gt;&gt; 50;</span>
<span class="fc" id="L715">                a24 = a21 &lt;&lt;  2 | a21 &gt;&gt;&gt; 62;</span>
<span class="fc" id="L716">                a21 = a08 &lt;&lt; 55 | a08 &gt;&gt;&gt;  9;</span>
<span class="fc" id="L717">                a08 = a16 &lt;&lt; 45 | a16 &gt;&gt;&gt; 19;</span>
<span class="fc" id="L718">                a16 = a05 &lt;&lt; 36 | a05 &gt;&gt;&gt; 28;</span>
<span class="fc" id="L719">                a05 = a03 &lt;&lt; 28 | a03 &gt;&gt;&gt; 36;</span>
<span class="fc" id="L720">                a03 = a18 &lt;&lt; 21 | a18 &gt;&gt;&gt; 43;</span>
<span class="fc" id="L721">                a18 = a17 &lt;&lt; 15 | a17 &gt;&gt;&gt; 49;</span>
<span class="fc" id="L722">                a17 = a11 &lt;&lt; 10 | a11 &gt;&gt;&gt; 54;</span>
<span class="fc" id="L723">                a11 = a07 &lt;&lt;  6 | a07 &gt;&gt;&gt; 58;</span>
<span class="fc" id="L724">                a07 = a10 &lt;&lt;  3 | a10 &gt;&gt;&gt; 61;</span>
<span class="fc" id="L725">                a10 = c1;</span>

                // chi
<span class="fc" id="L728">                c0 = a00 ^ (~a01 &amp; a02);</span>
<span class="fc" id="L729">                c1 = a01 ^ (~a02 &amp; a03);</span>
<span class="fc" id="L730">                a02 ^= ~a03 &amp; a04;</span>
<span class="fc" id="L731">                a03 ^= ~a04 &amp; a00;</span>
<span class="fc" id="L732">                a04 ^= ~a00 &amp; a01;</span>
<span class="fc" id="L733">                a00 = c0;</span>
<span class="fc" id="L734">                a01 = c1;</span>

<span class="fc" id="L736">                c0 = a05 ^ (~a06 &amp; a07);</span>
<span class="fc" id="L737">                c1 = a06 ^ (~a07 &amp; a08);</span>
<span class="fc" id="L738">                a07 ^= ~a08 &amp; a09;</span>
<span class="fc" id="L739">                a08 ^= ~a09 &amp; a05;</span>
<span class="fc" id="L740">                a09 ^= ~a05 &amp; a06;</span>
<span class="fc" id="L741">                a05 = c0;</span>
<span class="fc" id="L742">                a06 = c1;</span>

<span class="fc" id="L744">                c0 = a10 ^ (~a11 &amp; a12);</span>
<span class="fc" id="L745">                c1 = a11 ^ (~a12 &amp; a13);</span>
<span class="fc" id="L746">                a12 ^= ~a13 &amp; a14;</span>
<span class="fc" id="L747">                a13 ^= ~a14 &amp; a10;</span>
<span class="fc" id="L748">                a14 ^= ~a10 &amp; a11;</span>
<span class="fc" id="L749">                a10 = c0;</span>
<span class="fc" id="L750">                a11 = c1;</span>

<span class="fc" id="L752">                c0 = a15 ^ (~a16 &amp; a17);</span>
<span class="fc" id="L753">                c1 = a16 ^ (~a17 &amp; a18);</span>
<span class="fc" id="L754">                a17 ^= ~a18 &amp; a19;</span>
<span class="fc" id="L755">                a18 ^= ~a19 &amp; a15;</span>
<span class="fc" id="L756">                a19 ^= ~a15 &amp; a16;</span>
<span class="fc" id="L757">                a15 = c0;</span>
<span class="fc" id="L758">                a16 = c1;</span>

<span class="fc" id="L760">                c0 = a20 ^ (~a21 &amp; a22);</span>
<span class="fc" id="L761">                c1 = a21 ^ (~a22 &amp; a23);</span>
<span class="fc" id="L762">                a22 ^= ~a23 &amp; a24;</span>
<span class="fc" id="L763">                a23 ^= ~a24 &amp; a20;</span>
<span class="fc" id="L764">                a24 ^= ~a20 &amp; a21;</span>
<span class="fc" id="L765">                a20 = c0;</span>
<span class="fc" id="L766">                a21 = c1;</span>

                // iota
<span class="fc" id="L769">                a00 ^= keccakRoundConstants[myBase + i];</span>
            }

<span class="fc" id="L772">            a[ 0] = a00;</span>
<span class="fc" id="L773">            a[ 1] = a01;</span>
<span class="fc" id="L774">            a[ 2] = a02;</span>
<span class="fc" id="L775">            a[ 3] = a03;</span>
<span class="fc" id="L776">            a[ 4] = a04;</span>
<span class="fc" id="L777">            a[ 5] = a05;</span>
<span class="fc" id="L778">            a[ 6] = a06;</span>
<span class="fc" id="L779">            a[ 7] = a07;</span>
<span class="fc" id="L780">            a[ 8] = a08;</span>
<span class="fc" id="L781">            a[ 9] = a09;</span>
<span class="fc" id="L782">            a[10] = a10;</span>
<span class="fc" id="L783">            a[11] = a11;</span>
<span class="fc" id="L784">            a[12] = a12;</span>
<span class="fc" id="L785">            a[13] = a13;</span>
<span class="fc" id="L786">            a[14] = a14;</span>
<span class="fc" id="L787">            a[15] = a15;</span>
<span class="fc" id="L788">            a[16] = a16;</span>
<span class="fc" id="L789">            a[17] = a17;</span>
<span class="fc" id="L790">            a[18] = a18;</span>
<span class="fc" id="L791">            a[19] = a19;</span>
<span class="fc" id="L792">            a[20] = a20;</span>
<span class="fc" id="L793">            a[21] = a21;</span>
<span class="fc" id="L794">            a[22] = a22;</span>
<span class="fc" id="L795">            a[23] = a23;</span>
<span class="fc" id="L796">            a[24] = a24;</span>
<span class="fc" id="L797">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
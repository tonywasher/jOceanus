<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianBlake3Digest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.ext.digests</a> &gt; <span class="el_source">GordianBlake3Digest.java</span></div><h1>GordianBlake3Digest.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.ext.digests;

import net.sourceforge.joceanus.gordianknot.impl.ext.params.GordianBlake3Parameters;

import org.bouncycastle.crypto.ExtendedDigest;
import org.bouncycastle.crypto.Xof;
import org.bouncycastle.util.Memoable;
import org.bouncycastle.util.Pack;

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;

/**
 * Blake3 implementation. Donated to BouncyCastle.
 */
public class GordianBlake3Digest
        implements ExtendedDigest, Memoable, Xof {
    /**
     * Already outputting error.
     */
    private static final String ERR_OUTPUTTING = &quot;Already outputting&quot;;

    /**
     * Number of Words.
     */
    private static final int NUMWORDS = 8;

    /**
     * Number of Rounds.
     */
    private static final int ROUNDS = 7;

    /**
     * Buffer length.
     */
    private static final int BLOCKLEN = NUMWORDS * Integer.BYTES * 2;

    /**
     * Chunk length.
     */
    private static final int CHUNKLEN = 1024;

    /**
     * ChunkStart Flag.
     */
    private static final int CHUNKSTART    = 0b00000001;

    /**
     * ChunkEnd Flag.
     */
    private static final int CHUNKEND      = 0b00000010;

    /**
     * Parent Flag.
     */
    private static final int PARENT        = 0b00000100;

    /**
     * Root Flag.
     */
    private static final int ROOT          = 0b00001000;

    /**
     * KeyedHash Flag.
     */
    private static final int KEYEDHASH     = 0b00010000;

    /**
     * DeriveContext Flag.
     */
    private static final int DERIVECONTEXT = 0b00100000;

    /**
     * DeriveKey Flag.
     */
    private static final int DERIVEKEY     = 0b01000000;

    /**
     * Chaining0 State Locations.
     */
    private static final int CHAINING0 = 0;

    /**
     * Chaining1 State Location.
     */
    private static final int CHAINING1 = 1;

    /**
     * Chaining2 State Location.
     */
    private static final int CHAINING2 = 2;

    /**
     * Chaining3 State Location.
     */
    private static final int CHAINING3 = 3;

    /**
     * Chaining4 State Location.
     */
    private static final int CHAINING4 = 4;

    /**
     * Chaining5 State Location.
     */
    private static final int CHAINING5 = 5;

    /**
     * Chaining6 State Location.
     */
    private static final int CHAINING6 = 6;

    /**
     * Chaining7 State Location.
     */
    private static final int CHAINING7 = 7;

    /**
     * IV0 State Locations.
     */
    private static final int IV0       = 8;

    /**
     * IV1 State Location.
     */
    private static final int IV1       = 9;

    /**
     * IV2 State Location.
     */
    private static final int IV2       = 10;

    /**
     * IV3 State Location.
     */
    private static final int IV3       = 11;

    /**
     * Count0 State Location.
     */
    private static final int COUNT0    = 12;

    /**
     * Count1 State Location.
     */
    private static final int COUNT1    = 13;

    /**
     * DataLen State Location.
     */
    private static final int DATALEN   = 14;

    /**
     * Flags State Location.
     */
    private static final int FLAGS     = 15;

    /**
     * Message word permutations.
     */
<span class="fc" id="L178">    private static final byte[] SIGMA = { 2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8 };</span>

    /**
     * Rotation constants.
     */
<span class="fc" id="L183">    private static final byte[] ROTATE = { 16, 12, 8, 7 };</span>

    /**
     * Blake3 Initialization Vector.
     */
<span class="fc" id="L188">    private static final int[] IV = {</span>
            0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    };

    /**
     * The byte input/output buffer.
     */
<span class="fc" id="L195">    private final byte[] theBuffer = new byte[BLOCKLEN];</span>

    /**
     * The key.
     */
<span class="fc" id="L200">    private final int[] theK = new int[NUMWORDS];</span>

    /**
     * The chaining value.
     */
<span class="fc" id="L205">    private final int[] theChaining = new int[NUMWORDS];</span>

    /**
     * The state.
     */
<span class="fc" id="L210">    private final int[] theV = new int[NUMWORDS &lt;&lt; 1];</span>

    /**
     * The message Buffer.
     */
<span class="fc" id="L215">    private final int[] theM = new int[NUMWORDS &lt;&lt; 1];</span>

    /**
     * The indices.
     */
<span class="fc" id="L220">    private final byte[] theIndices = new byte[NUMWORDS &lt;&lt; 1];</span>

    /**
     * The chainingStack.
     */
<span class="fc" id="L225">    private final Deque&lt;int[]&gt; theStack = new ArrayDeque&lt;&gt;();</span>

    /**
     * The default digestLength.
     */
    private final int theDigestLen;

    /**
     * Are we outputting?
     */
    private boolean outputting;

    /**
     * How many more bytes can we output?
     */
    private long outputAvailable;

    /**
     * The current mode.
     */
    private int theMode;

    /**
     * The output mode.
     */
    private int theOutputMode;

    /**
     * The output dataLen.
     */
    private int theOutputDataLen;

    /**
     * The block counter.
     */
    private long theCounter;

    /**
     * The # of bytes in the current block.
     */
    private int theCurrBytes;

    /**
     * The position of the next byte in the buffer.
     */
    private int thePos;

    /**
     * Constructor.
     */
    public GordianBlake3Digest() {
<span class="fc" id="L276">        this(BLOCKLEN &gt;&gt; 1);</span>
<span class="fc" id="L277">    }</span>

    /**
     * Constructor.
     * @param pDigestLen the default digestLength
     */
<span class="fc" id="L283">    public GordianBlake3Digest(final int pDigestLen) {</span>
<span class="fc" id="L284">        theDigestLen = pDigestLen;</span>
<span class="fc" id="L285">        init(null);</span>
<span class="fc" id="L286">    }</span>

    /**
     * Constructor.
     * @param pSource the source digest.
     */
<span class="fc" id="L292">    private GordianBlake3Digest(final GordianBlake3Digest pSource) {</span>
        /* Copy default digest length */
<span class="fc" id="L294">        theDigestLen = pSource.theDigestLen;</span>

        /* Initialise from source */
<span class="fc" id="L297">        reset(pSource);</span>
<span class="fc" id="L298">    }</span>

    @Override
    public int getByteLength() {
<span class="fc" id="L302">        return BLOCKLEN;</span>
    }

    @Override
    public String getAlgorithmName() {
<span class="fc" id="L307">        return &quot;BLAKE3&quot;;</span>
    }

    @Override
    public int getDigestSize() {
<span class="fc" id="L312">        return theDigestLen;</span>
    }

    /**
     * Initialise.
     * @param pParams the parameters.
     */
    public void init(final GordianBlake3Parameters pParams) {
        /* Access key/context */
<span class="fc bfc" id="L321" title="All 2 branches covered.">        final byte[] myKey = pParams == null ? null : pParams.getKey();</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        final byte[] myContext = pParams == null ? null : pParams.getContext();</span>

        /* Reset the digest */
<span class="fc" id="L325">        reset();</span>

        /* If we have a key  */
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (myKey != null) {</span>
            /* Initialise with the key */
<span class="fc" id="L330">            initKey(myKey);</span>
<span class="fc" id="L331">            Arrays.fill(myKey, (byte) 0);</span>

            /* else if we have a context */
<span class="fc bfc" id="L334" title="All 2 branches covered.">        } else if (myContext != null) {</span>
            /* Initialise for deriving context */
<span class="fc" id="L336">            initNullKey();</span>
<span class="fc" id="L337">            theMode = DERIVECONTEXT;</span>

            /* Derive key from context */
<span class="fc" id="L340">            update(myContext, 0, myContext.length);</span>
<span class="fc" id="L341">            doFinal(theBuffer, 0);</span>
<span class="fc" id="L342">            initKeyFromContext();</span>
<span class="fc" id="L343">            reset();</span>

            /* Else init null key and reset mode */
        } else {
<span class="fc" id="L347">            initNullKey();</span>
<span class="fc" id="L348">            theMode = 0;</span>
        }
<span class="fc" id="L350">    }</span>

    @Override
    public void update(final byte b) {
        /* Check that we are not outputting */
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        if (outputting) {</span>
<span class="nc" id="L356">            throw new IllegalStateException(ERR_OUTPUTTING);</span>
        }

        /* If the buffer is full */
<span class="fc" id="L360">        final int blockLen = theBuffer.length;</span>
<span class="fc" id="L361">        final int remainingLength = blockLen - thePos;</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        if (remainingLength == 0) {</span>
            /* Process the buffer */
<span class="nc" id="L364">            compressBlock(theBuffer, 0);</span>

            /* Reset the buffer */
<span class="nc" id="L367">            Arrays.fill(theBuffer, (byte) 0);</span>
<span class="nc" id="L368">            thePos = 0;</span>
        }

        /* Store the byte */
<span class="fc" id="L372">        theBuffer[thePos] = b;</span>
<span class="fc" id="L373">        thePos++;</span>
<span class="fc" id="L374">    }</span>

    @Override
    public void update(final byte[] pMessage,
                       final int pOffset,
                       final int pLen) {
        /* Ignore null operation */
<span class="pc bpc" id="L381" title="1 of 4 branches missed.">        if (pMessage == null || pLen == 0) {</span>
<span class="fc" id="L382">            return;</span>
        }

        /* Check that we are not outputting */
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        if (outputting) {</span>
<span class="nc" id="L387">            throw new IllegalStateException(ERR_OUTPUTTING);</span>
        }

        /* Process any bytes currently in the buffer */
<span class="fc" id="L391">        int remainingLen = 0; // left bytes of buffer</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (thePos != 0) {</span>
            /* Calculate space remaining in the buffer */
<span class="fc" id="L394">            remainingLen = BLOCKLEN - thePos;</span>

            /* If there is sufficient space in the buffer */
<span class="fc bfc" id="L397" title="All 2 branches covered.">            if (remainingLen &gt;= pLen) {</span>
                /* Copy data into byffer and return */
<span class="fc" id="L399">                System.arraycopy(pMessage, pOffset, theBuffer, thePos, pLen);</span>
<span class="fc" id="L400">                thePos += pLen;</span>
<span class="fc" id="L401">                return;</span>
            }

            /* Fill the buffer */
<span class="fc" id="L405">            System.arraycopy(pMessage, pOffset, theBuffer, thePos, remainingLen);</span>

            /* Process the buffer */
<span class="fc" id="L408">            compressBlock(theBuffer, 0);</span>

            /* Reset the buffer */
<span class="fc" id="L411">            thePos = 0;</span>
<span class="fc" id="L412">            Arrays.fill(theBuffer, (byte) 0);</span>
        }

        /* process all blocks except the last one */
        int messagePos;
<span class="fc" id="L417">        final int blockWiseLastPos = pOffset + pLen - BLOCKLEN;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">        for (messagePos = pOffset + remainingLen; messagePos &lt; blockWiseLastPos; messagePos += BLOCKLEN) {</span>
            /* Process the buffer */
<span class="fc" id="L420">            compressBlock(pMessage, messagePos);</span>
        }

        /* Fill the buffer with the remaining bytes of the message */
<span class="fc" id="L424">        final int len = pLen - messagePos;</span>
<span class="fc" id="L425">        System.arraycopy(pMessage, messagePos, theBuffer, 0, pOffset + len);</span>
<span class="fc" id="L426">        thePos += pOffset + len;</span>
<span class="fc" id="L427">    }</span>

    @Override
    public int doFinal(final byte[] pOutput,
                       final int pOutOffset) {
<span class="fc" id="L432">        return doFinal(pOutput, pOutOffset, getDigestSize());</span>
    }

    @Override
    public int doFinal(final byte[] pOut,
                       final int pOutOffset,
                       final int pOutLen) {
        /* Build the required output */
<span class="fc" id="L440">        final int length = doOutput(pOut, pOutOffset, pOutLen);</span>

        /* reset the underlying digest and return the length */
<span class="fc" id="L443">        reset();</span>
<span class="fc" id="L444">        return length;</span>
    }

    @Override
    public int doOutput(final byte[] pOut,
                        final int pOutOffset,
                        final int pOutLen) {
        /* If we have not started outputting yet */
<span class="fc bfc" id="L452" title="All 2 branches covered.">        if (!outputting) {</span>
            /* Process the buffer */
<span class="fc" id="L454">            compressFinalBlock(thePos);</span>
        }

        /* Reject if there is insufficient Xof remaining */
<span class="pc bpc" id="L458" title="4 of 6 branches missed.">        if (pOutLen &lt; 0</span>
                || (outputAvailable &gt;= 0 &amp;&amp; pOutLen &gt; outputAvailable)) {
<span class="nc" id="L460">            throw new IllegalArgumentException(&quot;Insufficient bytes remaining&quot;);</span>
        }

        /* If we have some remaining data in the current buffer */
<span class="fc" id="L464">        int dataLeft = pOutLen;</span>
<span class="fc" id="L465">        int outPos = pOutOffset;</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">        if (thePos &lt; BLOCKLEN) {</span>
            /* Copy data from current hash */
<span class="fc" id="L468">            final int dataToCopy = Math.min(dataLeft, BLOCKLEN - thePos);</span>
<span class="fc" id="L469">            System.arraycopy(theBuffer, thePos, pOut, outPos, dataToCopy);</span>

            /* Adjust counters */
<span class="fc" id="L472">            thePos += dataToCopy;</span>
<span class="fc" id="L473">            outPos += dataToCopy;</span>
<span class="fc" id="L474">            dataLeft -= dataToCopy;</span>
        }

        /* Loop until we have completed the request */
<span class="fc bfc" id="L478" title="All 2 branches covered.">        while (dataLeft &gt; 0) {</span>
            /* Calculate the next block */
<span class="fc" id="L480">            nextOutputBlock();</span>

            /* Copy data from current hash */
<span class="fc" id="L483">            final int dataToCopy = Math.min(dataLeft, BLOCKLEN);</span>
<span class="fc" id="L484">            System.arraycopy(theBuffer, 0, pOut, outPos, dataToCopy);</span>

            /* Adjust counters */
<span class="fc" id="L487">            thePos += dataToCopy;</span>
<span class="fc" id="L488">            outPos += dataToCopy;</span>
<span class="fc" id="L489">            dataLeft -= dataToCopy;</span>
<span class="fc" id="L490">        }</span>

        /* Adjust outputAvailable */
<span class="fc" id="L493">        outputAvailable -= pOutLen;</span>

        /* Return the number of bytes transferred */
<span class="fc" id="L496">        return pOutLen;</span>
    }

    @Override
    public void reset() {
<span class="fc" id="L501">        resetBlockCount();</span>
<span class="fc" id="L502">        thePos = 0;</span>
<span class="fc" id="L503">        outputting = false;</span>
<span class="fc" id="L504">        Arrays.fill(theBuffer, (byte) 0);</span>
<span class="fc" id="L505">    }</span>

    @Override
    public void reset(final Memoable pSource) {
        /* Access source */
<span class="fc" id="L510">        final GordianBlake3Digest mySource = (GordianBlake3Digest) pSource;</span>

        /*  Reset counter */
<span class="fc" id="L513">        theCounter = mySource.theCounter;</span>
<span class="fc" id="L514">        theCurrBytes = mySource.theCurrBytes;</span>
<span class="fc" id="L515">        theMode = mySource.theMode;</span>

        /* Reset output state */
<span class="fc" id="L518">        outputting = mySource.outputting;</span>
<span class="fc" id="L519">        outputAvailable = mySource.outputAvailable;</span>
<span class="fc" id="L520">        theOutputMode = mySource.theOutputMode;</span>
<span class="fc" id="L521">        theOutputDataLen = mySource.theOutputDataLen;</span>

        /* Copy state */
<span class="fc" id="L524">        System.arraycopy(mySource.theChaining, 0, theChaining, 0, theChaining.length);</span>
<span class="fc" id="L525">        System.arraycopy(mySource.theK, 0, theK, 0, theK.length);</span>
<span class="fc" id="L526">        System.arraycopy(mySource.theM, 0, theM, 0, theM.length);</span>

        /* Copy stack */
<span class="fc" id="L529">        theStack.clear();</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">        for (int[] myEntry : mySource.theStack) {</span>
<span class="fc" id="L531">            theStack.push(myEntry.clone());</span>
<span class="fc" id="L532">        }</span>

        /* Copy buffer */
<span class="fc" id="L535">        System.arraycopy(mySource.theBuffer, 0, theBuffer, 0, theBuffer.length);</span>
<span class="fc" id="L536">        thePos = mySource.thePos;</span>
<span class="fc" id="L537">    }</span>

    @Override
    public GordianBlake3Digest copy() {
<span class="fc" id="L541">        return new GordianBlake3Digest(this);</span>
    }

    /**
     * Compress next block of the message.
     * @param pMessage the message buffer
     * @param pMsgPos the position within the message buffer
     */
    private void compressBlock(final byte[] pMessage,
                               final int pMsgPos) {
        /* Initialise state and compress message */
<span class="fc" id="L552">        initChunkBlock(BLOCKLEN, false);</span>
<span class="fc" id="L553">        initM(pMessage, pMsgPos);</span>
<span class="fc" id="L554">        compress();</span>

        /* Adjust stack if we have completed a block */
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if (theCurrBytes == 0) {</span>
<span class="fc" id="L558">            adjustStack();</span>
        }
<span class="fc" id="L560">    }</span>

    /**
     * Adjust the stack.
     */
    private void adjustStack() {
        /* Loop to combine blocks */
<span class="fc" id="L567">        long myCount = theCounter;</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">        while (myCount &gt; 0) {</span>
            /* Break loop if we are not combining */
<span class="fc bfc" id="L570" title="All 2 branches covered.">            if ((myCount &amp; 1) == 1) {</span>
<span class="fc" id="L571">                break;</span>
            }

            /* Build the message to be hashed */
<span class="fc" id="L575">            final int[] myLeft = theStack.pop();</span>
<span class="fc" id="L576">            System.arraycopy(myLeft, 0, theM, 0, NUMWORDS);</span>
<span class="fc" id="L577">            System.arraycopy(theChaining, 0, theM, NUMWORDS, NUMWORDS);</span>

            /* Create parent block */
<span class="fc" id="L580">            initParentBlock();</span>
<span class="fc" id="L581">            compress();</span>

            /* Next block */
<span class="fc" id="L584">            myCount &gt;&gt;= 1;</span>
<span class="fc" id="L585">        }</span>

        /* Add back to the stack */
<span class="fc" id="L588">        theStack.push(Arrays.copyOf(theChaining, NUMWORDS));</span>
<span class="fc" id="L589">    }</span>

    /**
     * Compress final block.
     * @param pDataLen the data length
     */
    private void compressFinalBlock(final int pDataLen) {
        /* Initialise state and compress message */
<span class="fc" id="L597">        initChunkBlock(pDataLen, true);</span>
<span class="fc" id="L598">        initM(theBuffer, 0);</span>
<span class="fc" id="L599">        compress();</span>

        /* Finalise stack */
<span class="fc" id="L602">        processStack();</span>
<span class="fc" id="L603">    }</span>

    /**
     * Process the stack.
     */
    private void processStack() {
        /* Finalise stack */
<span class="fc bfc" id="L610" title="All 2 branches covered.">        while (!theStack.isEmpty()) {</span>
            /* Build the message to be hashed */
<span class="fc" id="L612">            final int[] myLeft = theStack.pop();</span>
<span class="fc" id="L613">            System.arraycopy(myLeft, 0, theM, 0, NUMWORDS);</span>
<span class="fc" id="L614">            System.arraycopy(theChaining, 0, theM, NUMWORDS, NUMWORDS);</span>

            /* Create parent block */
<span class="fc" id="L617">            initParentBlock();</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">            if (theStack.isEmpty()) {</span>
<span class="fc" id="L619">                setRoot();</span>
            }
<span class="fc" id="L621">            compress();</span>
<span class="fc" id="L622">        }</span>
<span class="fc" id="L623">    }</span>

    /**
     * Perform compression.
     */
    private void compress() {
        /* Initialise the buffers */
<span class="fc" id="L630">        initIndices();</span>

        /* Loop through the rounds */
<span class="fc bfc" id="L633" title="All 2 branches covered.">        for (int round = 0; round &lt; ROUNDS - 1; round++) {</span>
            /* Perform the round and permuteM */
<span class="fc" id="L635">            performRound();</span>
<span class="fc" id="L636">            permuteIndices();</span>
        }
<span class="fc" id="L638">        performRound();</span>
<span class="fc" id="L639">        adjustChaining();</span>
<span class="fc" id="L640">    }</span>

    /**
     * Perform a round.
     */
    private void performRound() {
        /* Apply to columns of V */
<span class="fc" id="L647">        int idx = 0;</span>
<span class="fc" id="L648">        mixG(idx++, CHAINING0, CHAINING4, IV0, COUNT0);</span>
<span class="fc" id="L649">        mixG(idx++, CHAINING1, CHAINING5, IV1, COUNT1);</span>
<span class="fc" id="L650">        mixG(idx++, CHAINING2, CHAINING6, IV2, DATALEN);</span>
<span class="fc" id="L651">        mixG(idx++, CHAINING3, CHAINING7, IV3, FLAGS);</span>

        /* Apply to diagonals of V */
<span class="fc" id="L654">        mixG(idx++, CHAINING0, CHAINING5, IV2, FLAGS);</span>
<span class="fc" id="L655">        mixG(idx++, CHAINING1, CHAINING6, IV3, COUNT0);</span>
<span class="fc" id="L656">        mixG(idx++, CHAINING2, CHAINING7, IV0, COUNT1);</span>
<span class="fc" id="L657">        mixG(idx, CHAINING3, CHAINING4, IV1, DATALEN);</span>
<span class="fc" id="L658">    }</span>

    /**
     * Initialise M from message.
     * @param pMessage the source message
     * @param pMsgPos the message position
     */
    private void initM(final byte[] pMessage,
                       final int pMsgPos) {
        /* Copy message bytes into word array */
<span class="fc bfc" id="L668" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMWORDS &lt;&lt; 1; i++) {</span>
<span class="fc" id="L669">            theM[i] = Pack.littleEndianToInt(pMessage, pMsgPos + i * Integer.BYTES);</span>
        }
<span class="fc" id="L671">    }</span>

    /**
     * Adjust Chaining after compression.
     */
    private void adjustChaining() {
        /* If we are outputting */
<span class="fc bfc" id="L678" title="All 2 branches covered.">        if (outputting) {</span>
            /* Adjust full state */
<span class="fc bfc" id="L680" title="All 2 branches covered.">            for (int i = 0; i &lt; NUMWORDS; i++) {</span>
<span class="fc" id="L681">                theV[i] ^= theV[i + NUMWORDS];</span>
<span class="fc" id="L682">                theV[i + NUMWORDS] ^= theChaining[i];</span>
            }

            /* Output state to buffer */
<span class="fc bfc" id="L686" title="All 2 branches covered.">            for (int i = 0; i &lt; NUMWORDS &lt;&lt; 1; i++) {</span>
<span class="fc" id="L687">                Pack.intToLittleEndian(theV[i], theBuffer, i * Integer.BYTES);</span>
            }
<span class="fc" id="L689">            thePos = 0;</span>

            /* Else just build chain value */
        } else {
            /* Combine V into Chaining */
<span class="fc bfc" id="L694" title="All 2 branches covered.">            for (int i = 0; i &lt; NUMWORDS; i++) {</span>
<span class="fc" id="L695">                theChaining[i] = theV[i] ^ theV[i + NUMWORDS];</span>
            }
        }
<span class="fc" id="L698">    }</span>

    /**
     * Mix function G.
     * @param msgIdx the message index
     * @param posA position A in V
     * @param posB position B in V
     * @param posC position C in V
     * @param posD poistion D in V
     */
    private void mixG(final int msgIdx,
                      final int posA,
                      final int posB,
                      final int posC,
                      final int posD) {
        /* Determine indices */
<span class="fc" id="L714">        int msg = msgIdx &lt;&lt; 1;</span>
<span class="fc" id="L715">        int rot = 0;</span>

        /* Perform the Round */
<span class="fc" id="L718">        theV[posA] += theV[posB] + theM[theIndices[msg++]];</span>
<span class="fc" id="L719">        theV[posD] = rotr32(theV[posD] ^ theV[posA], ROTATE[rot++]);</span>
<span class="fc" id="L720">        theV[posC] += theV[posD];</span>
<span class="fc" id="L721">        theV[posB] = rotr32(theV[posB] ^ theV[posC], ROTATE[rot++]);</span>
<span class="fc" id="L722">        theV[posA] += theV[posB] + theM[theIndices[msg]];</span>
<span class="fc" id="L723">        theV[posD] = rotr32(theV[posD] ^ theV[posA], ROTATE[rot++]);</span>
<span class="fc" id="L724">        theV[posC] += theV[posD];</span>
<span class="fc" id="L725">        theV[posB] = rotr32(theV[posB] ^ theV[posC], ROTATE[rot]);</span>
<span class="fc" id="L726">    }</span>

    /**
     * initialise the indices.
     */
    private void initIndices() {
<span class="fc bfc" id="L732" title="All 2 branches covered.">        for (byte i = 0; i &lt; theIndices.length; i++) {</span>
<span class="fc" id="L733">            theIndices[i] = i;</span>
        }
<span class="fc" id="L735">    }</span>

    /**
     * PermuteIndices.
     */
    private void permuteIndices() {
<span class="fc bfc" id="L741" title="All 2 branches covered.">        for (byte i = 0; i &lt; theIndices.length; i++) {</span>
<span class="fc" id="L742">            theIndices[i] = SIGMA[theIndices[i]];</span>
        }
<span class="fc" id="L744">    }</span>

    /**
     * Rotate an int right.
     * @param x the value to rotate
     * @param rot the number of bits to rotate
     * @return the result
     */
    private static int rotr32(final int x,
                              final int rot) {
<span class="fc" id="L754">        return x &gt;&gt;&gt; rot | (x &lt;&lt; (Integer.SIZE - rot));</span>
    }

    /**
     * Initialise null key.
     */
    private void initNullKey() {
<span class="fc" id="L761">        System.arraycopy(IV, 0, theK, 0, NUMWORDS);</span>
<span class="fc" id="L762">    }</span>

    /**
     * Initialise key.
     * @param pKey the keyBytes
     */
    private void initKey(final byte[] pKey) {
        /* Copy message bytes into word array */
<span class="fc bfc" id="L770" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMWORDS; i++) {</span>
<span class="fc" id="L771">            theK[i] = Pack.littleEndianToInt(pKey, i * Integer.BYTES);</span>
        }
<span class="fc" id="L773">        theMode = KEYEDHASH;</span>
<span class="fc" id="L774">    }</span>

    /**
     * Initialise key from context.
     */
    private void initKeyFromContext() {
<span class="fc" id="L780">        System.arraycopy(theV, 0, theK, 0, NUMWORDS);</span>
<span class="fc" id="L781">        theMode = DERIVEKEY;</span>
<span class="fc" id="L782">    }</span>

    /**
     * Initialise chunk block.
     * @param pDataLen the dataLength
     * @param pFinal is this the final chunk?
     */
    private void initChunkBlock(final int pDataLen,
                                final boolean pFinal) {
        /* Initialise the block */
<span class="fc bfc" id="L792" title="All 2 branches covered.">        System.arraycopy(theCurrBytes == 0 ? theK : theChaining, 0, theV, 0, NUMWORDS);</span>
<span class="fc" id="L793">        System.arraycopy(IV, 0, theV, NUMWORDS, NUMWORDS &gt;&gt; 1);</span>
<span class="fc" id="L794">        theV[COUNT0] = (int) theCounter;</span>
<span class="fc" id="L795">        theV[COUNT1] = (int) (theCounter &gt;&gt; Integer.SIZE);</span>
<span class="fc" id="L796">        theV[DATALEN] = pDataLen;</span>
<span class="fc" id="L797">        theV[FLAGS] = theMode</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">                + (theCurrBytes == 0 ? CHUNKSTART : 0)</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">                + (pFinal ? CHUNKEND : 0);</span>

        /* * Adjust block count */
<span class="fc" id="L802">        theCurrBytes += pDataLen;</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (theCurrBytes &gt;= CHUNKLEN) {</span>
<span class="fc" id="L804">            incrementBlockCount();</span>
<span class="fc" id="L805">            theV[FLAGS] |= CHUNKEND;</span>
        }

        /* If we are single chunk */
<span class="fc bfc" id="L809" title="All 4 branches covered.">        if (pFinal &amp;&amp; theStack.isEmpty()) {</span>
<span class="fc" id="L810">            setRoot();</span>
        }
<span class="fc" id="L812">    }</span>

    /**
     * Initialise parent block.
     */
    private void initParentBlock() {
        /* Initialise the block */
<span class="fc" id="L819">        System.arraycopy(theK, 0, theV, 0, NUMWORDS);</span>
<span class="fc" id="L820">        System.arraycopy(IV, 0, theV, NUMWORDS, NUMWORDS &gt;&gt; 1);</span>
<span class="fc" id="L821">        theV[COUNT0] = 0;</span>
<span class="fc" id="L822">        theV[COUNT1] = 0;</span>
<span class="fc" id="L823">        theV[DATALEN] = BLOCKLEN;</span>
<span class="fc" id="L824">        theV[FLAGS] = theMode | PARENT;</span>
<span class="fc" id="L825">    }</span>

    /**
     * Initialise output block.
     */
    private void nextOutputBlock() {
        /* Increment the counter */
<span class="fc" id="L832">        theCounter++;</span>

        /* Initialise the block */
<span class="fc" id="L835">        System.arraycopy(theChaining, 0, theV, 0, NUMWORDS);</span>
<span class="fc" id="L836">        System.arraycopy(IV, 0, theV, NUMWORDS, NUMWORDS &gt;&gt; 1);</span>
<span class="fc" id="L837">        theV[COUNT0] = (int) theCounter;</span>
<span class="fc" id="L838">        theV[COUNT1] = (int) (theCounter &gt;&gt; Integer.SIZE);</span>
<span class="fc" id="L839">        theV[DATALEN] = theOutputDataLen;</span>
<span class="fc" id="L840">        theV[FLAGS] = theOutputMode;</span>

        /* Generate output */
<span class="fc" id="L843">        compress();</span>
<span class="fc" id="L844">    }</span>

    /**
     * IncrementBlockCount.
     */
    private void incrementBlockCount() {
<span class="fc" id="L850">        theCounter++;</span>
<span class="fc" id="L851">        theCurrBytes = 0;</span>
<span class="fc" id="L852">    }</span>

    /**
     * ResetBlockCount.
     */
    private void resetBlockCount() {
<span class="fc" id="L858">        theCounter = 0;</span>
<span class="fc" id="L859">        theCurrBytes = 0;</span>
<span class="fc" id="L860">    }</span>

    /**
     * Set root indication.
     */
    private void setRoot() {
<span class="fc" id="L866">        theV[FLAGS] |= ROOT;</span>
<span class="fc" id="L867">        theOutputMode = theV[FLAGS];</span>
<span class="fc" id="L868">        theOutputDataLen = theV[DATALEN];</span>
<span class="fc" id="L869">        theCounter = 0;</span>
<span class="fc" id="L870">        outputting = true;</span>
<span class="fc" id="L871">        outputAvailable = -1;</span>
<span class="fc" id="L872">        System.arraycopy(theV, 0, theChaining, 0, NUMWORDS);</span>
<span class="fc" id="L873">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianBlake2bDigest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.ext.digests</a> &gt; <span class="el_source">GordianBlake2bDigest.java</span></div><h1>GordianBlake2bDigest.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.ext.digests;

import org.bouncycastle.util.Memoable;
import org.bouncycastle.util.Pack;

/**
 * Blake2b digest.
 */
@SuppressWarnings(&quot;checkstyle:MagicNumber&quot;)
public class GordianBlake2bDigest
        extends GordianBlake2Base {
    /**
     * Number of Rounds.
     */
    private static final int ROUNDS = 12;

    /**
     * Block length.
     */
    private static final int BLOCK_LENGTH_BYTES = NUMWORDS * Long.BYTES &lt;&lt; 1;

    /**
     * Blake2b Initialization Vector.
     */
<span class="fc" id="L41">    private static final long[] IV = {</span>
            // Produced from the square root of primes 2, 3, 5, 7, 11, 13, 17, 19.
            // The same as SHA-512 IV.

                    0x6a09e667f3bcc908L, 0xbb67ae8584caa73bL, 0x3c6ef372fe94f82bL,
                    0xa54ff53a5f1d36f1L, 0x510e527fade682d1L, 0x9b05688c2b3e6c1fL,
                    0x1f83d9abfb41bd6bL, 0x5be0cd19137e2179L
            };

    /**
     * The state.
     */
<span class="fc" id="L53">    private final long[] theH = new long[NUMWORDS];</span>

    /**
     * The workBuffer.
     */
<span class="fc" id="L58">    private final long[] theV = new long[NUMWORDS &lt;&lt; 1];</span>

    /**
     * The messageBuffer.
     */
<span class="fc" id="L63">    private final long[] theM = new long[NUMWORDS &lt;&lt; 1];</span>

    /**
     * Low Counter.
     */
    private long t0;

    /**
     * High Counter.
     */
    private long t1;

    /**
     * Constructor.
     */
    public GordianBlake2bDigest() {
        /* Default to 512 bits */
<span class="fc" id="L80">        this(512);</span>
<span class="fc" id="L81">    }</span>

    /**
     * Constructor.
     * @param pLength the digest length in bits.
     */
    public GordianBlake2bDigest(final int pLength) {
        /* Initialise underlying class */
<span class="fc" id="L89">        super(ROUNDS, BLOCK_LENGTH_BYTES);</span>

        /* Check digest length */
<span class="pc bpc" id="L92" title="3 of 6 branches missed.">        if ((pLength % Byte.SIZE) != 0 || pLength &lt; 0 || pLength &gt; 512) {</span>
<span class="nc" id="L93">            throw new IllegalArgumentException(&quot;Incorrect digest length&quot;);</span>
        }
<span class="fc" id="L95">        setDigestLength(pLength / Byte.SIZE);</span>
<span class="fc" id="L96">        activateH();</span>
<span class="fc" id="L97">    }</span>

    /**
     * Constructor.
     * @param pSource the source digest.
     */
    private GordianBlake2bDigest(final GordianBlake2bDigest pSource) {
        /* Initialise underlying class */
<span class="fc" id="L105">        super(pSource);</span>

        /* Initialise from source */
<span class="fc" id="L108">        reset((Memoable) pSource);</span>
<span class="fc" id="L109">    }</span>

    @Override
    public String getAlgorithmName() {
<span class="fc" id="L113">        return &quot;Blake2b-&quot; + getDigestSize() * Byte.SIZE;</span>
    }

    @Override
    public int getByteLength() {
<span class="fc" id="L118">        return BLOCK_LENGTH_BYTES;</span>
    }

    @Override
    public void reset() {
        /* Reset counter */
<span class="fc" id="L124">        t0 = 0L;</span>
<span class="fc" id="L125">        t1 = 0L;</span>

        /* reset underlying class */
<span class="fc" id="L128">        super.reset();</span>
<span class="fc" id="L129">    }</span>

    @Override
    public void reset(final Memoable pSource) {
        /* Access source */
<span class="fc" id="L134">        final GordianBlake2bDigest mySource = (GordianBlake2bDigest) pSource;</span>

        /* reset underlying class */
<span class="fc" id="L137">        super.reset(mySource);</span>

        /* Reset counter */
<span class="fc" id="L140">        t0 = mySource.t0;</span>
<span class="fc" id="L141">        t1 = mySource.t1;</span>

        /* Copy state */
<span class="fc" id="L144">        System.arraycopy(mySource.theH, 0, theH, 0, theH.length);</span>
<span class="fc" id="L145">    }</span>

    @Override
    public GordianBlake2bDigest copy() {
<span class="fc" id="L149">        return new GordianBlake2bDigest(this);</span>
    }

    @Override
    void adjustCounter(final int pCount) {
<span class="fc" id="L154">        t0 += pCount;</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (t0 == 0) {</span>
<span class="nc" id="L156">            t1++;</span>
        }
<span class="fc" id="L158">    }</span>

    @Override
    void completeCounter(final int pCount) {
<span class="fc" id="L162">        t0 += pCount;</span>
<span class="pc bpc" id="L163" title="1 of 4 branches missed.">        if (pCount &gt; 0 &amp;&amp; t0 == 0) {</span>
<span class="nc" id="L164">            t1++;</span>
        }
<span class="fc" id="L166">    }</span>

    @Override
    void outputDigest(final byte[] pOut,
                      final int pOutOffset) {
        /* Loop to provide the output */
<span class="fc" id="L172">        final int myDigestLen = getDigestSize();</span>
<span class="fc bfc" id="L173" title="All 4 branches covered.">        for (int i = 0, j = 0; i &lt; NUMWORDS &amp;&amp; j &lt; myDigestLen; i++, j += Long.BYTES) {</span>
            /* Convert the next word to bytes */
<span class="fc" id="L175">            final byte[] bytes = Pack.longToLittleEndian(theH[i]);</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (j + Long.BYTES &lt; myDigestLen) {</span>
<span class="fc" id="L178">                System.arraycopy(bytes, 0, pOut, pOutOffset + j, Long.BYTES);</span>
            } else {
<span class="fc" id="L180">                System.arraycopy(bytes, 0, pOut, pOutOffset + j, myDigestLen - j);</span>
            }
        }
<span class="fc" id="L183">    }</span>

    @Override
    void activateH() {
        /* Initialise from IV */
<span class="fc" id="L188">        System.arraycopy(IV, 0, theH, 0, IV.length);</span>

        /* Initialise first word */
<span class="fc" id="L191">        theH[0] ^= getDigestSize() | (getKeyLen() &lt;&lt; Byte.SIZE);</span>
<span class="fc" id="L192">        theH[0] ^= (getFanOut() | (getMaxDepth() &lt;&lt; Byte.SIZE)) &lt;&lt; Short.SIZE;</span>
<span class="fc" id="L193">        theH[0] ^= ((long) getLeafLen()) &lt;&lt; Integer.SIZE;</span>

        /* Initialise second word */
<span class="fc" id="L196">        theH[1] ^= getNodeOffset() | (((long) getXofLen()) &lt;&lt; Integer.SIZE);</span>

        /* Initialise third word */
<span class="fc" id="L199">        theH[2] ^= (getNodeDepth() | (getInnerLen() &lt;&lt; Byte.SIZE));</span>

        /* Build salt section */
<span class="fc" id="L202">        final byte[] mySalt = getSalt();</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (mySalt != null) {</span>
<span class="fc" id="L204">            theH[4] ^= Pack.littleEndianToLong(mySalt, 0);</span>
<span class="fc" id="L205">            theH[5] ^= Pack.littleEndianToLong(mySalt, Long.BYTES);</span>
        }

        /* Build personalisation section */
<span class="fc" id="L209">        final byte[] myPersonal = getPersonal();</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (myPersonal != null) {</span>
<span class="nc" id="L211">            theH[6] ^= Pack.littleEndianToLong(myPersonal, 0);</span>
<span class="nc" id="L212">            theH[7] ^= Pack.littleEndianToLong(myPersonal, Long.BYTES);</span>
        }

        /* Initialise any keyBlock */
<span class="fc" id="L216">        initKeyBlock();</span>
<span class="fc" id="L217">    }</span>

    @Override
    void initV() {
        /* Copy in H and IV */
<span class="fc" id="L222">        System.arraycopy(theH, 0, theV, 0, NUMWORDS);</span>
<span class="fc" id="L223">        System.arraycopy(IV, 0, theV, NUMWORDS, NUMWORDS);</span>

        /* Fold in counters */
<span class="fc" id="L226">        theV[12] ^= t0;</span>
<span class="fc" id="L227">        theV[13] ^= t1;</span>

        /* Fold in finalisation flags */
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (isLastBlock()) {</span>
<span class="fc" id="L231">            theV[14] ^= -1L;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">            if (isLastNode()) {</span>
<span class="fc" id="L233">                theV[15] ^= -1L;</span>
            }
        }
<span class="fc" id="L236">    }</span>

    @Override
    void initM(final byte[] pMessage,
               final int pMsgPos) {
        /* Copy message bytes into word array */
<span class="fc bfc" id="L242" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMWORDS &lt;&lt; 1; i++) {</span>
<span class="fc" id="L243">            theM[i] = Pack.littleEndianToLong(pMessage, pMsgPos + i * Long.BYTES);</span>
        }
<span class="fc" id="L245">    }</span>

    @Override
    void adjustH() {
        /* Combine V into H */
<span class="fc bfc" id="L250" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMWORDS; i++) {</span>
<span class="fc" id="L251">            theH[i] ^= theV[i] ^ theV[i + NUMWORDS];</span>
        }
<span class="fc" id="L253">    }</span>

    @Override
    void mixG(final int msgIdx1,
              final int msgIdx2,
              final int posA,
              final int posB,
              final int posC,
              final int posD) {
        /* Perform the Round */
<span class="fc" id="L263">        theV[posA] += theV[posB] + theM[msgIdx1];</span>
<span class="fc" id="L264">        theV[posD] = rotr64(theV[posD] ^ theV[posA], 32);</span>
<span class="fc" id="L265">        theV[posC] += theV[posD];</span>
<span class="fc" id="L266">        theV[posB] = rotr64(theV[posB] ^ theV[posC], 24);</span>
<span class="fc" id="L267">        theV[posA] += theV[posB] + theM[msgIdx2];</span>
<span class="fc" id="L268">        theV[posD] = rotr64(theV[posD] ^ theV[posA], 16);</span>
<span class="fc" id="L269">        theV[posC] += theV[posD];</span>
<span class="fc" id="L270">        theV[posB] = rotr64(theV[posB] ^ theV[posC], 63);</span>
<span class="fc" id="L271">    }</span>

    /**
     * Rotate a long right.
     * @param x the value to rotate
     * @param rot the number of bits to rotate
     * @return the result
     */
    private static long rotr64(final long x,
                               final int rot) {
<span class="fc" id="L281">        return x &gt;&gt;&gt; rot | (x &lt;&lt; (Long.SIZE - rot));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
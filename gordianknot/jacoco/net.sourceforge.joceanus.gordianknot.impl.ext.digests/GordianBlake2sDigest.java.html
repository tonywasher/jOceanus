<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianBlake2sDigest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.ext.digests</a> &gt; <span class="el_source">GordianBlake2sDigest.java</span></div><h1>GordianBlake2sDigest.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.ext.digests;

import org.bouncycastle.util.Memoable;
import org.bouncycastle.util.Pack;

/**
 * Blake2s digest.
 */
@SuppressWarnings(&quot;checkstyle:MagicNumber&quot;)
public class GordianBlake2sDigest
        extends GordianBlake2Base {
    /**
     * Number of Rounds.
     */
    private static final int ROUNDS = 10;

    /**
     * Block length.
     */
    private static final int BLOCK_LENGTH_BYTES = NUMWORDS * Integer.BYTES &lt;&lt; 1;

    /**
     * Blake2s Initialization Vector.
     */
<span class="fc" id="L41">    private static final int[] IV = {</span>
            // Produced from the square root of primes 2, 3, 5, 7, 11, 13, 17, 19.
            // The same as SHA-256 IV.

                    0x6a09e667, 0xbb67ae85, 0x3c6ef372,
                    0xa54ff53a, 0x510e527f, 0x9b05688c,
                    0x1f83d9ab, 0x5be0cd19
            };

    /**
     * The state.
     */
<span class="fc" id="L53">    private final int[] theH = new int[NUMWORDS];</span>

    /**
     * The workBuffer.
     */
<span class="fc" id="L58">    private final int[] theV = new int[NUMWORDS &lt;&lt; 1];</span>

    /**
     * The messageBuffer.
     */
<span class="fc" id="L63">    private final int[] theM = new int[NUMWORDS &lt;&lt; 1];</span>

    /**
     * Low Counter.
     */
    private int t0;

    /**
     * High Counter.
     */
    private int t1;

    /**
     * Constructor.
     */
    public GordianBlake2sDigest() {
        /* Default to 256 bits */
<span class="fc" id="L80">        this(256);</span>
<span class="fc" id="L81">    }</span>

    /**
     * Constructor.
     * @param pLength the digest length in bits.
     */
    public GordianBlake2sDigest(final int pLength) {
        /* Initialise underlying class */
<span class="fc" id="L89">        super(ROUNDS, BLOCK_LENGTH_BYTES);</span>

        /* Check digest length */
<span class="pc bpc" id="L92" title="3 of 6 branches missed.">        if ((pLength % Byte.SIZE) != 0 || pLength &lt; 0 || pLength &gt; 256) {</span>
<span class="nc" id="L93">            throw new IllegalArgumentException(&quot;Incorrect digest length&quot;);</span>
        }
<span class="fc" id="L95">        setDigestLength(pLength / Byte.SIZE);</span>
<span class="fc" id="L96">        activateH();</span>
<span class="fc" id="L97">    }</span>

    /**
     * Constructor.
     * @param pSource the source digest.
     */
    private GordianBlake2sDigest(final GordianBlake2sDigest pSource) {
        /* Initialise underlying class */
<span class="fc" id="L105">        super(pSource);</span>

        /* Initialise from source */
<span class="fc" id="L108">        reset((Memoable) pSource);</span>
<span class="fc" id="L109">    }</span>

    @Override
    public String getAlgorithmName() {
<span class="fc" id="L113">        return &quot;Blake2s-&quot; + getDigestSize() * Byte.SIZE;</span>
    }

    @Override
    public int getByteLength() {
<span class="fc" id="L118">        return BLOCK_LENGTH_BYTES;</span>
    }

    @Override
    public void reset() {
        /* Reset counter */
<span class="fc" id="L124">        t0 = 0;</span>
<span class="fc" id="L125">        t1 = 0;</span>

        /* reset underlying class */
<span class="fc" id="L128">        super.reset();</span>
<span class="fc" id="L129">    }</span>

    @Override
    public void reset(final Memoable pSource) {
        /* Access source */
<span class="fc" id="L134">        final GordianBlake2sDigest mySource = (GordianBlake2sDigest) pSource;</span>

        /* reset underlying class */
<span class="fc" id="L137">        super.reset(mySource);</span>

        /* Reset counter */
<span class="fc" id="L140">        t0 = mySource.t0;</span>
<span class="fc" id="L141">        t1 = mySource.t1;</span>

        /* Copy state */
<span class="fc" id="L144">        System.arraycopy(mySource.theH, 0, theH, 0, theH.length);</span>
<span class="fc" id="L145">    }</span>

    @Override
    public GordianBlake2sDigest copy() {
<span class="fc" id="L149">        return new GordianBlake2sDigest(this);</span>
    }

    @Override
    void adjustCounter(final int pCount) {
<span class="fc" id="L154">        t0 += pCount;</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (t0 == 0) {</span>
<span class="nc" id="L156">            t1++;</span>
        }
<span class="fc" id="L158">    }</span>

    @Override
    void completeCounter(final int pCount) {
<span class="fc" id="L162">        t0 += pCount;</span>
<span class="pc bpc" id="L163" title="1 of 4 branches missed.">        if (pCount &gt; 0 &amp;&amp; t0 == 0) {</span>
<span class="nc" id="L164">            t1++;</span>
        }
<span class="fc" id="L166">    }</span>

    @Override
    void outputDigest(final byte[] pOut,
                      final int pOutOffset) {
        /* Loop to provide the output */
<span class="fc" id="L172">        final int myDigestLen = getDigestSize();</span>
<span class="fc bfc" id="L173" title="All 4 branches covered.">        for (int i = 0, j = 0; i &lt; NUMWORDS &amp;&amp; j &lt; myDigestLen; i++, j += Integer.BYTES) {</span>
            /* Convert the next word to bytes */
<span class="fc" id="L175">            final byte[] bytes = Pack.intToLittleEndian(theH[i]);</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (j + Integer.BYTES &lt; myDigestLen) {</span>
<span class="fc" id="L178">                System.arraycopy(bytes, 0, pOut, pOutOffset + j, Integer.BYTES);</span>
            } else {
<span class="fc" id="L180">                System.arraycopy(bytes, 0, pOut, pOutOffset + j, myDigestLen - j);</span>
            }
        }
<span class="fc" id="L183">    }</span>

    @Override
    protected void activateH() {
        /* Initialise from IV */
<span class="fc" id="L188">        System.arraycopy(IV, 0, theH, 0, IV.length);</span>

        /* Initialise first word */
<span class="fc" id="L191">        theH[0] ^= getDigestSize() | (getKeyLen() &lt;&lt; Byte.SIZE);</span>
<span class="fc" id="L192">        theH[0] ^= (getFanOut() | (getMaxDepth() &lt;&lt; Byte.SIZE)) &lt;&lt; Short.SIZE;</span>

        /* Initialise second word */
<span class="fc" id="L195">        theH[1] ^= getLeafLen();</span>

        /* Initialise third word */
<span class="fc" id="L198">        theH[2] ^= getNodeOffset();</span>

        /* Initialise fourth word */
<span class="fc" id="L201">        theH[3] ^= getXofLen();</span>
<span class="fc" id="L202">        theH[3] ^= (getNodeDepth() | (getInnerLen() &lt;&lt; Byte.SIZE)) &lt;&lt; Short.SIZE;</span>

        /* Build salt section */
<span class="fc" id="L205">        final byte[] mySalt = getSalt();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (mySalt != null) {</span>
<span class="fc" id="L207">            theH[4] ^= Pack.littleEndianToInt(mySalt, 0);</span>
<span class="fc" id="L208">            theH[5] ^= Pack.littleEndianToInt(mySalt, Integer.BYTES);</span>
        }

        /* Build personalisation section */
<span class="fc" id="L212">        final byte[] myPersonal = getPersonal();</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (myPersonal != null) {</span>
<span class="nc" id="L214">            theH[6] ^= Pack.littleEndianToInt(myPersonal, 0);</span>
<span class="nc" id="L215">            theH[7] ^= Pack.littleEndianToInt(myPersonal, Integer.BYTES);</span>
        }

        /* Initialise any keyBlock */
<span class="fc" id="L219">        initKeyBlock();</span>
<span class="fc" id="L220">    }</span>

    @Override
    protected void initV() {
        /* Copy in H and IV */
<span class="fc" id="L225">        System.arraycopy(theH, 0, theV, 0, NUMWORDS);</span>
<span class="fc" id="L226">        System.arraycopy(IV, 0, theV, NUMWORDS, NUMWORDS);</span>

        /* Fold in counters */
<span class="fc" id="L229">        theV[12] ^= t0;</span>
<span class="fc" id="L230">        theV[13] ^= t1;</span>

        /* Fold in finalisation flags */
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (isLastBlock()) {</span>
<span class="fc" id="L234">            theV[14] ^= -1;</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">            if (isLastNode()) {</span>
<span class="nc" id="L236">                theV[15] ^= -1;</span>
            }
        }
<span class="fc" id="L239">    }</span>

    @Override
    protected void initM(final byte[] pMessage,
                         final int pMsgPos) {
        /* Copy message bytes into word array */
<span class="fc bfc" id="L245" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMWORDS &lt;&lt; 1; i++) {</span>
<span class="fc" id="L246">            theM[i] = Pack.littleEndianToInt(pMessage, pMsgPos + i * Integer.BYTES);</span>
        }
<span class="fc" id="L248">    }</span>

    @Override
    protected void adjustH() {
        /* Combine V into H */
<span class="fc bfc" id="L253" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMWORDS; i++) {</span>
<span class="fc" id="L254">            theH[i] ^= theV[i] ^ theV[i + NUMWORDS];</span>
        }
<span class="fc" id="L256">    }</span>

    @Override
    protected void mixG(final int msgIdx1,
                        final int msgIdx2,
                        final int posA,
                        final int posB,
                        final int posC,
                        final int posD) {
        /* Perform the Round */
<span class="fc" id="L266">        theV[posA] += theV[posB] + theM[msgIdx1];</span>
<span class="fc" id="L267">        theV[posD] = rotr32(theV[posD] ^ theV[posA], 16);</span>
<span class="fc" id="L268">        theV[posC] += theV[posD];</span>
<span class="fc" id="L269">        theV[posB] = rotr32(theV[posB] ^ theV[posC], 12);</span>
<span class="fc" id="L270">        theV[posA] += theV[posB] + theM[msgIdx2];</span>
<span class="fc" id="L271">        theV[posD] = rotr32(theV[posD] ^ theV[posA], 8);</span>
<span class="fc" id="L272">        theV[posC] += theV[posD];</span>
<span class="fc" id="L273">        theV[posB] = rotr32(theV[posB] ^ theV[posC], 7);</span>
<span class="fc" id="L274">    }</span>

    /**
     * Rotate an int right.
     * @param x the value to rotate
     * @param rot the number of bits to rotate
     * @return the result
     */
    private static int rotr32(final int x,
                              final int rot) {
<span class="fc" id="L284">        return x &gt;&gt;&gt; rot | (x &lt;&lt; (Integer.SIZE - rot));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
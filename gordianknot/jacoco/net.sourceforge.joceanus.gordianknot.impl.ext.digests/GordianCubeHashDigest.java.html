<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianCubeHashDigest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.ext.digests</a> &gt; <span class="el_source">GordianCubeHashDigest.java</span></div><h1>GordianCubeHashDigest.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.ext.digests;

import org.bouncycastle.crypto.ExtendedDigest;
import org.bouncycastle.util.Memoable;

import java.util.Arrays;

/**
 * CubeHash Digest.
 */
@SuppressWarnings(&quot;checkstyle:MagicNumber&quot;)
public class GordianCubeHashDigest
        implements ExtendedDigest, Memoable {
    /**
     * The State length.
     */
    private static final int STATELEN = 32;

    /**
     * The Swap length.
     */
    private static final int SWAPLEN = STATELEN / 2;

    /**
     * The state.
     */
<span class="fc" id="L43">    private final int[] theState = new int[STATELEN];</span>

    /**
     * The swap buffer.
     */
<span class="fc" id="L48">    private final int[] theSwap = new int[SWAPLEN];</span>

    /**
     * The initial state.
     */
    private final int[] theInitState;

    /**
     * The block length.
     */
    private final int theBlockLen;

    /**
     * The hash length.
     */
    private final int theHashLen;

    /**
     * The number of final rounds.
     */
    private final int theNumRounds;

    /**
     * The number of final rounds.
     */
    private final int theNumFinalRounds;

    /**
     * The input buffer.
     */
    private final byte[] theInputBuffer;

    /**
     * The current byte index into input buffer.
     */
    private int theByteIndex;

    /**
     * Constructor.
     * @param pHashLen the hash lengyh
     */
    public GordianCubeHashDigest(final int pHashLen) {
<span class="fc" id="L90">        this(pHashLen, 32, 16, 16, 32);</span>
<span class="fc" id="L91">    }</span>

    /**
     * Constructor.
     * @param pSource the source digest
     */
<span class="fc" id="L97">    private GordianCubeHashDigest(final GordianCubeHashDigest pSource) {</span>
        /* Store configuration */
<span class="fc" id="L99">        theHashLen = pSource.theHashLen;</span>
<span class="fc" id="L100">        theBlockLen = pSource.theBlockLen;</span>
<span class="fc" id="L101">        theNumRounds = pSource.theNumRounds;</span>
<span class="fc" id="L102">        theNumFinalRounds = pSource.theNumFinalRounds;</span>

        /* Create the input buffer */
<span class="fc" id="L105">        theInputBuffer = new byte[theBlockLen];</span>

        /* Copy the state */
<span class="fc" id="L108">        System.arraycopy(pSource.theState, 0, theState, 0, theState.length);</span>
<span class="fc" id="L109">        System.arraycopy(pSource.theInputBuffer, 0, theInputBuffer, 0, theBlockLen);</span>
<span class="fc" id="L110">        theByteIndex = pSource.theByteIndex;</span>
<span class="fc" id="L111">        theInitState = Arrays.copyOf(pSource.theInitState, theState.length);</span>
<span class="fc" id="L112">    }</span>

    /**
     * Constructor.
     * @param pHashLen the hashLen in bits
     * @param pBlockLen the blockLen in bytes
     * @param pNumRounds the number of rounds per block
     * @param pInitRounds the number of initial rounds
     * @param pFinalRounds the number of final rounds;
     */
    private GordianCubeHashDigest(final int pHashLen,
                                  final int pBlockLen,
                                  final int pNumRounds,
                                  final int pInitRounds,
<span class="fc" id="L126">                                  final int pFinalRounds) {</span>
        /* Store configuration */
<span class="fc" id="L128">        theHashLen = pHashLen / Byte.SIZE;</span>
<span class="fc" id="L129">        theBlockLen = pBlockLen;</span>
<span class="fc" id="L130">        theNumRounds = pNumRounds;</span>
<span class="fc" id="L131">        theNumFinalRounds = pFinalRounds;</span>

        /* Create the input buffer */
<span class="fc" id="L134">        theInputBuffer = new byte[pBlockLen];</span>

        /* Initialise the state */
<span class="fc" id="L137">        theState[0] = theHashLen;</span>
<span class="fc" id="L138">        theState[1] = pBlockLen;</span>
<span class="fc" id="L139">        theState[2] = pNumRounds;</span>
<span class="fc" id="L140">        performRounds(pInitRounds);</span>

        /* Save the initial state */
<span class="fc" id="L143">        theInitState = Arrays.copyOf(theState, theState.length);</span>
<span class="fc" id="L144">    }</span>

    @Override
    public String getAlgorithmName() {
<span class="fc" id="L148">        return &quot;CubeHash-&quot; + theHashLen * Byte.SIZE;</span>
    }

    @Override
    public int getDigestSize() {
<span class="fc" id="L153">        return theHashLen;</span>
    }

    @Override
    public int getByteLength() {
<span class="fc" id="L158">        return theHashLen;</span>
    }

    @Override
    public void update(final byte pByte) {
<span class="fc" id="L163">        theInputBuffer[theByteIndex++] = pByte;</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (theByteIndex == theBlockLen) {</span>
<span class="fc" id="L165">            processBlock();</span>
<span class="fc" id="L166">            theByteIndex = 0;</span>
        }
<span class="fc" id="L168">    }</span>

    @Override
    public void update(final byte[] pData, final int pOffset, final int pLength) {
<span class="fc bfc" id="L172" title="All 2 branches covered.">        for (int i = 0; i &lt; pLength; i++) {</span>
<span class="fc" id="L173">            update(pData[pOffset + i]);</span>
        }
<span class="fc" id="L175">    }</span>

    @Override
    public int doFinal(final byte[] pHash, final int pOffset) {
<span class="fc" id="L179">        finaliseHash();</span>
<span class="fc" id="L180">        outputHash(pHash, pOffset);</span>
<span class="fc" id="L181">        return getDigestSize();</span>
    }

    @Override
    public void reset() {
<span class="fc" id="L186">        System.arraycopy(theInitState, 0, theState, 0, theState.length);</span>
<span class="fc" id="L187">        theByteIndex = 0;</span>
<span class="fc" id="L188">    }</span>

    @Override
    public GordianCubeHashDigest copy() {
<span class="fc" id="L192">        return new GordianCubeHashDigest(this);</span>
    }

    @Override
    public void reset(final Memoable pState) {
<span class="fc" id="L197">        final GordianCubeHashDigest d = (GordianCubeHashDigest) pState;</span>

        /* Copy the state */
<span class="fc" id="L200">        System.arraycopy(d.theState, 0, theState, 0, theState.length);</span>
<span class="fc" id="L201">        System.arraycopy(d.theInputBuffer, 0, theInputBuffer, 0, theBlockLen);</span>
<span class="fc" id="L202">        theByteIndex = d.theByteIndex;</span>
<span class="fc" id="L203">    }</span>

    /**
     * Decode a 32-bit value from a buffer (little-endian).
     *
     * @param buf the input buffer
     * @param off the input offset
     * @return the decoded value
     */
    private static int decode32le(final byte[] buf,
                                  final int off) {
<span class="fc" id="L214">        return (buf[off] &amp; 0xFF)</span>
                | ((buf[off + 1] &amp; 0xFF) &lt;&lt; 8)
                | ((buf[off + 2] &amp; 0xFF) &lt;&lt; 16)
                | ((buf[off + 3] &amp; 0xFF) &lt;&lt; 24);
    }

    /**
     * Encode a 32-bit value into a buffer (little-endian).
     *
     * @param val the value to encode
     * @param buf the output buffer
     * @param off the output offset
     */
    private static void encode32le(final int val,
                                   final byte[] buf,
                                   final int off) {
<span class="fc" id="L230">        buf[off] = (byte) val;</span>
<span class="fc" id="L231">        buf[off + 1] = (byte) (val &gt;&gt; 8);</span>
<span class="fc" id="L232">        buf[off + 2] = (byte) (val &gt;&gt; 16);</span>
<span class="fc" id="L233">        buf[off + 3] = (byte) (val &gt;&gt; 24);</span>
<span class="fc" id="L234">    }</span>

    /**
     * Process a block.
     */
    private void processBlock() {
        /* Loop through the bytes in the block */
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (int i = 0, j = 0; j &lt; theBlockLen; i++, j += Integer.BYTES) {</span>
<span class="fc" id="L242">            theState[i] ^= decode32le(theInputBuffer, j);</span>
        }

        /* Perform the required rounds */
<span class="fc" id="L246">        performRounds(theNumRounds);</span>
<span class="fc" id="L247">    }</span>

    /**
     * Finalise the hash.
     */
    private void finaliseHash() {
        /* Set the marker */
<span class="fc" id="L254">        theInputBuffer[theByteIndex++] = (byte) 0x80;</span>

        /* Fill remainder of buffer with zeroes */
<span class="fc bfc" id="L257" title="All 2 branches covered.">        while (theByteIndex &lt; theBlockLen) {</span>
<span class="fc" id="L258">            theInputBuffer[theByteIndex++] = 0;</span>
        }

        /* Process the block */
<span class="fc" id="L262">        processBlock();</span>

        /* Adjust the final State word */
<span class="fc" id="L265">        theState[STATELEN - 1] ^= 1;</span>

        /* Perform the required rounds */
<span class="fc" id="L268">        performRounds(theNumFinalRounds);</span>
<span class="fc" id="L269">    }</span>

    /**
     * Output the hash.
     * @param pOutput the output buffer
     * @param pOffSet the offset with the output buffer to write to
     */
    private void outputHash(final byte[] pOutput,
                            final int pOffSet) {
        /* Loop through the bytes in the block */
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (int i = 0, j = 0; j &lt; theHashLen; i++, j += Integer.BYTES) {</span>
<span class="fc" id="L280">            encode32le(theState[i], pOutput, j + pOffSet);</span>
        }

        /* Reset back to initial state */
<span class="fc" id="L284">        reset();</span>
<span class="fc" id="L285">    }</span>

    /**
     * Perform the required number of rounds.
     * @param pNumRounds the number of rounds
     */
    private void performRounds(final int pNumRounds) {
        /* Loop to perform the round */
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (int i = 0; i &lt; pNumRounds; i++) {</span>
<span class="fc" id="L294">            performRound();</span>
        }
<span class="fc" id="L296">    }</span>

    /**
     * Perform the round.
     */
    private void performRound() {
        /* 1. Add x[0jklm] into x[1jklm] modulo 2^32, for each (j,k,l,m) */
<span class="fc bfc" id="L303" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L304">            theState[i + SWAPLEN] += theState[i];</span>
        }

        /* 2. Rotate x[0jklm] upwards by 7 bits, for each (j,k,l,m) */
<span class="fc bfc" id="L308" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L309">            theSwap[i] = theState[i] &lt;&lt; 7 | theState[i] &gt;&gt;&gt; 25;</span>
        }

        /* 3. Swap x[00klm] with x[01klm], for each (k,l,m) */
<span class="fc bfc" id="L313" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L314">            theState[i] = theSwap[i ^ 8];</span>
        }

        /* 4. Xor x[1jklm] into x[0jklm], for each (j,k,l,m) */
<span class="fc bfc" id="L318" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L319">            theState[i] ^= theState[i + SWAPLEN];</span>
        }

        /* 5. Swap x[1jk0m] with x[1jk1m], for each (j,k,m) */
<span class="fc bfc" id="L323" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L324">            theSwap[i] = theState[i + SWAPLEN];</span>
        }
<span class="fc bfc" id="L326" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L327">            theState[i + SWAPLEN] = theSwap[i ^ 2];</span>
        }

        /* 6. Add x[0jklm] into x[1jklm] modulo 2^32, for each (j,k,l,m) */
<span class="fc bfc" id="L331" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L332">            theState[i + SWAPLEN] += theState[i];</span>
        }

        /* 7. Rotate x[0jklm] upwards by 11 bits, for each (j,k,l,m) */
<span class="fc bfc" id="L336" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L337">            theSwap[i] = theState[i] &lt;&lt; 11 | theState[i] &gt;&gt;&gt; 21;</span>
        }

        /* 8. Swap x[0j0lm] with x[0j1lm], for each (j,l,m) */
<span class="fc bfc" id="L341" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L342">            theState[i] = theSwap[i ^ 4];</span>
        }

        /* 9. Xor x[1jklm] into x[0jklm], for each (j,k,l,m) */
<span class="fc bfc" id="L346" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L347">            theState[i] ^= theState[i + SWAPLEN];</span>
        }

        /* 10. Swap x[1jkl0] with x[1jkl1], for each (j,k,l) */
<span class="fc bfc" id="L351" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L352">            theSwap[i] = theState[i + SWAPLEN];</span>
        }
<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (int i = 0; i &lt; SWAPLEN; i++) {</span>
<span class="fc" id="L355">            theState[i + SWAPLEN] = theSwap[i ^ 1];</span>
        }
<span class="fc" id="L357">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
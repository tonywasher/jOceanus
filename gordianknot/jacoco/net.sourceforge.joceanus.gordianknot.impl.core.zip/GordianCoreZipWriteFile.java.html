<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianCoreZipWriteFile.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.core.zip</a> &gt; <span class="el_source">GordianCoreZipWriteFile.java</span></div><h1>GordianCoreZipWriteFile.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.core.zip;

import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.factory.GordianFactory;
import net.sourceforge.joceanus.gordianknot.api.keyset.GordianKeySet;
import net.sourceforge.joceanus.gordianknot.api.zip.GordianZipFileEntry;
import net.sourceforge.joceanus.gordianknot.api.zip.GordianZipWriteFile;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianDataConverter;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianDataException;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianIOException;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianLogicException;
import net.sourceforge.joceanus.gordianknot.impl.core.keyset.GordianCoreKeySet;
import net.sourceforge.joceanus.gordianknot.impl.core.stream.GordianStreamDefinition;
import net.sourceforge.joceanus.gordianknot.impl.core.stream.GordianStreamManager;
import org.w3c.dom.Document;

import javax.xml.XMLConstants;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * Class used to build a ZipFile.
 */
public class GordianCoreZipWriteFile
        implements GordianZipWriteFile {
    /**
     * The FileName prefix.
     */
    private static final String FILE_PREFIX = &quot;File&quot;;

    /**
     * Security Lock for this zip file.
     */
    private final GordianCoreZipLock theLock;

    /**
     * securedKeySet for this zip file.
     */
    private final byte[] theSecuredKeySet;

    /**
     * KeySet for this zip file.
     */
    private final GordianCoreKeySet theKeySet;

    /**
     * The StreamFactory.
     */
    private final GordianStreamManager theStreamFactory;

    /**
     * The underlying Zip output stream.
     */
    private ZipOutputStream theStream;

    /**
     * The list of contents.
     */
    private final GordianCoreZipFileContents theContents;

    /**
     * The active zipEntry.
     */
    private ZipEntry theEntry;

    /**
     * The active zipFileEntry.
     */
    private GordianCoreZipFileEntry theFileEntry;

    /**
     * The active filename.
     */
    private String theFileName;

    /**
     * The active output stream.
     */
    private OutputStream theOutput;

    /**
     * The fileNumber.
     */
    private int theFileNo;

    /**
     * Constructor for new output zip file with security.
     * @param pLock the lock to use
     * @param pOutputStream the output stream to write to
     * @throws GordianException on error
     */
    GordianCoreZipWriteFile(final GordianCoreZipLock pLock,
<span class="fc" id="L119">                            final OutputStream pOutputStream) throws GordianException {</span>
        /* Check that the lock is usable */
<span class="pc bpc" id="L121" title="2 of 4 branches missed.">        if (pLock == null || !pLock.isFresh()) {</span>
<span class="nc" id="L122">            throw new GordianDataException(&quot;Invalid lock&quot;);</span>
        }

        /* Record lock and mark as used */
<span class="fc" id="L126">        theLock = pLock;</span>
<span class="fc" id="L127">        pLock.markAsUsed();</span>

        /* Create a child hash and record details */
<span class="fc" id="L130">        final GordianCoreKeySet myKeySet = (GordianCoreKeySet) theLock.getKeySet();</span>
<span class="fc" id="L131">        final GordianFactory myFactory = myKeySet.getFactory();</span>
<span class="fc" id="L132">        theKeySet = (GordianCoreKeySet) myFactory.getKeySetFactory().generateKeySet(myKeySet.getKeySetSpec());</span>
<span class="fc" id="L133">        theSecuredKeySet = myKeySet.secureKeySet(theKeySet);</span>

        /* Create the Stream Manager */
<span class="fc" id="L136">        theStreamFactory = new GordianStreamManager(theKeySet);</span>

        /* reSeed the random number generator */
<span class="fc" id="L139">        theKeySet.getFactory().reSeedRandom();</span>

        /* Create the output streams */
<span class="fc" id="L142">        final BufferedOutputStream myOutBuffer = new BufferedOutputStream(pOutputStream);</span>
<span class="fc" id="L143">        theStream = new ZipOutputStream(myOutBuffer);</span>

        /*
         * Set compression level to zero to speed things up. It would be nice to use the STORED
         * method, but this requires calculating the CRC and file size prior to writing data to
         * the Zip file which will badly affect performance.
         */
<span class="fc" id="L150">        theStream.setLevel(ZipOutputStream.STORED);</span>

        /* Create the file contents */
<span class="fc" id="L153">        theContents = new GordianCoreZipFileContents();</span>
<span class="fc" id="L154">    }</span>

    /**
     * Constructor for new output zip file with no security.
     * @param pOutputStream the output stream to write to
     */
<span class="fc" id="L160">    GordianCoreZipWriteFile(final OutputStream pOutputStream) {</span>
        /* record null security */
<span class="fc" id="L162">        theLock = null;</span>
<span class="fc" id="L163">        theSecuredKeySet = null;</span>
<span class="fc" id="L164">        theKeySet = null;</span>
<span class="fc" id="L165">        theStreamFactory = null;</span>

        /* Create the output streams */
<span class="fc" id="L168">        final BufferedOutputStream myOutBuffer = new BufferedOutputStream(pOutputStream);</span>
<span class="fc" id="L169">        theStream = new ZipOutputStream(myOutBuffer);</span>

        /* Create the file contents */
<span class="fc" id="L172">        theContents = new GordianCoreZipFileContents();</span>
<span class="fc" id="L173">    }</span>

    /**
     * Is the ZipFile encrypted.
     * @return is the Zip File encrypted
     */
    private boolean isEncrypted() {
<span class="fc bfc" id="L180" title="All 2 branches covered.">        return theLock != null;</span>
    }

    @Override
    public GordianCoreZipFileContents getContents() {
<span class="nc" id="L185">        return theContents;</span>
    }

    @Override
    public GordianZipFileEntry getCurrentEntry() {
<span class="nc" id="L190">        return theFileEntry;</span>
    }

    @Override
    public void writeXMLDocument(final File pFile,
                                 final Document pDocument) throws GordianException {
        /* Access the entry as an input stream */
<span class="fc" id="L197">        try (OutputStream myOutputStream = createOutputStream(pFile, true)) {</span>
            /* Create the transformer */
<span class="fc" id="L199">            final TransformerFactory myXformFactory = TransformerFactory.newInstance();</span>
<span class="fc" id="L200">            myXformFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>
<span class="fc" id="L201">            myXformFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span>
<span class="fc" id="L202">            myXformFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);</span>
<span class="fc" id="L203">            final Transformer myXformer = myXformFactory.newTransformer();</span>

            /* Format the XML and write to stream */
<span class="fc" id="L206">            myXformer.transform(new DOMSource(pDocument), new StreamResult(myOutputStream));</span>

            /* Catch exceptions */
<span class="nc" id="L209">        } catch (IOException</span>
                | TransformerException e) {
<span class="nc" id="L211">            throw new GordianIOException(&quot;Failed to write Document&quot;, e);</span>
<span class="fc" id="L212">        }</span>
<span class="fc" id="L213">    }</span>

    @Override
    public OutputStream createOutputStream(final File pFile,
                                           final boolean pCompress) throws GordianException {
        /* Reject call if we have closed the stream */
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (theStream == null) {</span>
<span class="nc" id="L220">            throw new GordianLogicException(&quot;ZipFile is closed&quot;);</span>
        }

        /* Reject call if we have an open stream */
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (theOutput != null) {</span>
<span class="nc" id="L225">            throw new GordianLogicException(&quot;Output stream already open&quot;);</span>
        }

        /* Increment file number */
<span class="fc" id="L229">        theFileNo++;</span>

        /* Protect against exceptions */
        try {
            /* Start the new entry */
<span class="fc" id="L234">            theFileName = pFile.getPath();</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">            theEntry = new ZipEntry(isEncrypted()</span>
                                    ? FILE_PREFIX
<span class="fc" id="L237">                                            + theFileNo</span>
<span class="fc" id="L238">                                    : theFileName);</span>
<span class="fc" id="L239">            theStream.putNextEntry(theEntry);</span>

            /* Create a new zipFileEntry */
<span class="fc" id="L242">            theFileEntry = theContents.addZipFileEntry(theFileName);</span>

            /* Simply create a wrapper on the output stream */
<span class="fc" id="L245">            theOutput = new GordianWrapOutputStream(theStream);</span>

            /* If we are encrypting */
<span class="fc bfc" id="L248" title="All 2 branches covered.">            if (isEncrypted()) {</span>
                /* Create an the output stream */
<span class="fc" id="L250">                theOutput = theStreamFactory.buildOutputStream(theOutput, pCompress);</span>
            }

            /* Catch exceptions */
<span class="nc" id="L254">        } catch (IOException e) {</span>
<span class="nc" id="L255">            throw new GordianIOException(&quot;Exception creating new Output stream&quot;, e);</span>
<span class="fc" id="L256">        }</span>

        /* return the new stream */
<span class="fc" id="L259">        return theOutput;</span>
    }

    /**
     * Close any active output stream and record digest values.
     * @throws IOException on error
     */
    private void closeOutputStream() throws IOException {
        /* Protect against exceptions */
        try {
            /* If we have an output stream */
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (theOutput != null) {</span>
                /* Close the active entry */
<span class="fc" id="L272">                theStream.closeEntry();</span>

                /* Add the details of the entry */
<span class="fc" id="L275">                theFileEntry.setZipEntry(theEntry);</span>

                /* If we have encryption */
<span class="fc bfc" id="L278" title="All 2 branches covered.">                if (isEncrypted()) {</span>
                    /* Analyse the output stream */
<span class="fc" id="L280">                    final List&lt;GordianStreamDefinition&gt; myStreams = theStreamFactory.analyseStreams(theOutput);</span>

                    /* Analyse the stream */
<span class="fc" id="L283">                    theFileEntry.buildProperties(myStreams);</span>
                }

                /* Release the entry */
<span class="fc" id="L287">                theEntry = null;</span>
<span class="fc" id="L288">                theFileName = null;</span>
<span class="fc" id="L289">                theFileEntry = null;</span>
            }

            /* Reset streams */
<span class="fc" id="L293">            theOutput = null;</span>

            /* Catch exceptions */
<span class="nc" id="L296">        } catch (GordianException e) {</span>
<span class="nc" id="L297">            throw new IOException(e);</span>
<span class="fc" id="L298">        }</span>
<span class="fc" id="L299">    }</span>

    @Override
    public void close() throws IOException {
        /* Close any open output stream */
<span class="fc" id="L304">        closeOutputStream();</span>

        /* If the stream is open */
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (theStream != null) {</span>
            /* Protect against exceptions */
            try {
                /* If we have stored files and are encrypted */
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                if (theFileNo &gt; 0</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">                        &amp;&amp; isEncrypted()) {</span>
                    /* Create a new zipFileEntry */
<span class="fc" id="L314">                    final GordianCoreZipFileEntry myEntry = theContents.addZipFileHeader();</span>
<span class="fc" id="L315">                    myEntry.setHash(theSecuredKeySet);</span>

                    /* Create the header entry */
<span class="fc" id="L318">                    ++theFileNo;</span>
<span class="fc" id="L319">                    theEntry = new ZipEntry(FILE_PREFIX</span>
                            + theFileNo);

                    /* Declare the lock and encrypt the header */
<span class="fc" id="L323">                    theEntry.setExtra(theLock.getEncodedBytes());</span>

                    /* Start the new entry */
<span class="fc" id="L326">                    theStream.putNextEntry(theEntry);</span>

                    /* Declare the details */
<span class="fc" id="L329">                    myEntry.setZipEntry(theEntry);</span>

                    /* Access the encoded file string */
<span class="fc" id="L332">                    final String myHeader = theContents.encodeContents();</span>

                    /* Write the bytes to the Zip file and close the entry */
<span class="fc" id="L335">                    final byte[] myBytes = GordianDataConverter.stringToByteArray(myHeader);</span>
<span class="fc" id="L336">                    final GordianKeySet myKeySet = theLock.getKeySet();</span>
<span class="fc" id="L337">                    theStream.write(myKeySet.encryptBytes(myBytes));</span>
<span class="fc" id="L338">                    theStream.closeEntry();</span>
                }

                /* close the stream */
<span class="fc" id="L342">                theStream.flush();</span>
<span class="fc" id="L343">                theStream.close();</span>
<span class="fc" id="L344">                theStream = null;</span>

                /* Catch exceptions */
<span class="nc" id="L347">            } catch (GordianException e) {</span>
<span class="nc" id="L348">                throw new IOException(e);</span>
<span class="fc" id="L349">            }</span>
        }
<span class="fc" id="L351">    }</span>

    /**
     * Wrapper class to catch close of output stream and prevent it from closing the ZipFile.
     */
    private final class GordianWrapOutputStream
            extends OutputStream {
        /**
         * The underlying Zip output stream.
         */
        private final ZipOutputStream theStream;

        /**
         * Constructor.
         * @param pStream the ZipStream
         */
<span class="fc" id="L367">        GordianWrapOutputStream(final ZipOutputStream pStream) {</span>
<span class="fc" id="L368">            theStream = pStream;</span>
<span class="fc" id="L369">        }</span>

        @Override
        public void flush() throws IOException {
<span class="fc" id="L373">            theStream.flush();</span>
<span class="fc" id="L374">        }</span>

        @Override
        public void write(final int b) throws IOException {
<span class="nc" id="L378">            theStream.write(b);</span>
<span class="nc" id="L379">        }</span>

        @Override
        public void write(final byte[] b) throws IOException {
<span class="nc" id="L383">            theStream.write(b);</span>
<span class="nc" id="L384">        }</span>

        @Override
        public void write(final byte[] b,
                          final int offset,
                          final int length) throws IOException {
<span class="fc" id="L390">            theStream.write(b, offset, length);</span>
<span class="fc" id="L391">        }</span>

        @Override
        public void close() throws IOException {
<span class="fc" id="L395">            closeOutputStream();</span>
<span class="fc" id="L396">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianEllipticEncryptor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.ext.engines</a> &gt; <span class="el_source">GordianEllipticEncryptor.java</span></div><h1>GordianEllipticEncryptor.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.ext.engines;

import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.ec.ECElGamalDecryptor;
import org.bouncycastle.crypto.ec.ECElGamalEncryptor;
import org.bouncycastle.crypto.ec.ECPair;
import org.bouncycastle.crypto.params.ECDomainParameters;
import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
import org.bouncycastle.crypto.params.ECPublicKeyParameters;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.math.ec.ECPoint;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Arrays;

/**
 * Elliptic curve encryptor.
 * Based on https://onlinelibrary.wiley.com/doi/pdf/10.1002/sec.1702
 */
public class GordianEllipticEncryptor {
    /**
     * CoFactor must be less than or equal to 20. Boundary is actually 10 &lt; b &lt; 76.
     */
    private static final int MAXCOFACTOR = 20;

    /**
     * The max iterations to try for a point.
     */
    private static final int MAXITERATION = 1 &lt;&lt; Byte.SIZE;

    /**
     * The encryptor.
     */
    private final ECElGamalEncryptor theEncryptor;

    /**
     * The decryptor.
     */
    private final ECElGamalDecryptor theDecryptor;

    /**
     * The ECCurve.
     */
    private ECCurve theCurve;

    /**
     * is encryption available?
     */
    private boolean isAvailable;

    /**
     * Are we encrypting or decrypting?
     */
    private boolean encrypting;

    /**
     * Constructor.
     */
<span class="fc" id="L77">    public GordianEllipticEncryptor() {</span>
<span class="fc" id="L78">        theEncryptor = new ECElGamalEncryptor();</span>
<span class="fc" id="L79">        theDecryptor = new ECElGamalDecryptor();</span>
<span class="fc" id="L80">    }</span>

    /**
     * Initialise for encryption.
     * @param pPublicKey the publicKey
     * @param pRandom the secureRandom
     */
    public void initForEncrypt(final ECPublicKeyParameters pPublicKey,
                               final SecureRandom pRandom) {
        /* Access domain parameters */
<span class="fc" id="L90">        final ECDomainParameters myDomain = pPublicKey.getParameters();</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (isUnsupported(myDomain)) {</span>
<span class="nc" id="L92">            throw new IllegalArgumentException(&quot;Unsupported curve&quot;);</span>
        }

        /* Record details */
<span class="fc" id="L96">        theCurve = myDomain.getCurve();</span>
<span class="fc" id="L97">        isAvailable = true;</span>
<span class="fc" id="L98">        encrypting = true;</span>

        /* Initialise for encryption */
<span class="fc" id="L101">        final ParametersWithRandom myParms = new ParametersWithRandom(pPublicKey, pRandom);</span>
<span class="fc" id="L102">        theEncryptor.init(myParms);</span>
<span class="fc" id="L103">    }</span>

    /**
     * Initialise for decryption.
     * @param pPrivateKey the privateKey
     */
    public void initForDecrypt(final ECPrivateKeyParameters pPrivateKey) {
        /* Access domain parameters */
<span class="fc" id="L111">        final ECDomainParameters myDomain = pPrivateKey.getParameters();</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (isUnsupported(myDomain)) {</span>
<span class="nc" id="L113">            throw new IllegalArgumentException(&quot;Unsupported curve&quot;);</span>
        }

        /* Record details */
<span class="fc" id="L117">        theCurve = myDomain.getCurve();</span>
<span class="fc" id="L118">        isAvailable = true;</span>
<span class="fc" id="L119">        encrypting = false;</span>

        /* Initialise for decryption */
<span class="fc" id="L122">        theDecryptor.init(pPrivateKey);</span>
<span class="fc" id="L123">    }</span>

    /**
     * Check whether encryption is available for this domain.
     * @param pDomain the domain
     * @return true/false
     */
    private boolean isUnsupported(final ECDomainParameters pDomain) {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        return pDomain.getH().compareTo(BigInteger.valueOf(MAXCOFACTOR)) &gt; 0;</span>
    }

    /**
     * Obtain the length of field.
     * @return the length of the field.
     */
    private int getFieldLength() {
<span class="fc" id="L139">        return (theCurve.getFieldSize() + Byte.SIZE - 1) / Byte.SIZE;</span>
    }

    /**
     * Obtain the length of block (1 less than fieldLength).
     * @return the length of the block.
     */
    private int getBlockLength() {
<span class="fc" id="L147">        return getFieldLength() - 1;</span>
    }

    /**
     * Obtain the length of the plain block (2 less than blockLength).
     * @return the length of the block.
     */
    private int getPlainBlockLength() {
<span class="fc" id="L155">        return getBlockLength() - 2;</span>
    }

    /**
     * Obtain the length of the encrypted block.
     * @return the length of the block.
     */
    private int getEncodedBlockLength() {
<span class="fc" id="L163">        return (getFieldLength() + 1) &lt;&lt; 1;</span>
    }

    /**
     * Obtain the length of the buffer required to receive the decrypted data.
     * @param pLength the length of encrypted data
     * @return the number of bytes.
     */
    private int getDecryptedLength(final int pLength) {
<span class="fc" id="L172">        return getPlainBlockLength() * getNumBlocks(pLength, getEncodedBlockLength());</span>
    }

    /**
     * Obtain the length of the buffer required for the encrypted output.
     * @param pLength the length of clear data
     * @return the number of bytes.
     */
    private int getEncryptedLength(final int pLength) {
<span class="fc" id="L181">        return getEncodedBlockLength() * getNumBlocks(pLength, getPlainBlockLength());</span>
    }

    /**
     * Obtain the number of blocks required for the length in terms of blocks.
     * @param pLength the length of clear data
     * @param pBlockLength the blockLength
     * @return the number of blocks.
     */
    private static int getNumBlocks(final int pLength, final int pBlockLength) {
<span class="fc" id="L191">        return (pLength + pBlockLength - 1) / pBlockLength;</span>
    }

    /**
     * Encrypt a data buffer.
     * @param pData the buffer to encrypt
     * @return the encrypted keyPair
     * @throws InvalidCipherTextException on error
     */
    public byte[] encrypt(final byte[] pData) throws InvalidCipherTextException {
        /* Check that we are set to encrypt */
<span class="pc bpc" id="L202" title="2 of 4 branches missed.">        if (!isAvailable || !encrypting) {</span>
<span class="nc" id="L203">            throw new IllegalStateException(&quot;Not initialised for encrypting&quot;);</span>
        }

        /* Create the output buffer */
<span class="fc" id="L207">        int myInLen = pData.length;</span>
<span class="fc" id="L208">        final byte[] myOutput = new byte[getEncryptedLength(pData.length)];</span>

        /* Access block lengths */
<span class="fc" id="L211">        final int myInBlockLength = getPlainBlockLength();</span>

        /* Loop encrypting the blocks */
<span class="fc" id="L214">        int myInOff = 0;</span>
<span class="fc" id="L215">        int myOutOff = 0;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        while (myInLen &gt; 0) {</span>
            /* Encrypt to an ECPair */
<span class="fc" id="L218">            final int myLen = Math.min(myInLen, myInBlockLength);</span>
<span class="fc" id="L219">            final ECPair myPair = encryptToPair(pData, myInOff, myLen);</span>

            /* Convert into the output buffer */
<span class="fc" id="L222">            myOutOff += convertFromECPair(myPair, myOutput, myOutOff);</span>

            /* Move to next block */
<span class="fc" id="L225">            myInOff += myInBlockLength;</span>
<span class="fc" id="L226">            myInLen -= myInBlockLength;</span>
<span class="fc" id="L227">        }</span>

        /* Return full buffer if possible */
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        return myOutOff == myOutput.length</span>
<span class="fc" id="L231">                ? myOutput</span>
<span class="nc" id="L232">                : Arrays.copyOf(myOutput, myOutOff);</span>
    }

    /**
     * Encrypt a value.
     * @param pData the buffer to encrypt
     * @param pInOff the offset in the buffer
     * @param pInLen the length of data to encrypt
     * @return the encrypted keyPair
     * @throws InvalidCipherTextException on error
     */
    private ECPair encryptToPair(final byte[] pData,
                                 final int pInOff,
                                 final int pInLen) throws InvalidCipherTextException {
        /* Convert the data to an ECPoint */
<span class="fc" id="L247">        final ECPoint myPoint = convertToECPoint(pData, pInOff, pInLen);</span>

        /* Encrypt the data */
<span class="fc" id="L250">        return theEncryptor.encrypt(myPoint);</span>
    }

    /**
     * Convert to ECPoint.
     * @param pInBuffer the input buffer
     * @param pInOff the input offset
     * @param pInLen the length of data to process
     * @return the ECPair
     * @throws InvalidCipherTextException on error
     */
    private ECPoint convertToECPoint(final byte[] pInBuffer,
                                     final int pInOff,
                                     final int pInLen) throws InvalidCipherTextException {
        /* Check lengths */
<span class="fc" id="L265">        final int myLen = getBlockLength();</span>
<span class="pc bpc" id="L266" title="2 of 4 branches missed.">        if (pInLen &gt; myLen - 2</span>
                || pInLen &lt;= 0) {
<span class="nc" id="L268">            throw new IllegalArgumentException(&quot;Invalid input length&quot;);</span>
        }
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (pInBuffer.length - pInOff &lt; pInLen) {</span>
<span class="nc" id="L271">            throw new IllegalArgumentException(&quot;Invalid input buffer&quot;);</span>
        }

        /* Create the work buffer and copy data in */
<span class="fc" id="L275">        final byte[] myX = new byte[myLen + 1];</span>

        /* Calculate the start position and place data and padding */
<span class="fc" id="L278">        final int myStart = myLen - pInLen;</span>
<span class="fc" id="L279">        System.arraycopy(pInBuffer, pInOff, myX, myStart, pInLen);</span>
<span class="fc" id="L280">        myX[myStart - 1] = 1;</span>

        /* Loop to obtain point on curve */
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        for (int i = 0; i &lt; MAXITERATION; i++) {</span>
            /* Check to see whether the value is on the curve */
<span class="fc" id="L285">            final ECPoint myPoint = checkOnCurve(myX);</span>

            /* If we have a valid point */
<span class="fc bfc" id="L288" title="All 2 branches covered.">            if (myPoint != null) {</span>
<span class="fc" id="L289">                return myPoint;</span>
            }

            /* Increment the test value */
<span class="fc" id="L293">            myX[myLen]++;</span>
        }

        /* No possible value found */
<span class="nc" id="L297">        throw new InvalidCipherTextException(&quot;Unable to find point on curve&quot;);</span>
    }

    /**
     * Check whether the point is on the curve.
     * @param pX the byte buffer representing X
     * @return the ECPoint if on curve, else null
     */
    private ECPoint checkOnCurve(final byte[] pX) {
        /* Protect against exceptions */
        try {
            /* Create a compressed point */
<span class="fc" id="L309">            final int myFieldLen = getFieldLength();</span>
<span class="fc" id="L310">            final byte[] myCompressed = new byte[myFieldLen + 1];</span>
<span class="fc" id="L311">            System.arraycopy(pX, 0, myCompressed, 1, myFieldLen);</span>
<span class="fc" id="L312">            myCompressed[0] = 2;</span>
<span class="fc" id="L313">            final ECPoint myPoint = theCurve.decodePoint(myCompressed);</span>

            /* Check the point */
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            return myPoint.isValid()</span>
<span class="fc" id="L317">                    ? myPoint</span>
<span class="nc" id="L318">                    : null;</span>

            /* Handle invalid coding */
<span class="fc" id="L321">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L322">            return null;</span>
        }
    }

    /**
     * Convert from ECPair.
     * @param pPair the ECPoint
     * @param pOutBuffer the output buffer
     * @param pOutOff the output offset
     * @return the length of data decoded
     * @throws InvalidCipherTextException on error
     */
    private int convertFromECPair(final ECPair pPair,
                                  final byte[] pOutBuffer,
                                  final int pOutOff) throws InvalidCipherTextException {
        /* Check length */
<span class="fc" id="L338">        final int myLen = getFieldLength() + 1;</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        if (pOutBuffer.length - pOutOff &lt; myLen &lt;&lt; 1) {</span>
<span class="nc" id="L340">            throw new IllegalArgumentException(&quot;Output buffer too small&quot;);</span>
        }

        /* Access the two encoded parameters  */
<span class="fc" id="L344">        final byte[] myX = pPair.getX().getEncoded(true);</span>
<span class="fc" id="L345">        final byte[] myY = pPair.getY().getEncoded(true);</span>
<span class="pc bpc" id="L346" title="2 of 4 branches missed.">        if (myX.length != myLen || myY.length != myLen) {</span>
<span class="nc" id="L347">            throw new InvalidCipherTextException(&quot;Bad encoding&quot;);</span>
        }

        /* Copy to the output buffer */
<span class="fc" id="L351">        System.arraycopy(myX, 0, pOutBuffer, pOutOff, myLen);</span>
<span class="fc" id="L352">        System.arraycopy(myY, 0, pOutBuffer, pOutOff + myLen, myLen);</span>
<span class="fc" id="L353">        return myLen &lt;&lt; 1;</span>
    }

    /**
     * Decrypt a data buffer.
     * @param pData the buffer to encrypt
     * @return the encrypted keyPair
     * @throws InvalidCipherTextException on error
     */
    public byte[] decrypt(final byte[] pData) throws InvalidCipherTextException {
        /* Check that we are set to encrypt */
<span class="pc bpc" id="L364" title="2 of 4 branches missed.">        if (!isAvailable || encrypting) {</span>
<span class="nc" id="L365">            throw new IllegalStateException(&quot;Not initialised for decrypting&quot;);</span>
        }

        /* Create the output buffer */
<span class="fc" id="L369">        int myInLen = pData.length;</span>
<span class="fc" id="L370">        final byte[] myOutput = new byte[getDecryptedLength(pData.length)];</span>

        /* Access block lengths */
<span class="fc" id="L373">        final int myInBlockLength = getEncodedBlockLength();</span>

        /* Loop decrypting the blocks */
<span class="fc" id="L376">        int myInOff = 0;</span>
<span class="fc" id="L377">        int myOutOff = 0;</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        while (myInLen &gt; 0) {</span>
            /* Encrypt to an ECPair */
<span class="fc" id="L380">            final ECPair myPair = convertToECPair(pData, myInOff);</span>

            /* Convert into the output buffer */
<span class="fc" id="L383">            myOutOff += decryptFromECPair(myPair, myOutput, myOutOff);</span>

            /* Move to next block */
<span class="fc" id="L386">            myInOff += myInBlockLength;</span>
<span class="fc" id="L387">            myInLen -= myInBlockLength;</span>
<span class="fc" id="L388">        }</span>

        /* Return full buffer if possible */
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (myOutOff == myOutput.length) {</span>
<span class="nc" id="L392">            return myOutput;</span>
        }

        /* Cut down buffer */
<span class="fc" id="L396">        final byte[] myReturn = Arrays.copyOf(myOutput, myOutOff);</span>
<span class="fc" id="L397">        Arrays.fill(myOutput, (byte) 0);</span>
<span class="fc" id="L398">        return myReturn;</span>
    }

    /**
     * Decrypt a value.
     * @param pPair the pair to decrypt
     * @param pOutBuffer the output buffer
     * @param pOutOff the output offset
     * @return the length of data decoded
     * @throws InvalidCipherTextException on error
     */
    private int decryptFromECPair(final ECPair pPair,
                                  final byte[] pOutBuffer,
                                  final int pOutOff) throws InvalidCipherTextException {
        /* Decrypt the pair */
<span class="fc" id="L413">        final ECPoint myPoint = theDecryptor.decrypt(pPair);</span>
<span class="fc" id="L414">        return convertFromECPoint(myPoint, pOutBuffer, pOutOff);</span>
    }

    /**
     * Convert from ECPoint.
     * @param pPoint the ECPoint
     * @param pOutBuffer the output buffer
     * @param pOutOff the output offset
     * @return the length of data decoded
     * @throws InvalidCipherTextException on error
     */
    private int convertFromECPoint(final ECPoint pPoint,
                                   final byte[] pOutBuffer,
                                   final int pOutOff) throws InvalidCipherTextException {
        /* Obtain the X co-ordinate */
<span class="fc" id="L429">        final BigInteger myX = pPoint.getAffineXCoord().toBigInteger();</span>
<span class="fc" id="L430">        final byte[] myBuf = myX.toByteArray();</span>

        /* Set defaults */
<span class="fc" id="L433">        int myStart = -1;</span>
<span class="fc" id="L434">        final int myEnd = myBuf.length - 1;</span>

        /* Loop through the data in fixed time */
<span class="fc bfc" id="L437" title="All 2 branches covered.">        for (int myIndex = 0; myIndex &lt; myEnd; myIndex++) {</span>
            /* If the value is non-zero and we have not yet found start */
            /* Disable the short-circuit logic!! */
<span class="fc bfc" id="L440" title="All 6 branches covered.">            if (myBuf[myIndex] != 0</span>
                    &amp; myStart == -1) {
<span class="fc" id="L442">                myStart = myIndex;</span>
            }
        }

        /* Check validity */
<span class="pc bpc" id="L447" title="2 of 4 branches missed.">        if (myStart == -1 || myBuf[myStart] != 1) {</span>
<span class="nc" id="L448">            throw new InvalidCipherTextException(&quot;Invalid data&quot;);</span>
        }

        /* Bump past padding */
<span class="fc" id="L452">        myStart++;</span>

        /* Check length */
<span class="fc" id="L455">        final int myOutLen = myEnd - myStart;</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">        if (pOutBuffer.length - pOutOff &lt; myOutLen) {</span>
<span class="nc" id="L457">            throw new IllegalArgumentException(&quot;Output buffer too small&quot;);</span>
        }

        /* Copy the data out */
<span class="fc" id="L461">        System.arraycopy(myBuf, myStart, pOutBuffer, pOutOff, myOutLen);</span>
<span class="fc" id="L462">        return myOutLen;</span>
    }

    /**
     * Convert to ECPair.
     * @param pInBuffer the input buffer
     * @param pInOff the input offset
     * @return the ECPair
     */
    private ECPair convertToECPair(final byte[] pInBuffer,
                                   final int pInOff)  {
        /* Check length */
<span class="fc" id="L474">        final int myLen = getFieldLength() + 1;</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">        if (pInBuffer.length - pInOff &lt; myLen &lt;&lt; 1) {</span>
<span class="nc" id="L476">            throw new IllegalArgumentException(&quot;Invalid input buffer&quot;);</span>
        }

        /* Access the X point */
<span class="fc" id="L480">        final byte[] myXbytes  = new byte[myLen];</span>
<span class="fc" id="L481">        System.arraycopy(pInBuffer, pInOff, myXbytes, 0, myLen);</span>
<span class="fc" id="L482">        final ECPoint myX = theCurve.decodePoint(myXbytes);</span>

        /* Access the Y point */
<span class="fc" id="L485">        final byte[] myYbytes = new byte[myLen];</span>
<span class="fc" id="L486">        System.arraycopy(pInBuffer, pInOff + myLen, myYbytes, 0, myLen);</span>
<span class="fc" id="L487">        final ECPoint myY = theCurve.decodePoint(myYbytes);</span>

        /* Create the ECPair */
<span class="fc" id="L490">        return new ECPair(myX, myY);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
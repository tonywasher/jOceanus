<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianRabbitEngine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.ext.engines</a> &gt; <span class="el_source">GordianRabbitEngine.java</span></div><h1>GordianRabbitEngine.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.ext.engines;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.StreamCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.util.Memoable;

import java.util.Arrays;

/**
 * StreamCipher implementation based on the SosemanukFast java implementation.
 * &lt;p&gt;
 * Based on http://www.ecrypt.eu.org/stream/e2-rabbit.html.
 */
@SuppressWarnings(&quot;checkstyle:MagicNumber&quot;)
public class GordianRabbitEngine
        implements StreamCipher, Memoable {
    /**
     * Number of variables.
     */
    private static final int NUM_VARS = 8;

    /**
     * Advanced stream length.
     */
    private static final int STREAM_LEN = 80;

    /**
     * context.
     */
<span class="fc" id="L50">    static class GordianRabbitContext {</span>
        /**
         * X state.
         */
<span class="fc" id="L54">        private int[] x = new int[NUM_VARS];</span>

        /**
         * c stat.
         */
<span class="fc" id="L59">        private int[] c = new int[NUM_VARS];</span>

        /**
         * carry state.
         */
        private int carry;

        /**
         * Copy from.
         * @param pSource the source context
         */
        void copyFrom(final GordianRabbitContext pSource) {
<span class="fc" id="L71">            System.arraycopy(pSource.x, 0, x, 0, NUM_VARS);</span>
<span class="fc" id="L72">            System.arraycopy(pSource.c, 0, c, 0, NUM_VARS);</span>
<span class="fc" id="L73">            carry = pSource.carry;</span>
<span class="fc" id="L74">        }</span>
    }

    /**
     * Work context.
     */
<span class="fc" id="L80">    private GordianRabbitContext work = new GordianRabbitContext();</span>

    /**
     * master context.
     */
<span class="fc" id="L85">    private GordianRabbitContext master = new GordianRabbitContext();</span>

    /**
     * index of next byte in keyStream.
     */
    private int theIndex;

    /**
     * Advanced stream.
     */
<span class="fc" id="L95">    private final byte[] keyStream = new byte[STREAM_LEN];</span>

    /**
     * Reset state.
     */
    private GordianRabbitEngine theResetState;

    /**
     * Constructor.
     */
<span class="fc" id="L105">    public GordianRabbitEngine() {</span>
<span class="fc" id="L106">    }</span>

    /**
     * Constructor.
     * @param pSource the source engine
     */
<span class="fc" id="L112">    private GordianRabbitEngine(final GordianRabbitEngine pSource) {</span>
<span class="fc" id="L113">        reset(pSource);</span>
<span class="fc" id="L114">    }</span>

    /**
     * initialise a Rabbit cipher.
     * @param forEncryption whether or not we are for encryption.
     * @param params the parameters required to set up the cipher.
     * @exception IllegalArgumentException if the params argument is inappropriate.
     */
    public void init(final boolean forEncryption,
                     final CipherParameters params) {
        /*
         * encryption and decryption is completely symmetrical, so the 'forEncryption' is
         * irrelevant. (Like 90% of stream ciphers)
         */

        /* Determine parameters */
<span class="fc" id="L130">        CipherParameters myParams = params;</span>
<span class="fc" id="L131">        byte[] newKey = null;</span>
<span class="fc" id="L132">        byte[] newIV = null;</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if ((myParams instanceof ParametersWithIV)) {</span>
<span class="fc" id="L134">            final ParametersWithIV ivParams = (ParametersWithIV) myParams;</span>
<span class="fc" id="L135">            newIV = ivParams.getIV();</span>
<span class="fc" id="L136">            myParams = ivParams.getParameters();</span>
        }
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if (myParams instanceof KeyParameter) {</span>
<span class="fc" id="L139">            final KeyParameter keyParam = (KeyParameter) myParams;</span>
<span class="fc" id="L140">            newKey = keyParam.getKey();</span>
        }

        /* Initialise engine and mark as initialised */
<span class="fc" id="L144">        theIndex = 0;</span>
<span class="fc" id="L145">        setKey(newKey);</span>
<span class="fc" id="L146">        setIV(newIV);</span>
<span class="fc" id="L147">        makeKeyStream();</span>

        /* Save reset state */
<span class="fc" id="L150">        theResetState = copy();</span>
<span class="fc" id="L151">    }</span>

    @Override
    public String getAlgorithmName() {
<span class="nc" id="L155">        return &quot;Rabbit&quot;;</span>
    }

    @Override
    public int processBytes(final byte[] in,
                            final int inOff,
                            final int len,
                            final byte[] out,
                            final int outOff) {
        /* Check for errors */
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (theResetState == null) {</span>
<span class="nc" id="L166">            throw new IllegalStateException(getAlgorithmName() + &quot; not initialised&quot;);</span>
        }
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if ((inOff + len) &gt; in.length) {</span>
<span class="nc" id="L169">            throw new DataLengthException(&quot;input buffer too short&quot;);</span>
        }
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if ((outOff + len) &gt; out.length) {</span>
<span class="nc" id="L172">            throw new OutputLengthException(&quot;output buffer too short&quot;);</span>
        }

        /* Loop through the input bytes */
<span class="fc bfc" id="L176" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L177">            out[i + outOff] = returnByte(in[i + inOff]);</span>
        }
<span class="fc" id="L179">        return len;</span>
    }

    @Override
    public void reset() {
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (theResetState != null) {</span>
<span class="fc" id="L185">            reset(theResetState);</span>
        }
<span class="fc" id="L187">    }</span>

    @Override
    public byte returnByte(final byte in) {
<span class="fc" id="L191">        final byte out = (byte) (keyStream[theIndex] ^ in);</span>
<span class="fc" id="L192">        theIndex = (theIndex + 1) % STREAM_LEN;</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (theIndex == 0) {</span>
<span class="fc" id="L195">            makeKeyStream();</span>
        }
<span class="fc" id="L197">        return out;</span>
    }

    /**
     * Decode a 32-bit value from a buffer (little-endian).
     *
     * @param buf the input buffer
     * @param off the input offset
     * @return the decoded value
     */
    private static int decode32le(final byte[] buf, final int off) {
<span class="fc" id="L208">        return (buf[off] &amp; 0xFF)</span>
                | ((buf[off + 1] &amp; 0xFF) &lt;&lt; 8)
                | ((buf[off + 2] &amp; 0xFF) &lt;&lt; 16)
                | ((buf[off + 3] &amp; 0xFF) &lt;&lt; 24);
    }

    /**
     * Encode a 32-bit value into a buffer (little-endian).
     *
     * @param val the value to encode
     * @param buf the output buffer
     * @param off the output offset
     */
    private static void encode32le(final int val, final byte[] buf, final int off) {
<span class="fc" id="L222">        buf[off] = (byte) val;</span>
<span class="fc" id="L223">        buf[off + 1] = (byte) (val &gt;&gt; 8);</span>
<span class="fc" id="L224">        buf[off + 2] = (byte) (val &gt;&gt; 16);</span>
<span class="fc" id="L225">        buf[off + 3] = (byte) (val &gt;&gt; 24);</span>
<span class="fc" id="L226">    }</span>

    /* Square a 32-bit unsigned integer to obtain the 64-bit result and return */
    /* the upper 32 bits XOR the lower 32 bits */
    static int rabbitGFunc(final int x) {
        /* Construct high and low argument for squaring */
<span class="fc" id="L232">        final int a = x &amp; 0xFFFF;</span>
<span class="fc" id="L233">        final int b = x &gt;&gt;&gt; 16;</span>

        /* Calculate high and low result of squaring */
<span class="fc" id="L236">        final int h = ((((a * a) &gt;&gt;&gt; 17) + (a * b)) &gt;&gt;&gt; 15) + b * b;</span>
<span class="fc" id="L237">        final int l = x * x;</span>

        /* Return high XOR low */
<span class="fc" id="L240">        return (h ^ l);</span>
    }

    /* Calculate the next internal state */
    static void rabbitNextState(final GordianRabbitContext pContext) {
        /* Save old counter values */
<span class="fc" id="L246">        final int[] cOld = Arrays.copyOf(pContext.c, NUM_VARS);</span>
<span class="fc" id="L247">        final int[] g = new int[NUM_VARS];</span>

        /* Calculate new counter values */
<span class="fc" id="L250">        pContext.c[0] = (pContext.c[0] + 0x4D34D34D + pContext.carry);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">        pContext.c[1] = (pContext.c[1] + 0xD34D34D3 + (Integer.compareUnsigned(pContext.c[0], cOld[0]) &lt; 0 ? 1 : 0));</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        pContext.c[2] = (pContext.c[2] + 0x34D34D34 + (Integer.compareUnsigned(pContext.c[1], cOld[1]) &lt; 0 ? 1 : 0));</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">        pContext.c[3] = (pContext.c[3] + 0x4D34D34D + (Integer.compareUnsigned(pContext.c[2], cOld[2]) &lt; 0 ? 1 : 0));</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        pContext.c[4] = (pContext.c[4] + 0xD34D34D3 + (Integer.compareUnsigned(pContext.c[3], cOld[3]) &lt; 0 ? 1 : 0));</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">        pContext.c[5] = (pContext.c[5] + 0x34D34D34 + (Integer.compareUnsigned(pContext.c[4], cOld[4]) &lt; 0 ? 1 : 0));</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        pContext.c[6] = (pContext.c[6] + 0x4D34D34D + (Integer.compareUnsigned(pContext.c[5], cOld[5]) &lt; 0 ? 1 : 0));</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        pContext.c[7] = (pContext.c[7] + 0xD34D34D3 + (Integer.compareUnsigned(pContext.c[6], cOld[6]) &lt; 0 ? 1 : 0));</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        pContext.carry = Integer.compareUnsigned(pContext.c[7], cOld[7]) &lt; 0 ? 1 : 0;</span>

        /* Calculate the g-values */
<span class="fc bfc" id="L261" title="All 2 branches covered.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="fc" id="L262">            g[i] = rabbitGFunc(pContext.x[i] + pContext.c[i]);</span>
        }

        /* Calculate new state values */
<span class="fc" id="L266">        pContext.x[0] = (g[0] + rotl32(g[7], 16) + rotl32(g[6], 16));</span>
<span class="fc" id="L267">        pContext.x[1] = (g[1] + rotl32(g[0], 8) + g[7]);</span>
<span class="fc" id="L268">        pContext.x[2] = (g[2] + rotl32(g[1], 16) + rotl32(g[0], 16));</span>
<span class="fc" id="L269">        pContext.x[3] = (g[3] + rotl32(g[2], 8) + g[1]);</span>
<span class="fc" id="L270">        pContext.x[4] = (g[4] + rotl32(g[3], 16) + rotl32(g[2], 16));</span>
<span class="fc" id="L271">        pContext.x[5] = (g[5] + rotl32(g[4], 8) + g[3]);</span>
<span class="fc" id="L272">        pContext.x[6] = (g[6] + rotl32(g[5], 16) + rotl32(g[4], 16));</span>
<span class="fc" id="L273">        pContext.x[7] = (g[7] + rotl32(g[6], 8) + g[5]);</span>
<span class="fc" id="L274">    }</span>

    static int rotl32(final int v, final int n) {
<span class="fc" id="L277">        return (((v) &lt;&lt; (n)) | ((v) &gt;&gt;&gt; (32 - (n))));</span>
    }

    /* Key setup */
    void setKey(final byte[] key) {
        /* Check lengths */
<span class="pc bpc" id="L283" title="2 of 4 branches missed.">        if (key == null || key.length != 16) {</span>
<span class="nc" id="L284">            throw new IllegalArgumentException(&quot;A key of 16 bytes is needed&quot;);</span>
        }

        /* Generate four subkeys */
<span class="fc" id="L288">        final int k0 = decode32le(key, 0);</span>
<span class="fc" id="L289">        final int k1 = decode32le(key, 4);</span>
<span class="fc" id="L290">        final int k2 = decode32le(key, 8);</span>
<span class="fc" id="L291">        final int k3 = decode32le(key, 12);</span>

        /* Generate initial state variables */
<span class="fc" id="L294">        master.x[0] = k0;</span>
<span class="fc" id="L295">        master.x[2] = k1;</span>
<span class="fc" id="L296">        master.x[4] = k2;</span>
<span class="fc" id="L297">        master.x[6] = k3;</span>
<span class="fc" id="L298">        master.x[1] = (k3 &lt;&lt; 16) | (k2 &gt;&gt;&gt; 16);</span>
<span class="fc" id="L299">        master.x[3] = (k0 &lt;&lt; 16) | (k3 &gt;&gt;&gt; 16);</span>
<span class="fc" id="L300">        master.x[5] = (k1 &lt;&lt; 16) | (k0 &gt;&gt;&gt; 16);</span>
<span class="fc" id="L301">        master.x[7] = (k2 &lt;&lt; 16) | (k1 &gt;&gt;&gt; 16);</span>

        /* Generate initial counter values */
<span class="fc" id="L304">        master.c[0] = rotl32(k2, 16);</span>
<span class="fc" id="L305">        master.c[2] = rotl32(k3, 16);</span>
<span class="fc" id="L306">        master.c[4] = rotl32(k0, 16);</span>
<span class="fc" id="L307">        master.c[6] = rotl32(k1, 16);</span>
<span class="fc" id="L308">        master.c[1] = (k0 &amp; 0xFFFF0000) | (k1 &amp; 0xFFFF);</span>
<span class="fc" id="L309">        master.c[3] = (k1 &amp; 0xFFFF0000) | (k2 &amp; 0xFFFF);</span>
<span class="fc" id="L310">        master.c[5] = (k2 &amp; 0xFFFF0000) | (k3 &amp; 0xFFFF);</span>
<span class="fc" id="L311">        master.c[7] = (k3 &amp; 0xFFFF0000) | (k0 &amp; 0xFFFF);</span>

        /* Clear carry bit */
<span class="fc" id="L314">        master.carry = 0;</span>

        /* Iterate the system four times */
<span class="fc bfc" id="L317" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L318">            rabbitNextState(master);</span>
        }

        /* Modify the counters */
<span class="fc bfc" id="L322" title="All 2 branches covered.">        for (int i = 0; i &lt; NUM_VARS; i++) {</span>
<span class="fc" id="L323">            master.c[i] ^= master.x[(i + 4) &amp; 0x7];</span>
        }

        /* Copy master instance to work instance */
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (int i = 0; i &lt; NUM_VARS; i++) {</span>
<span class="fc" id="L328">            work.x[i] = master.x[i];</span>
<span class="fc" id="L329">            work.c[i] = master.c[i];</span>
        }
<span class="fc" id="L331">        work.carry = master.carry;</span>
<span class="fc" id="L332">    }</span>

    /* ------------------------------------------------------------------------- */

    /* IV setup */
    void setIV(final byte[] iv) {
        /* Check lengths */
<span class="pc bpc" id="L339" title="2 of 4 branches missed.">        if (iv == null || iv.length != 8) {</span>
<span class="nc" id="L340">            throw new IllegalArgumentException(&quot;An IV of 8 bytes is needed&quot;);</span>
        }

        /* Generate four subvectors */
<span class="fc" id="L344">        final int i0 = decode32le(iv, 0);</span>
<span class="fc" id="L345">        final int i2 = decode32le(iv, 4);</span>
<span class="fc" id="L346">        final int i1 = (i0 &gt;&gt;&gt; 16) | (i2 &amp; 0xFFFF0000);</span>
<span class="fc" id="L347">        final int i3 = (i2 &lt;&lt; 16) | (i0 &amp; 0x0000FFFF);</span>

        /* Modify counter values */
<span class="fc" id="L350">        work.c[0] = master.c[0] ^ i0;</span>
<span class="fc" id="L351">        work.c[1] = master.c[1] ^ i1;</span>
<span class="fc" id="L352">        work.c[2] = master.c[2] ^ i2;</span>
<span class="fc" id="L353">        work.c[3] = master.c[3] ^ i3;</span>
<span class="fc" id="L354">        work.c[4] = master.c[4] ^ i0;</span>
<span class="fc" id="L355">        work.c[5] = master.c[5] ^ i1;</span>
<span class="fc" id="L356">        work.c[6] = master.c[6] ^ i2;</span>
<span class="fc" id="L357">        work.c[7] = master.c[7] ^ i3;</span>

        /* Copy state variables */
<span class="fc bfc" id="L360" title="All 2 branches covered.">        for (int i = 0; i &lt; NUM_VARS; i++) {</span>
<span class="fc" id="L361">            work.x[i] = master.x[i];</span>
        }
<span class="fc" id="L363">        work.carry = master.carry;</span>

        /* Iterate the system four times */
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L367">            rabbitNextState(work);</span>
        }
<span class="fc" id="L369">    }</span>

    /* Generate keystream */
    void makeKeyStream() {
        /* Generate five blocks */
<span class="fc bfc" id="L374" title="All 2 branches covered.">        for (int i = 0; i &lt; STREAM_LEN; i += 16) {</span>
            /* Iterate the system */
<span class="fc" id="L376">            rabbitNextState(work);</span>

            /* Generate 16 bytes of pseudo-random data */
<span class="fc" id="L379">            encode32le(work.x[0] ^ (work.x[5] &gt;&gt;&gt; 16) ^ (work.x[3] &lt;&lt; 16), keyStream, i + 0);</span>
<span class="fc" id="L380">            encode32le(work.x[2] ^ (work.x[7] &gt;&gt;&gt; 16) ^ (work.x[5] &lt;&lt; 16), keyStream, i + 4);</span>
<span class="fc" id="L381">            encode32le(work.x[4] ^ (work.x[1] &gt;&gt;&gt; 16) ^ (work.x[7] &lt;&lt; 16), keyStream, i + 8);</span>
<span class="fc" id="L382">            encode32le(work.x[6] ^ (work.x[3] &gt;&gt;&gt; 16) ^ (work.x[1] &lt;&lt; 16), keyStream, i + 12);</span>
        }
<span class="fc" id="L384">    }</span>

    @Override
    public GordianRabbitEngine copy() {
<span class="fc" id="L388">        return new GordianRabbitEngine(this);</span>
    }

    @Override
    public void reset(final Memoable pState) {
<span class="fc" id="L393">        final GordianRabbitEngine e = (GordianRabbitEngine) pState;</span>
<span class="fc" id="L394">        work.copyFrom(e.work);</span>
<span class="fc" id="L395">        master.copyFrom(e.master);</span>
<span class="fc" id="L396">        System.arraycopy(e.keyStream, 0, keyStream, 0, STREAM_LEN);</span>
<span class="fc" id="L397">        theIndex = e.theIndex;</span>
<span class="fc" id="L398">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
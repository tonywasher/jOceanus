<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianAgreementResult.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.core.agree</a> &gt; <span class="el_source">GordianAgreementResult.java</span></div><h1>GordianAgreementResult.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.core.agree;

import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.base.GordianKeySpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianCipherFactory;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianCipherParameters;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamCipher;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamCipherSpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianStreamKeySpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianSymCipher;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianSymCipherSpec;
import net.sourceforge.joceanus.gordianknot.api.cipher.GordianSymKeySpec;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigestSpec;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigestType;
import net.sourceforge.joceanus.gordianknot.api.factory.GordianFactory;
import net.sourceforge.joceanus.gordianknot.api.factory.GordianFactoryType;
import net.sourceforge.joceanus.gordianknot.api.key.GordianKey;
import net.sourceforge.joceanus.gordianknot.api.keyset.GordianKeySet;
import net.sourceforge.joceanus.gordianknot.api.keyset.GordianKeySetSpec;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianDataConverter;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianParameters;
import net.sourceforge.joceanus.gordianknot.impl.core.kdf.GordianHKDFEngine;
import net.sourceforge.joceanus.gordianknot.impl.core.kdf.GordianHKDFParams;
import net.sourceforge.joceanus.gordianknot.impl.core.key.GordianCoreKeyGenerator;
import net.sourceforge.joceanus.gordianknot.impl.core.keyset.GordianCoreKeySet;
import net.sourceforge.joceanus.gordianknot.impl.core.keyset.GordianCoreKeySetFactory;
import org.bouncycastle.util.Arrays;

import java.nio.charset.StandardCharsets;
import java.util.Random;

/**
 * Result derivation.
 */
public class GordianAgreementResult {
    /**
     * The factory.
     */
    private final GordianBaseFactory theFactory;

    /**
     * The client initVector.
     */
    private byte[] theClientIV;

    /**
     * The server initVector.
     */
    private byte[] theServerIV;

    /**
     * constructor.
     * @param pFactory the factory
     */
<span class="fc" id="L72">    GordianAgreementResult(final GordianBaseFactory pFactory) {</span>
<span class="fc" id="L73">        theFactory = pFactory;</span>
<span class="fc" id="L74">    }</span>

    /**
     * Obtain the clientIV.
     * @return the clientIV
     */
    protected byte[] getClientIV() {
<span class="fc" id="L81">        return theClientIV;</span>
    }

    /**
     * Set clientIV.
     * @param pClientIV the clientIV
     */
    void setClientIV(final byte[] pClientIV) {
<span class="fc" id="L89">        theClientIV = pClientIV;</span>
<span class="fc" id="L90">    }</span>

    /**
     * Obtain the serverIV.
     * @return the serverIV
     */
    protected byte[] getServerIV() {
<span class="fc" id="L97">        return theServerIV;</span>
    }

    /**
     * Set serverIV.
     * @param pServerIV the serverIV
     */
    void setServerIV(final byte[] pServerIV) {
<span class="fc" id="L105">        theServerIV = pServerIV;</span>
<span class="fc" id="L106">    }</span>

    /**
     * Reset data.
     */
    public void reset() {
        /* Reset the client and serverIVs */
<span class="fc" id="L113">        theClientIV = null;</span>
<span class="fc" id="L114">        theServerIV = null;</span>
<span class="fc" id="L115">    }</span>

    /**
     * Process the secret.
     * @param pSecret the secret
     * @param pResultType the resultType
     * @return teh result
     * @throws GordianException on error
     */
    Object processSecret(final byte[] pSecret,
                         final Object pResultType) throws GordianException {
        /* If the resultType is a FactoryType */
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (pResultType instanceof GordianFactoryType myType) {</span>
            /* derive the factory */
<span class="fc" id="L129">            return deriveFactory(myType, pSecret);</span>

            /* If the resultType is a KeySetSpec */
<span class="fc bfc" id="L132" title="All 2 branches covered.">        } else if (pResultType instanceof GordianKeySetSpec mySpec) {</span>
            /* Derive the keySet */
<span class="fc" id="L134">            return deriveKeySet(mySpec, pSecret);</span>

            /* If the resultType is a SymCipherSpec */
<span class="fc bfc" id="L137" title="All 2 branches covered.">        } else if (pResultType instanceof GordianSymCipherSpec mySpec) {</span>
            /* Derive the key */
<span class="fc" id="L139">            return deriveCipher(mySpec, pSecret);</span>

            /* If the resultType is a StreamCipherSpec */
<span class="fc bfc" id="L142" title="All 2 branches covered.">        } else if (pResultType instanceof GordianStreamCipherSpec mySpec) {</span>
            /* Derive the key */
<span class="fc" id="L144">            return deriveCipher(mySpec, pSecret);</span>

            /* If the resultType is an Integer */
<span class="fc bfc" id="L147" title="All 2 branches covered.">        } else if (pResultType instanceof Integer myLength) {</span>
            /* Derive the key */
<span class="fc" id="L149">            return deriveBytes(pSecret, myLength);</span>
        }

        /* Return the raw secret */
<span class="fc" id="L153">        return Arrays.clone(pSecret);</span>
    }

    /**
     * Derive factory from the secret.
     * @param pFactoryType the factoryType
     * @param pSecret the secret
     * @return the factory
     * @throws GordianException on error
     */
    private GordianFactory deriveFactory(final GordianFactoryType pFactoryType,
                                         final byte[] pSecret) throws GordianException {
        /* Ensure that we clear out the seed */
<span class="fc" id="L166">        byte[] mySeed = null;</span>
        try {
            /* Calculate the seed */
<span class="fc" id="L169">            mySeed = calculateDerivedSecret(pSecret, GordianDerivationId.FACTORY, GordianParameters.SEED_LEN.getByteLength());</span>

            /* Create a new Factory using the phrase */
<span class="fc" id="L172">            final GordianParameters myParams = new GordianParameters(pFactoryType, mySeed);</span>
<span class="fc" id="L173">            return theFactory.newFactory(myParams);</span>

            /* Clear buffer */
        } finally {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">            if (mySeed != null) {</span>
<span class="fc" id="L178">                Arrays.fill(mySeed, (byte) 0);</span>
            }
        }
    }

    /**
     * Derive a keySet from the secret.
     * @param pSpec the keySetSpec
     * @param pSecret the secret
     * @return the derived keySet
     * @throws GordianException on error
     */
    private GordianKeySet deriveKeySet(final GordianKeySetSpec pSpec,
                                       final byte[] pSecret) throws GordianException {
        /* Derive a shared factory */
<span class="fc" id="L193">        final GordianFactory myFactory = deriveFactory(GordianFactoryType.BC, pSecret);</span>

        /* Ensure that we clear out the secret */
<span class="fc" id="L196">        byte[] mySecret = null;</span>
        try {
            /* Calculate the secret */
<span class="fc" id="L199">            mySecret = calculateDerivedSecret(pSecret, GordianDerivationId.KEYSET, GordianParameters.SECRET_LEN.getByteLength());</span>

            /* Derive the keySet */
<span class="fc" id="L202">            final GordianCoreKeySetFactory myKeySets = (GordianCoreKeySetFactory) myFactory.getKeySetFactory();</span>
<span class="fc" id="L203">            final GordianCoreKeySet myKeySet = myKeySets.createKeySet(pSpec);</span>
<span class="fc" id="L204">            myKeySet.buildFromSecret(mySecret);</span>
<span class="fc" id="L205">            return myKeySet;</span>

        } finally {
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">            if (mySecret != null) {</span>
<span class="fc" id="L209">                Arrays.fill(mySecret, (byte) 0);</span>
            }
        }
    }

    /**
     * Derive a symKeyCipher pair from the secret.
     * @param pCipherSpec the cipherSpec
     * @param pSecret the secret
     * @return the ciphers
     * @throws GordianException on error
     */
    private GordianSymCipher[] deriveCipher(final GordianSymCipherSpec pCipherSpec,
                                            final byte[] pSecret) throws GordianException {
        /* Derive a shared factory */
<span class="fc" id="L224">        final GordianFactory myFactory = deriveFactory(GordianFactoryType.BC, pSecret);</span>

        /* Generate the key */
<span class="fc" id="L227">        final GordianKey&lt;GordianSymKeySpec&gt; myKey = deriveKey(myFactory, pCipherSpec.getKeyType(), pSecret);</span>

        /* Create the cipher and initialise with key */
<span class="fc" id="L230">        final GordianCipherFactory myCiphers = myFactory.getCipherFactory();</span>
<span class="fc" id="L231">        final GordianSymCipher myOutCipher = myCiphers.createSymKeyCipher(pCipherSpec);</span>
<span class="fc" id="L232">        final GordianSymCipher myInCipher = myCiphers.createSymKeyCipher(pCipherSpec);</span>

        /* If we need an IV */
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (pCipherSpec.needsIV()) {</span>
            /* Calculate the IV */
<span class="fc" id="L237">            final byte[] myIV = deriveIV(pSecret, pCipherSpec.getIVLength());</span>

            /* Initialise the ciphers */
<span class="fc" id="L240">            final GordianCipherParameters myParms = GordianCipherParameters.keyAndNonce(myKey, myIV);</span>
<span class="fc" id="L241">            myOutCipher.initForEncrypt(myParms);</span>
<span class="fc" id="L242">            myInCipher.initForDecrypt(myParms);</span>

            /* else no IV */
<span class="fc" id="L245">        } else {</span>
<span class="nc" id="L246">            final GordianCipherParameters myParms = GordianCipherParameters.key(myKey);</span>
<span class="nc" id="L247">            myOutCipher.initForEncrypt(myParms);</span>
<span class="nc" id="L248">            myInCipher.initForDecrypt(myParms);</span>
        }
<span class="fc" id="L250">        return new GordianSymCipher[] { myOutCipher, myInCipher };</span>
    }

    /**
     * Derive a streamKeyCipher pair from the secret.
     * @param pCipherSpec the cipherSpec
     * @param pSecret the secret
     * @return the ciphers
     * @throws GordianException on error
     */
    private GordianStreamCipher[] deriveCipher(final GordianStreamCipherSpec pCipherSpec,
                                               final byte[] pSecret) throws GordianException {
        /* Derive a shared factory */
<span class="fc" id="L263">        final GordianFactory myFactory = deriveFactory(GordianFactoryType.BC, pSecret);</span>

        /* Generate the key */
<span class="fc" id="L266">        final GordianKey&lt;GordianStreamKeySpec&gt; myKey = deriveKey(myFactory, pCipherSpec.getKeyType(), pSecret);</span>

        /* Create the ciphers */
<span class="fc" id="L269">        final GordianCipherFactory myCiphers = myFactory.getCipherFactory();</span>
<span class="fc" id="L270">        final GordianStreamCipher myOutCipher = myCiphers.createStreamKeyCipher(pCipherSpec);</span>
<span class="fc" id="L271">        final GordianStreamCipher myInCipher = myCiphers.createStreamKeyCipher(pCipherSpec);</span>

        /* If we need an IV */
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (pCipherSpec.needsIV()) {</span>
            /* Calculate the IV */
<span class="fc" id="L276">            final byte[] myIV = deriveIV(pSecret, pCipherSpec.getIVLength());</span>

            /* Initialise the ciphers */
<span class="fc" id="L279">            final GordianCipherParameters myParms = GordianCipherParameters.keyAndNonce(myKey, myIV);</span>
<span class="fc" id="L280">            myOutCipher.initForEncrypt(myParms);</span>
<span class="fc" id="L281">            myInCipher.initForDecrypt(myParms);</span>

            /* else no IV */
<span class="fc" id="L284">        } else {</span>
            /* Initialise the ciphers */
<span class="nc" id="L286">            final GordianCipherParameters myParms = GordianCipherParameters.key(myKey);</span>
<span class="nc" id="L287">            myOutCipher.initForEncrypt(myParms);</span>
<span class="nc" id="L288">            myInCipher.initForDecrypt(myParms);</span>
        }
<span class="fc" id="L290">        return new GordianStreamCipher[] { myOutCipher, myInCipher };</span>
    }

    /**
     * Derive a key from the secret.
     * @param &lt;T&gt; the key type
     * @param pFactory the factory
     * @param pKeyType the keyType
     * @param pSecret the secret
     * @return the key
     * @throws GordianException on error
     */
    private &lt;T extends GordianKeySpec&gt; GordianKey&lt;T&gt; deriveKey(final GordianFactory pFactory,
                                                               final T pKeyType,
                                                               final byte[] pSecret) throws GordianException {
        /* Ensure that we clear out the key */
<span class="fc" id="L306">        byte[] myKey = null;</span>
        try {
            /* Calculate the secret */
<span class="fc" id="L309">            myKey = calculateDerivedSecret(pSecret, GordianDerivationId.KEY, pKeyType.getKeyLength().getByteLength());</span>

            /* Derive the key */
<span class="fc" id="L312">            final GordianCipherFactory myCiphers = pFactory.getCipherFactory();</span>
<span class="fc" id="L313">            final GordianCoreKeyGenerator&lt;T&gt; myGenerator = (GordianCoreKeyGenerator&lt;T&gt;) myCiphers.getKeyGenerator(pKeyType);</span>
<span class="fc" id="L314">            return myGenerator.buildKeyFromBytes(myKey);</span>

            /* Clear buffers */
        } finally {
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">            if (myKey != null) {</span>
<span class="fc" id="L319">                Arrays.fill(myKey, (byte) 0);</span>
            }
        }
    }

    /**
     * Calculate the derived IV.
     * @param pSecret the secret
     * @param pIVLen the IV length
     * @return the derived IV
     * @throws GordianException on error
     */
    private byte[] deriveIV(final byte[] pSecret,
                            final int pIVLen) throws GordianException {
        /* Calculate the secret */
<span class="fc" id="L334">        return calculateDerivedSecret(pSecret, GordianDerivationId.IV, pIVLen);</span>
    }

    /**
     * Derive bytes.
     * @param pSecret the secret
     * @param pLength the length of bytes
     * @return the factory
     * @throws GordianException on error
     */
    private byte[] deriveBytes(final byte[] pSecret,
                               final int pLength) throws GordianException {
        /* Return the secret */
<span class="fc" id="L347">        return calculateDerivedSecret(pSecret, GordianDerivationId.BYTES, pLength);</span>
    }

    /**
     * Calculate the derived secret.
     * @param pSecret the secret
     * @param pId the derivation Id
     * @param pResultLen the length of the result
     * @return the derived secret
     * @throws GordianException on error
     */
    byte[] calculateDerivedSecret(final byte[] pSecret,
                                  final GordianDerivationId pId,
                                  final int pResultLen) throws GordianException {
        /* Build the 64-bit seed and create the seeded random */
<span class="fc" id="L362">        final long mySeed = GordianDataConverter.byteArrayToLong(pSecret);</span>
<span class="fc" id="L363">        final Random myRandom = new Random(mySeed);</span>

        /* Protect against exceptions */
<span class="fc" id="L366">        final GordianHKDFParams myParams = GordianHKDFParams.extractThenExpand(pResultLen);</span>
        try {
            /* Customise the HKDF parameters */
<span class="fc" id="L369">            final GordianDigestSpec myDigestSpec = new GordianDigestSpec(pId.getDigestType());</span>
<span class="fc" id="L370">            final byte[] myBytes = new byte[Long.BYTES];</span>
<span class="fc" id="L371">            myRandom.nextBytes(myBytes);</span>
<span class="fc" id="L372">            myParams.withIKM(pSecret).withIKM(pId.getId())</span>
<span class="fc" id="L373">                    .withSalt(theClientIV).withSalt(theServerIV)</span>
<span class="fc" id="L374">                    .withInfo(myBytes);</span>

            /* Derive the bytes */
<span class="fc" id="L377">            final GordianHKDFEngine myEngine = new GordianHKDFEngine(theFactory, myDigestSpec);</span>
<span class="fc" id="L378">            return myEngine.deriveBytes(myParams);</span>

        } finally {
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">            if (myParams != null) {</span>
<span class="fc" id="L382">                myParams.clearParameters();</span>
            }
        }
    }

    /**
     * Derived secret id.
     */
<span class="fc" id="L390">    public enum GordianDerivationId {</span>
        /**
         * Factory.
         */
<span class="fc" id="L394">        FACTORY(&quot;Factory&quot;),</span>

        /**
         * KeySet.
         */
<span class="fc" id="L399">        KEYSET(&quot;KeySet&quot;),</span>

        /**
         * Key.
         */
<span class="fc" id="L404">        KEY(&quot;Key&quot;),</span>

        /**
         * IV.
         */
<span class="fc" id="L409">        IV(&quot;IV&quot;),</span>

        /**
         * Bytes.
         */
<span class="fc" id="L414">        BYTES(&quot;Bytes&quot;),</span>

        /**
         * Tags.
         */
<span class="fc" id="L419">        TAGS(&quot;Tags&quot;),</span>

        /**
         * Composite.
         */
<span class="fc" id="L424">        COMPOSITE(&quot;Composite&quot;);</span>

        /**
         * The id.
         */
        private final byte[] theId;

        /**
         * Constructor.
         * @param pId the id
         */
<span class="fc" id="L435">        GordianDerivationId(final String pId) {</span>
<span class="fc" id="L436">            theId = pId.getBytes(StandardCharsets.UTF_8);</span>
<span class="fc" id="L437">        }</span>

        /**
         * Obtain the id.
         * @return the id.
         */
        byte[] getId() {
<span class="fc" id="L444">            return theId;</span>
        }

        /**
         * Obtain digest type for id.
         * @return the id
         */
        public GordianDigestType getDigestType() {
            /*
             * Assign a different digestType to each Id.
             * Note that each type must nbe available as an HMAC in JCA.
             */
<span class="pc bpc" id="L456" title="1 of 8 branches missed.">            switch (this) {</span>
                case FACTORY:
<span class="fc" id="L458">                    return GordianDigestType.SHA3;</span>
                case KEYSET:
<span class="fc" id="L460">                    return GordianDigestType.SHA2;</span>
                case KEY:
<span class="fc" id="L462">                    return GordianDigestType.SKEIN;</span>
                case IV:
<span class="fc" id="L464">                    return GordianDigestType.RIPEMD;</span>
                case BYTES:
<span class="fc" id="L466">                    return GordianDigestType.STREEBOG;</span>
                case TAGS:
<span class="fc" id="L468">                    return GordianDigestType.WHIRLPOOL;</span>
                case COMPOSITE:
<span class="fc" id="L470">                    return GordianDigestType.SM3;</span>
                default:
<span class="nc" id="L472">                    throw new IllegalArgumentException(&quot;Invalid ID&quot;);</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
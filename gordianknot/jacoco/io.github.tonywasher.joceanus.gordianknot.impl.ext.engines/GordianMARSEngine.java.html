<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianMARSEngine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">io.github.tonywasher.joceanus.gordianknot.impl.ext.engines</a> &gt; <span class="el_source">GordianMARSEngine.java</span></div><h1>GordianMARSEngine.java</h1><pre class="source lang-java linenums">/*
 * GordianKnot: Security Suite
 * Copyright 2012-2026. Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.github.tonywasher.joceanus.gordianknot.impl.ext.engines;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.params.KeyParameter;

/**
 * MARSEngine ported from the reference C implementation, found at https://embeddedsw.net/Cipher_Reference_Home.html.
 */
@SuppressWarnings(&quot;checkstyle:MagicNumber&quot;)
<span class="fc" id="L29">public class GordianMARSEngine</span>
        implements BlockCipher {
    /**
     * BlockSize in bits.
     */
    private static final int BLOCKSIZE = 128;

    /**
     * BlockSize in bytes.
     */
    private static final int BLOCKSIZEB = (BLOCKSIZE / 8);

    /**
     * BlockSize in Integers.
     */
    private static final int INTLENGTH = BLOCKSIZEB / Integer.BYTES;

    /**
     * Encryption flag.
     */
    private Boolean forEncryption;

    /**
     * Input buffer.
     */
<span class="fc" id="L54">    private final int[] input = new int[INTLENGTH];</span>

    /**
     * Output buffer.
     */
<span class="fc" id="L59">    private final int[] output = new int[INTLENGTH];</span>

    /**
     * SBox.
     */
<span class="fc" id="L64">    private static final int[] S_BOX = {</span>
            0x09d0c479, 0x28c8ffe0, 0x84aa6c39, 0x9dad7287, /* 0x000 */
            0x7dff9be3, 0xd4268361, 0xc96da1d4, 0x7974cc93,
            0x85d0582e, 0x2a4b5705, 0x1ca16a62, 0xc3bd279d,
            0x0f1f25e5, 0x5160372f, 0xc695c1fb, 0x4d7ff1e4,
            0xae5f6bf4, 0x0d72ee46, 0xff23de8a, 0xb1cf8e83, /* 0x010 */
            0xf14902e2, 0x3e981e42, 0x8bf53eb6, 0x7f4bf8ac,
            0x83631f83, 0x25970205, 0x76afe784, 0x3a7931d4,
            0x4f846450, 0x5c64c3f6, 0x210a5f18, 0xc6986a26,
            0x28f4e826, 0x3a60a81c, 0xd340a664, 0x7ea820c4, /* 0x020 */
            0x526687c5, 0x7eddd12b, 0x32a11d1d, 0x9c9ef086,
            0x80f6e831, 0xab6f04ad, 0x56fb9b53, 0x8b2e095c,
            0xb68556ae, 0xd2250b0d, 0x294a7721, 0xe21fb253,
            0xae136749, 0xe82aae86, 0x93365104, 0x99404a66, /* 0x030 */
            0x78a784dc, 0xb69ba84b, 0x04046793, 0x23db5c1e,
            0x46cae1d6, 0x2fe28134, 0x5a223942, 0x1863cd5b,
            0xc190c6e3, 0x07dfb846, 0x6eb88816, 0x2d0dcc4a,
            0xa4ccae59, 0x3798670d, 0xcbfa9493, 0x4f481d45, /* 0x040 */
            0xeafc8ca8, 0xdb1129d6, 0xb0449e20, 0x0f5407fb,
            0x6167d9a8, 0xd1f45763, 0x4daa96c3, 0x3bec5958,
            0xababa014, 0xb6ccd201, 0x38d6279f, 0x02682215,
            0x8f376cd5, 0x092c237e, 0xbfc56593, 0x32889d2c, /* 0x050 */
            0x854b3e95, 0x05bb9b43, 0x7dcd5dcd, 0xa02e926c,
            0xfae527e5, 0x36a1c330, 0x3412e1ae, 0xf257f462,
            0x3c4f1d71, 0x30a2e809, 0x68e5f551, 0x9c61ba44,
            0x5ded0ab8, 0x75ce09c8, 0x9654f93e, 0x698c0cca, /* 0x060 */
            0x243cb3e4, 0x2b062b97, 0x0f3b8d9e, 0x00e050df,
            0xfc5d6166, 0xe35f9288, 0xc079550d, 0x0591aee8,
            0x8e531e74, 0x75fe3578, 0x2f6d829a, 0xf60b21ae,
            0x95e8eb8d, 0x6699486b, 0x901d7d9b, 0xfd6d6e31, /* 0x070 */
            0x1090acef, 0xe0670dd8, 0xdab2e692, 0xcd6d4365,
            0xe5393514, 0x3af345f0, 0x6241fc4d, 0x460da3a3,
            0x7bcf3729, 0x8bf1d1e0, 0x14aac070, 0x1587ed55,
            0x3afd7d3e, 0xd2f29e01, 0x29a9d1f6, 0xefb10c53, /* 0x080 */
            0xcf3b870f, 0xb414935c, 0x664465ed, 0x024acac7,
            0x59a744c1, 0x1d2936a7, 0xdc580aa6, 0xcf574ca8,
            0x040a7a10, 0x6cd81807, 0x8a98be4c, 0xaccea063,
            0xc33e92b5, 0xd1e0e03d, 0xb322517e, 0x2092bd13, /* 0x090 */
            0x386b2c4a, 0x52e8dd58, 0x58656dfb, 0x50820371,
            0x41811896, 0xe337ef7e, 0xd39fb119, 0xc97f0df6,
            0x68fea01b, 0xa150a6e5, 0x55258962, 0xeb6ff41b,
            0xd7c9cd7a, 0xa619cd9e, 0xbcf09576, 0x2672c073, /* 0x0a0 */
            0xf003fb3c, 0x4ab7a50b, 0x1484126a, 0x487ba9b1,
            0xa64fc9c6, 0xf6957d49, 0x38b06a75, 0xdd805fcd,
            0x63d094cf, 0xf51c999e, 0x1aa4d343, 0xb8495294,
            0xce9f8e99, 0xbffcd770, 0xc7c275cc, 0x378453a7, /* 0x0b0 */
            0x7b21be33, 0x397f41bd, 0x4e94d131, 0x92cc1f98,
            0x5915ea51, 0x99f861b7, 0xc9980a88, 0x1d74fd5f,
            0xb0a495f8, 0x614deed0, 0xb5778eea, 0x5941792d,
            0xfa90c1f8, 0x33f824b4, 0xc4965372, 0x3ff6d550, /* 0x0c0 */
            0x4ca5fec0, 0x8630e964, 0x5b3fbbd6, 0x7da26a48,
            0xb203231a, 0x04297514, 0x2d639306, 0x2eb13149,
            0x16a45272, 0x532459a0, 0x8e5f4872, 0xf966c7d9,
            0x07128dc0, 0x0d44db62, 0xafc8d52d, 0x06316131, /* 0x0d0 */
            0xd838e7ce, 0x1bc41d00, 0x3a2e8c0f, 0xea83837e,
            0xb984737d, 0x13ba4891, 0xc4f8b949, 0xa6d6acb3,
            0xa215cdce, 0x8359838b, 0x6bd1aa31, 0xf579dd52,
            0x21b93f93, 0xf5176781, 0x187dfdde, 0xe94aeb76, /* 0x0e0 */
            0x2b38fd54, 0x431de1da, 0xab394825, 0x9ad3048f,
            0xdfea32aa, 0x659473e3, 0x623f7863, 0xf3346c59,
            0xab3ab685, 0x3346a90b, 0x6b56443e, 0xc6de01f8,
            0x8d421fc0, 0x9b0ed10c, 0x88f1a1e9, 0x54c1f029, /* 0x0f0 */
            0x7dead57b, 0x8d7ba426, 0x4cf5178a, 0x551a7cca,
            0x1a9a5f08, 0xfcd651b9, 0x25605182, 0xe11fc6c3,
            0xb6fd9676, 0x337b3027, 0xb7c8eb14, 0x9e5fd030,
            0x6b57e354, 0xad913cf7, 0x7e16688d, 0x58872a69, /* 0x100 */
            0x2c2fc7df, 0xe389ccc6, 0x30738df1, 0x0824a734,
            0xe1797a8b, 0xa4a8d57b, 0x5b5d193b, 0xc8a8309b,
            0x73f9a978, 0x73398d32, 0x0f59573e, 0xe9df2b03,
            0xe8a5b6c8, 0x848d0704, 0x98df93c2, 0x720a1dc3, /* 0x110 */
            0x684f259a, 0x943ba848, 0xa6370152, 0x863b5ea3,
            0xd17b978b, 0x6d9b58ef, 0x0a700dd4, 0xa73d36bf,
            0x8e6a0829, 0x8695bc14, 0xe35b3447, 0x933ac568,
            0x8894b022, 0x2f511c27, 0xddfbcc3c, 0x006662b6, /* 0x120 */
            0x117c83fe, 0x4e12b414, 0xc2bca766, 0x3a2fec10,
            0xf4562420, 0x55792e2a, 0x46f5d857, 0xceda25ce,
            0xc3601d3b, 0x6c00ab46, 0xefac9c28, 0xb3c35047,
            0x611dfee3, 0x257c3207, 0xfdd58482, 0x3b14d84f, /* 0x130 */
            0x23becb64, 0xa075f3a3, 0x088f8ead, 0x07adf158,
            0x7796943c, 0xfacabf3d, 0xc09730cd, 0xf7679969,
            0xda44e9ed, 0x2c854c12, 0x35935fa3, 0x2f057d9f,
            0x690624f8, 0x1cb0bafd, 0x7b0dbdc6, 0x810f23bb, /* 0x140 */
            0xfa929a1a, 0x6d969a17, 0x6742979b, 0x74ac7d05,
            0x010e65c4, 0x86a3d963, 0xf907b5a0, 0xd0042bd3,
            0x158d7d03, 0x287a8255, 0xbba8366f, 0x096edc33,
            0x21916a7b, 0x77b56b86, 0x951622f9, 0xa6c5e650, /* 0x150 */
            0x8cea17d1, 0xcd8c62bc, 0xa3d63433, 0x358a68fd,
            0x0f9b9d3c, 0xd6aa295b, 0xfe33384a, 0xc000738e,
            0xcd67eb2f, 0xe2eb6dc2, 0x97338b02, 0x06c9f246,
            0x419cf1ad, 0x2b83c045, 0x3723f18a, 0xcb5b3089, /* 0x160 */
            0x160bead7, 0x5d494656, 0x35f8a74b, 0x1e4e6c9e,
            0x000399bd, 0x67466880, 0xb4174831, 0xacf423b2,
            0xca815ab3, 0x5a6395e7, 0x302a67c5, 0x8bdb446b,
            0x108f8fa4, 0x10223eda, 0x92b8b48b, 0x7f38d0ee, /* 0x170 */
            0xab2701d4, 0x0262d415, 0xaf224a30, 0xb3d88aba,
            0xf8b2c3af, 0xdaf7ef70, 0xcc97d3b7, 0xe9614b6c,
            0x2baebff4, 0x70f687cf, 0x386c9156, 0xce092ee5,
            0x01e87da6, 0x6ce91e6a, 0xbb7bcc84, 0xc7922c20, /* 0x180 */
            0x9d3b71fd, 0x060e41c6, 0xd7590f15, 0x4e03bb47,
            0x183c198e, 0x63eeb240, 0x2ddbf49a, 0x6d5cba54,
            0x923750af, 0xf9e14236, 0x7838162b, 0x59726c72,
            0x81b66760, 0xbb2926c1, 0x48a0ce0d, 0xa6c0496d, /* 0x190 */
            0xad43507b, 0x718d496a, 0x9df057af, 0x44b1bde6,
            0x054356dc, 0xde7ced35, 0xd51a138b, 0x62088cc9,
            0x35830311, 0xc96efca2, 0x686f86ec, 0x8e77cb68,
            0x63e1d6b8, 0xc80f9778, 0x79c491fd, 0x1b4c67f2, /* 0x1a0 */
            0x72698d7d, 0x5e368c31, 0xf7d95e2e, 0xa1d3493f,
            0xdcd9433e, 0x896f1552, 0x4bc4ca7a, 0xa6d1baf4,
            0xa5a96dcc, 0x0bef8b46, 0xa169fda7, 0x74df40b7,
            0x4e208804, 0x9a756607, 0x038e87c8, 0x20211e44, /* 0x1b0 */
            0x8b7ad4bf, 0xc6403f35, 0x1848e36d, 0x80bdb038,
            0x1e62891c, 0x643d2107, 0xbf04d6f8, 0x21092c8c,
            0xf644f389, 0x0778404e, 0x7b78adb8, 0xa2c52d53,
            0x42157abe, 0xa2253e2e, 0x7bf3f4ae, 0x80f594f9, /* 0x1c0 */
            0x953194e7, 0x77eb92ed, 0xb3816930, 0xda8d9336,
            0xbf447469, 0xf26d9483, 0xee6faed5, 0x71371235,
            0xde425f73, 0xb4e59f43, 0x7dbe2d4e, 0x2d37b185,
            0x49dc9a63, 0x98c39d98, 0x1301c9a2, 0x389b1bbf, /* 0x1d0 */
            0x0c18588d, 0xa421c1ba, 0x7aa3865c, 0x71e08558,
            0x3c5cfcaa, 0x7d239ca4, 0x0297d9dd, 0xd7dc2830,
            0x4b37802b, 0x7428ab54, 0xaeee0347, 0x4b3fbb85,
            0x692f2f08, 0x134e578e, 0x36d9e0bf, 0xae8b5fcf, /* 0x1e0 */
            0xedb93ecf, 0x2b27248e, 0x170eb1ef, 0x7dc57fd6,
            0x1e760f16, 0xb1136601, 0x864e1b9b, 0xd7ea7319,
            0x3ab871bd, 0xcfa4d76f, 0xe31bd782, 0x0dbeb469,
            0xabb96061, 0x5370f85d, 0xffb07e37, 0xda30d0fb, /* 0x1f0 */
            0xebc977b6, 0x0b98b40f, 0x3a4d0fe6, 0xdf4fc26b,
            0x159cf22a, 0xc298d6e2, 0x2b78ef6a, 0x61a94ac0,
            0xab561187, 0x14eea0f0, 0xdf0d4164, 0x19af70ee
    };

    /**
     * VK.
     */
<span class="fc" id="L198">    private final int[] vk = {</span>
            0x09d0c479, 0x28c8ffe0, 0x84aa6c39, 0x9dad7287, 0x7dff9be3, 0xd4268361, /* 6 */
            0xc96da1d4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 20 */
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 37 */
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /* 47 */
    };

    /**
     * lKey.
     */
<span class="fc" id="L208">    private final int[] lKey = new int[40];</span>

    private static int rotr(final int x, final int n) {
<span class="fc" id="L211">        return ((x &gt;&gt;&gt; n) | (x &lt;&lt; (32 - n)));</span>
    }

    private static int rotl(final int x, final int n) {
<span class="fc" id="L215">        return ((x &lt;&lt; n) | (x &gt;&gt;&gt; (32 - n)));</span>
    }

    private static void fMix(final int[] vals, final int offset) {
        /* Decide correct offsets */
<span class="fc" id="L220">        int myOffset = offset;</span>
<span class="fc" id="L221">        final int a = myOffset++ % 4;</span>
<span class="fc" id="L222">        final int b = myOffset++ % 4;</span>
<span class="fc" id="L223">        final int c = myOffset++ % 4;</span>
<span class="fc" id="L224">        final int d = myOffset % 4;</span>

        /* Perform mix */
<span class="fc" id="L227">        int r = rotr(vals[a], 8);</span>
<span class="fc" id="L228">        vals[b] ^= S_BOX[vals[a] &amp; 255];</span>
<span class="fc" id="L229">        vals[b] += S_BOX[(r &amp; 255) + 256];</span>
<span class="fc" id="L230">        r = rotr(vals[a], 16);</span>
<span class="fc" id="L231">        vals[a] = rotr(vals[a], 24);</span>
<span class="fc" id="L232">        vals[c] += S_BOX[r &amp; 255];</span>
<span class="fc" id="L233">        vals[d] ^= S_BOX[(vals[a] &amp; 255) + 256];</span>
<span class="fc" id="L234">    }</span>

    private static void bMix(final int[] vals, final int offset) {
        /* Decide correct offsets */
<span class="fc" id="L238">        int myOffset = offset;</span>
<span class="fc" id="L239">        final int a = myOffset++ % 4;</span>
<span class="fc" id="L240">        final int b = myOffset++ % 4;</span>
<span class="fc" id="L241">        final int c = myOffset++ % 4;</span>
<span class="fc" id="L242">        final int d = myOffset % 4;</span>

        /* Perform mix */
<span class="fc" id="L245">        int r = rotl(vals[a], 8);</span>
<span class="fc" id="L246">        vals[b] ^= S_BOX[(vals[a] &amp; 255) + 256];</span>
<span class="fc" id="L247">        vals[c] -= S_BOX[r &amp; 255];</span>
<span class="fc" id="L248">        r = rotl(vals[a], 16);</span>
<span class="fc" id="L249">        vals[a] = rotl(vals[a], 24);</span>
<span class="fc" id="L250">        vals[d] -= S_BOX[(r &amp; 255) + 256];</span>
<span class="fc" id="L251">        vals[d] ^= S_BOX[vals[a] &amp; 255];</span>
<span class="fc" id="L252">    }</span>

    private void fKtr(final int[] vals, final int i, final int offset, final boolean doSwitch) {
        /* Decide correct offsets */
<span class="fc" id="L256">        int myOffset = offset;</span>
<span class="fc" id="L257">        final int a = myOffset++ % 4;</span>
<span class="fc" id="L258">        int b = myOffset++ % 4;</span>
<span class="fc" id="L259">        final int c = myOffset++ % 4;</span>
<span class="fc" id="L260">        int d = myOffset % 4;</span>

        /* Switch b and c if required */
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (doSwitch) {</span>
<span class="fc" id="L264">            final int temp = b;</span>
<span class="fc" id="L265">            b = d;</span>
<span class="fc" id="L266">            d = temp;</span>
        }

        /* Perform operation */
<span class="fc" id="L270">        final int m = vals[a] + lKey[i];</span>
<span class="fc" id="L271">        vals[a] = rotl(vals[a], 13);</span>
<span class="fc" id="L272">        int r = vals[a] * lKey[i + 1];</span>
<span class="fc" id="L273">        int l = S_BOX[m &amp; 511];</span>
<span class="fc" id="L274">        r = rotl(r, 5);</span>
<span class="fc" id="L275">        vals[c] += rotl(m, r);</span>
<span class="fc" id="L276">        l ^= r;</span>
<span class="fc" id="L277">        r = rotl(r, 5);</span>
<span class="fc" id="L278">        l ^= r;</span>
<span class="fc" id="L279">        vals[d] ^= r;</span>
<span class="fc" id="L280">        vals[b] += rotl(l, r);</span>
<span class="fc" id="L281">    }</span>

    private void rKtr(final int[] vals, final int i, final int offset, final boolean doSwitch) {
        /* Decide correct offsets */
<span class="fc" id="L285">        int myOffset = offset;</span>
<span class="fc" id="L286">        final int a = myOffset++ % 4;</span>
<span class="fc" id="L287">        int b = myOffset++ % 4;</span>
<span class="fc" id="L288">        final int c = myOffset++ % 4;</span>
<span class="fc" id="L289">        int d = myOffset % 4;</span>

        /* Switch b and c if required */
<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (doSwitch) {</span>
<span class="fc" id="L293">            final int temp = b;</span>
<span class="fc" id="L294">            b = d;</span>
<span class="fc" id="L295">            d = temp;</span>
        }

        /* Perform operation */
<span class="fc" id="L299">        int r = vals[a] * lKey[i + 1];</span>
<span class="fc" id="L300">        vals[a] = rotr(vals[a], 13);</span>
<span class="fc" id="L301">        final int m = vals[a] + lKey[i];</span>
<span class="fc" id="L302">        int l = S_BOX[m &amp; 511];</span>
<span class="fc" id="L303">        r = rotl(r, 5);</span>
<span class="fc" id="L304">        l ^= r;</span>
<span class="fc" id="L305">        vals[c] -= rotl(m, r);</span>
<span class="fc" id="L306">        r = rotl(r, 5);</span>
<span class="fc" id="L307">        l ^= r;</span>
<span class="fc" id="L308">        vals[d] ^= r;</span>
<span class="fc" id="L309">        vals[b] -= rotl(l, r);</span>
<span class="fc" id="L310">    }</span>

    /* For a 32 bit word (x) generate a mask (m) such that a bit in */
    /* m is set to 1 if and only if the corresponding bit in x is: */
    /*                                                              */
    /* 1. in a sequence of 10 or more adjacent '0' bits */
    /* 2. in a sequence of 10 or more adjacent '1' bits */
    /* 3. but is not either endpoint of such a sequence unless such */
    /* an endpoint is at the top bit (bit 31) of a word and is */
    /* in a sequence of '0' bits. */
    /*                                                              */
    /* The only situation in which a sequence endpoint is included */
    /* in the mask is hence when the endpoint is at bit 31 and is */
    /* the endpoint of a sequence of '0' bits. My thanks go to Shai */
    /* Halevi of IBM for the neat trick (which I missed) of finding */
    /* the '0' and '1' sequences at the same time. */
    private static int genMask(final int x) {
        /* if m{bn} stands for bit number bn of m, set m{bn} = 1 if */
        /* x{bn} == x{bn+1} for 0 &lt;= bn &lt;= 30. That is, set a bit */
        /* in m if the corresponding bit and the next higher bit in */
        /* x are equal in value (set m{31} = 0). */
<span class="fc" id="L331">        int m = (~x ^ (x &gt;&gt;&gt; 1)) &amp; 0x7fffffff;</span>

        /* Sequences of 9 '1' bits in m now correspond to sequences */
        /* of 10 '0's or 10 '1' bits in x. Shift and 'and' bits in */
        /* m to find sequences of 9 or more '1' bits. As a result */
        /* bits in m are set if they are at the bottom of sequences */
        /* of 10 adjacent '0's or 10 adjacent '1's in x. */
<span class="fc" id="L338">        m &amp;= (m &gt;&gt;&gt; 1) &amp; (m &gt;&gt;&gt; 2);</span>
<span class="fc" id="L339">        m &amp;= (m &gt;&gt;&gt; 3) &amp; (m &gt;&gt;&gt; 6);</span>

        /* return if mask is empty - no key fixing needed */
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (m == 0) {</span>
<span class="fc" id="L343">            return 0;</span>
        }

        /* We need the internal bits in each continuous sequence of */
        /* matching bits (that is the bits less the two endpoints). */
        /* We thus propagate each set bit into the 8 internal bits */
        /* that it represents, starting 1 left and finsihing 8 left */
        /* of its position. */
<span class="fc" id="L351">        m &lt;&lt;= 1;</span>
<span class="fc" id="L352">        m |= (m &lt;&lt; 1);</span>
<span class="fc" id="L353">        m |= (m &lt;&lt; 2);</span>
<span class="fc" id="L354">        m |= (m &lt;&lt; 4);</span>

        /* m is now correct except for the odd behaviour of bit 31, */
        /* that is, it will be set if it is in a sequence of 10 or */
        /* more '0's and clear otherwise. */
<span class="fc" id="L359">        m |= (m &lt;&lt; 1) &amp; ~x &amp; 0x80000000;</span>
<span class="fc" id="L360">        return m &amp; 0xfffffffc;</span>
    }

    /* My thanks to Louis Granboulan for spotting an error in the */
    /* previous version of set_key. */
    private int[] setKey(final int[] inKey, final int keyLen) {
        int w;
<span class="fc" id="L367">        int m = keyLen / 32 - 1;</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">        for (int i = 0, j = 0; i &lt; 39; ++i) {</span>
<span class="fc" id="L369">            vk[i + 7] = rotl(vk[i] ^ vk[i + 5], 3) ^ inKey[j] ^ i;</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">            j = (j == m</span>
<span class="fc" id="L371">                    ? 0</span>
<span class="fc" id="L372">                    : j + 1);</span>
        }

<span class="fc" id="L375">        vk[46] = keyLen / 32;</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">        for (int j = 0; j &lt; 7; ++j) {</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            for (int i = 1; i &lt; 40; ++i) {</span>
<span class="fc" id="L379">                vk[i + 7] = rotl(vk[i + 7] + S_BOX[vk[i + 6] &amp; 511], 9);</span>
            }
<span class="fc" id="L381">            vk[7] = rotl(vk[7] + S_BOX[vk[46] &amp; 511], 9);</span>
        }

<span class="fc bfc" id="L384" title="All 2 branches covered.">        for (int i = 0, j = 0; i &lt; 40; ++i) {</span>
<span class="fc" id="L385">            lKey[j] = vk[i + 7];</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            j = (j &lt; 33</span>
<span class="fc" id="L387">                    ? j + 7</span>
<span class="fc" id="L388">                    : j - 33);</span>
        }

<span class="fc bfc" id="L391" title="All 2 branches covered.">        for (int i = 5; i &lt; 37; i += 2) {</span>
<span class="fc" id="L392">            w = lKey[i] | 3;</span>
<span class="fc" id="L393">            m = genMask(w);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">            if (m != 0) {</span>
<span class="fc" id="L395">                w ^= (rotl(S_BOX[265 + (lKey[i] &amp; 3)], lKey[i + 3] &amp; 31) &amp; m);</span>
            }
<span class="fc" id="L397">            lKey[i] = w;</span>
        }
<span class="fc" id="L399">        return lKey;</span>
    }

    private void encrypt(final int[] inBlk, final int[] outBlk) {
<span class="fc" id="L403">        final int[] vals = new int[4];</span>

<span class="fc" id="L405">        vals[0] = inBlk[0] + lKey[0];</span>
<span class="fc" id="L406">        vals[1] = inBlk[1] + lKey[1];</span>
<span class="fc" id="L407">        vals[2] = inBlk[2] + lKey[2];</span>
<span class="fc" id="L408">        vals[3] = inBlk[3] + lKey[3];</span>

<span class="fc" id="L410">        fMix(vals, 0);</span>
<span class="fc" id="L411">        vals[0] += vals[3];</span>
<span class="fc" id="L412">        fMix(vals, 1);</span>
<span class="fc" id="L413">        vals[1] += vals[2];</span>
<span class="fc" id="L414">        fMix(vals, 2);</span>
<span class="fc" id="L415">        fMix(vals, 3);</span>

<span class="fc" id="L417">        fMix(vals, 0);</span>
<span class="fc" id="L418">        vals[0] += vals[3];</span>
<span class="fc" id="L419">        fMix(vals, 1);</span>
<span class="fc" id="L420">        vals[1] += vals[2];</span>
<span class="fc" id="L421">        fMix(vals, 2);</span>
<span class="fc" id="L422">        fMix(vals, 3);</span>

<span class="fc" id="L424">        fKtr(vals, 4, 0, false);</span>
<span class="fc" id="L425">        fKtr(vals, 6, 1, false);</span>
<span class="fc" id="L426">        fKtr(vals, 8, 2, false);</span>
<span class="fc" id="L427">        fKtr(vals, 10, 3, false);</span>
<span class="fc" id="L428">        fKtr(vals, 12, 0, false);</span>
<span class="fc" id="L429">        fKtr(vals, 14, 1, false);</span>
<span class="fc" id="L430">        fKtr(vals, 16, 2, false);</span>
<span class="fc" id="L431">        fKtr(vals, 18, 3, false);</span>
<span class="fc" id="L432">        fKtr(vals, 20, 0, true);</span>
<span class="fc" id="L433">        fKtr(vals, 22, 1, true);</span>
<span class="fc" id="L434">        fKtr(vals, 24, 2, true);</span>
<span class="fc" id="L435">        fKtr(vals, 26, 3, true);</span>
<span class="fc" id="L436">        fKtr(vals, 28, 0, true);</span>
<span class="fc" id="L437">        fKtr(vals, 30, 1, true);</span>
<span class="fc" id="L438">        fKtr(vals, 32, 2, true);</span>
<span class="fc" id="L439">        fKtr(vals, 34, 3, true);</span>

<span class="fc" id="L441">        bMix(vals, 0);</span>
<span class="fc" id="L442">        bMix(vals, 1);</span>
<span class="fc" id="L443">        vals[2] -= vals[1];</span>
<span class="fc" id="L444">        bMix(vals, 2);</span>
<span class="fc" id="L445">        vals[3] -= vals[0];</span>
<span class="fc" id="L446">        bMix(vals, 3);</span>

<span class="fc" id="L448">        bMix(vals, 0);</span>
<span class="fc" id="L449">        bMix(vals, 1);</span>
<span class="fc" id="L450">        vals[2] -= vals[1];</span>
<span class="fc" id="L451">        bMix(vals, 2);</span>
<span class="fc" id="L452">        vals[3] -= vals[0];</span>
<span class="fc" id="L453">        bMix(vals, 3);</span>

<span class="fc" id="L455">        outBlk[0] = vals[0] - lKey[36];</span>
<span class="fc" id="L456">        outBlk[1] = vals[1] - lKey[37];</span>
<span class="fc" id="L457">        outBlk[2] = vals[2] - lKey[38];</span>
<span class="fc" id="L458">        outBlk[3] = vals[3] - lKey[39];</span>
<span class="fc" id="L459">    }</span>

    private void decrypt(final int[] inBlk, final int[] outBlk) {
<span class="fc" id="L462">        final int[] vals = new int[4];</span>

<span class="fc" id="L464">        vals[3] = inBlk[0] + lKey[36];</span>
<span class="fc" id="L465">        vals[2] = inBlk[1] + lKey[37];</span>
<span class="fc" id="L466">        vals[1] = inBlk[2] + lKey[38];</span>
<span class="fc" id="L467">        vals[0] = inBlk[3] + lKey[39];</span>

<span class="fc" id="L469">        fMix(vals, 0);</span>
<span class="fc" id="L470">        vals[0] += vals[3];</span>
<span class="fc" id="L471">        fMix(vals, 1);</span>
<span class="fc" id="L472">        vals[1] += vals[2];</span>
<span class="fc" id="L473">        fMix(vals, 2);</span>
<span class="fc" id="L474">        fMix(vals, 3);</span>

<span class="fc" id="L476">        fMix(vals, 0);</span>
<span class="fc" id="L477">        vals[0] += vals[3];</span>
<span class="fc" id="L478">        fMix(vals, 1);</span>
<span class="fc" id="L479">        vals[1] += vals[2];</span>
<span class="fc" id="L480">        fMix(vals, 2);</span>
<span class="fc" id="L481">        fMix(vals, 3);</span>

<span class="fc" id="L483">        rKtr(vals, 34, 0, false);</span>
<span class="fc" id="L484">        rKtr(vals, 32, 1, false);</span>
<span class="fc" id="L485">        rKtr(vals, 30, 2, false);</span>
<span class="fc" id="L486">        rKtr(vals, 28, 3, false);</span>
<span class="fc" id="L487">        rKtr(vals, 26, 0, false);</span>
<span class="fc" id="L488">        rKtr(vals, 24, 1, false);</span>
<span class="fc" id="L489">        rKtr(vals, 22, 2, false);</span>
<span class="fc" id="L490">        rKtr(vals, 20, 3, false);</span>
<span class="fc" id="L491">        rKtr(vals, 18, 0, true);</span>
<span class="fc" id="L492">        rKtr(vals, 16, 1, true);</span>
<span class="fc" id="L493">        rKtr(vals, 14, 2, true);</span>
<span class="fc" id="L494">        rKtr(vals, 12, 3, true);</span>
<span class="fc" id="L495">        rKtr(vals, 10, 0, true);</span>
<span class="fc" id="L496">        rKtr(vals, 8, 1, true);</span>
<span class="fc" id="L497">        rKtr(vals, 6, 2, true);</span>
<span class="fc" id="L498">        rKtr(vals, 4, 3, true);</span>

<span class="fc" id="L500">        bMix(vals, 0);</span>
<span class="fc" id="L501">        bMix(vals, 1);</span>
<span class="fc" id="L502">        vals[2] -= vals[1];</span>
<span class="fc" id="L503">        bMix(vals, 2);</span>
<span class="fc" id="L504">        vals[3] -= vals[0];</span>
<span class="fc" id="L505">        bMix(vals, 3);</span>
<span class="fc" id="L506">        bMix(vals, 0);</span>
<span class="fc" id="L507">        bMix(vals, 1);</span>
<span class="fc" id="L508">        vals[2] -= vals[1];</span>
<span class="fc" id="L509">        bMix(vals, 2);</span>
<span class="fc" id="L510">        vals[3] -= vals[0];</span>
<span class="fc" id="L511">        bMix(vals, 3);</span>

<span class="fc" id="L513">        outBlk[0] = vals[3] - lKey[0];</span>
<span class="fc" id="L514">        outBlk[1] = vals[2] - lKey[1];</span>
<span class="fc" id="L515">        outBlk[2] = vals[1] - lKey[2];</span>
<span class="fc" id="L516">        outBlk[3] = vals[0] - lKey[3];</span>
<span class="fc" id="L517">    }</span>

    /**
     * Set key from bytes.
     *
     * @param pKey the key Bytes.
     */
    public void setKey(final byte[] pKey) {
        /* Determine the key and array length */
<span class="fc" id="L526">        int keyLength = pKey.length;</span>
<span class="fc" id="L527">        final int intLength = keyLength / Integer.BYTES;</span>
<span class="fc" id="L528">        keyLength *= Byte.SIZE;</span>


        /* map cipher key to initial key state */
<span class="fc" id="L532">        final int[] myIntKey = new int[intLength];</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">        for (int i = 0, pos = 0; i &lt; intLength; i++, pos += Integer.BYTES) {</span>
<span class="fc" id="L534">            myIntKey[i] = ((pKey[pos + 3] &amp; 255) &lt;&lt; 24)</span>
                    | ((pKey[pos + 2] &amp; 255) &lt;&lt; 16)
                    | ((pKey[pos + 1] &amp; 255) &lt;&lt; 8)
                    | (pKey[pos] &amp; 255);
        }

        /* Set the key */
<span class="fc" id="L541">        setKey(myIntKey, keyLength);</span>
<span class="fc" id="L542">    }</span>

    /**
     * Build inputArray from input.
     *
     * @param pInput  the input Bytes.
     * @param pOffset the offset
     */
    private void buildInput(final byte[] pInput, final int pOffset) {
        /* map input to intArray */
<span class="fc bfc" id="L552" title="All 2 branches covered.">        for (int i = 0, pos = pOffset; i &lt; INTLENGTH; i++, pos += Integer.BYTES) {</span>
<span class="fc" id="L553">            input[i] = ((pInput[pos + 3] &amp; 255) &lt;&lt; 24)</span>
                    | ((pInput[pos + 2] &amp; 255) &lt;&lt; 16)
                    | ((pInput[pos + 1] &amp; 255) &lt;&lt; 8)
                    | (pInput[pos] &amp; 255);
        }
<span class="fc" id="L558">    }</span>

    /**
     * Build output from intArray.
     *
     * @param pOutput the output array.
     * @param pOffset the offset
     */
    private void buildOutput(final byte[] pOutput, final int pOffset) {
        /* Determine the key and array length */
<span class="fc" id="L568">        final int intLength = 4;</span>

        /* map input to intArray */
<span class="fc bfc" id="L571" title="All 2 branches covered.">        for (int i = 0, pos = pOffset; i &lt; intLength; i++, pos += Integer.BYTES) {</span>
<span class="fc" id="L572">            final int w = output[i];</span>
<span class="fc" id="L573">            pOutput[pos] = (byte) (w);</span>
<span class="fc" id="L574">            pOutput[pos + 1] = (byte) (w &gt;&gt; 8);</span>
<span class="fc" id="L575">            pOutput[pos + 2] = (byte) (w &gt;&gt; 16);</span>
<span class="fc" id="L576">            pOutput[pos + 3] = (byte) (w &gt;&gt; 24);</span>
        }
<span class="fc" id="L578">    }</span>

    @Override
    public String getAlgorithmName() {
<span class="fc" id="L582">        return &quot;MARS&quot;;</span>
    }

    @Override
    public int getBlockSize() {
<span class="fc" id="L587">        return BLOCKSIZEB;</span>
    }

    @Override
    public void init(final boolean forEncrypt, final CipherParameters pParameters) throws IllegalArgumentException {
        /* Reject invalid parameters */
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">        if (!(pParameters instanceof KeyParameter)) {</span>
<span class="nc" id="L594">            throw new IllegalArgumentException(&quot;Invalid parameter passed to MARS init - &quot;</span>
<span class="nc" id="L595">                    + pParameters.getClass().getName());</span>
        }

        /* Determine keySize */
<span class="fc" id="L599">        final byte[] keyBytes = ((KeyParameter) pParameters).getKey();</span>
<span class="fc" id="L600">        final int keyBitSize = keyBytes.length * Byte.SIZE;</span>
<span class="pc bpc" id="L601" title="1 of 6 branches missed.">        if (keyBitSize != 128 &amp;&amp; keyBitSize != 192 &amp;&amp; keyBitSize != 256) {</span>
<span class="nc" id="L602">            throw new IllegalArgumentException(&quot;KeyBitSize must be 128, 192 or 256&quot;);</span>
        }

        /* Set up key */
<span class="fc" id="L606">        this.forEncryption = forEncrypt;</span>
<span class="fc" id="L607">        setKey(keyBytes);</span>
<span class="fc" id="L608">    }</span>

    @Override
    public int processBlock(final byte[] in, final int inOff, final byte[] out, final int outOff) throws DataLengthException, IllegalStateException {
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">        if (forEncryption == null) {</span>
<span class="nc" id="L613">            throw new IllegalStateException(&quot;Anubis engine not initialised&quot;);</span>
        }
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">        if (inOff &gt; (in.length - BLOCKSIZEB)) {</span>
<span class="nc" id="L616">            throw new DataLengthException(&quot;input buffer too short&quot;);</span>
        }
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">        if (outOff &gt; (out.length - BLOCKSIZEB)) {</span>
<span class="nc" id="L619">            throw new OutputLengthException(&quot;output buffer too short&quot;);</span>
        }

<span class="fc" id="L622">        buildInput(in, inOff);</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">        if (forEncryption) {</span>
<span class="fc" id="L624">            encrypt(input, output);</span>
        } else {
<span class="fc" id="L626">            decrypt(input, output);</span>
        }
<span class="fc" id="L628">        buildOutput(out, outOff);</span>
<span class="fc" id="L629">        return BLOCKSIZEB;</span>
    }

    @Override
    public void reset() {
        /* NoOp */
<span class="fc" id="L635">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
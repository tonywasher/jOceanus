<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianCoreCertificate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.joceanus.gordianknot.impl.core.cert</a> &gt; <span class="el_source">GordianCoreCertificate.java</span></div><h1>GordianCoreCertificate.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * GordianKnot: Security Suite
 * Copyright 2012,2025 Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package net.sourceforge.joceanus.gordianknot.impl.core.cert;

import net.sourceforge.joceanus.gordianknot.api.base.GordianException;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigest;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigestFactory;
import net.sourceforge.joceanus.gordianknot.api.digest.GordianDigestSpec;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairFactory;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPair;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairGenerator;
import net.sourceforge.joceanus.gordianknot.api.keypair.GordianKeyPairSpec;
import net.sourceforge.joceanus.gordianknot.api.cert.GordianCertificate;
import net.sourceforge.joceanus.gordianknot.api.cert.GordianCertificateId;
import net.sourceforge.joceanus.gordianknot.api.cert.GordianKeyPairUsage;
import net.sourceforge.joceanus.gordianknot.api.cert.GordianKeyPairUse;
import net.sourceforge.joceanus.gordianknot.api.keystore.GordianKeyStoreEntry.GordianKeyStorePair;
import net.sourceforge.joceanus.gordianknot.api.sign.GordianSignParams;
import net.sourceforge.joceanus.gordianknot.api.sign.GordianSignature;
import net.sourceforge.joceanus.gordianknot.api.sign.GordianSignatureSpec;
import net.sourceforge.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianDataException;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianIOException;
import net.sourceforge.joceanus.gordianknot.impl.core.exc.GordianLogicException;
import net.sourceforge.joceanus.gordianknot.impl.core.keypair.GordianCompositeKeyPair;
import net.sourceforge.joceanus.gordianknot.impl.core.keypair.GordianCoreKeyPair;
import net.sourceforge.joceanus.gordianknot.impl.core.sign.GordianCoreSignatureFactory;
import org.bouncycastle.asn1.ASN1BitString;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1OutputStream;
import org.bouncycastle.asn1.DERBitString;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.BasicConstraints;
import org.bouncycastle.asn1.x509.Certificate;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.Extensions;
import org.bouncycastle.asn1.x509.ExtensionsGenerator;
import org.bouncycastle.asn1.x509.KeyUsage;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.asn1.x509.TBSCertificate;
import org.bouncycastle.asn1.x509.Time;
import org.bouncycastle.asn1.x509.V3TBSCertificateGenerator;

import java.io.IOException;
import java.math.BigInteger;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.Objects;

/**
 * Certificate implementation.
 */
public class GordianCoreCertificate
    implements GordianCertificate {
    /**
     * The Factory.
     */
    private final GordianBaseFactory theFactory;

    /**
     * The Subject.
     */
    private final GordianCertificateId theSubject;

    /**
     * The Issuer.
     */
    private final GordianCertificateId theIssuer;

    /**
     * The (public only) KeyPair to which this Certificate belongs.
     */
    private final GordianKeyPair theKeyPair;

    /**
     * The KeyUsage.
     */
    private final GordianKeyPairUsage theKeyUsage;

    /**
     * The CAStatus.
     */
    private final GordianCAStatus theCAStatus;

    /**
     * The Signature Algorithm.
     */
    private final AlgorithmIdentifier theSigAlgId;

    /**
     * The SignatureSpec.
     */
    private final GordianSignatureSpec theSigSpec;

    /**
     * The serial#.
     */
    private final BigInteger theSerialNo;

    /**
     * The TBS Certificate.
     */
    private final TBSCertificate theTbsCertificate;

    /**
     * The signature.
     */
    private final byte[] theSignature;

    /**
     * The encoded representation.
     */
    private final byte[] theEncoded;

    /**
     * Is the certificate self-signed?
     */
    private final boolean isSelfSigned;

    /**
     * Create a new self-signed certificate.
     *
     * @param pFactory the factory
     * @param pKeyPair the keyPair
     * @param pSubject the name of the entity
     * @throws GordianException on error
     */
    public GordianCoreCertificate(final GordianBaseFactory pFactory,
                                  final GordianKeyPair pKeyPair,
<span class="fc" id="L149">                                  final X500Name pSubject) throws GordianException {</span>
        /* Check that the keyPair is OK */
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (isPublicOnly(pKeyPair)) {</span>
<span class="nc" id="L152">            throw new GordianLogicException(&quot;Invalid keyPair&quot;);</span>
        }

        /* Store the parameters */
<span class="fc" id="L156">        theFactory = pFactory;</span>
<span class="fc" id="L157">        theKeyPair = getPublicOnly(pKeyPair);</span>

        /* Determine the signatureSpec */
<span class="fc" id="L160">        theSigSpec = determineSignatureSpecForKeyPair(theKeyPair);</span>

        /* Determine the algorithm Id for the signatureSpec */
<span class="fc" id="L163">        theSigAlgId = determineAlgIdForSignatureSpec(theSigSpec, theKeyPair);</span>

        /* Create the TBSCertificate */
<span class="fc" id="L166">        theKeyUsage = new GordianKeyPairUsage(GordianKeyPairUse.CERTIFICATE);</span>
<span class="fc" id="L167">        theCAStatus = new GordianCAStatus(true);</span>
<span class="fc" id="L168">        theTbsCertificate = buildCertificate(null, pSubject);</span>
<span class="fc" id="L169">        theSerialNo = theTbsCertificate.getSerialNumber().getValue();</span>

        /* Create the signature */
<span class="fc" id="L172">        theSignature = createSignature(pKeyPair);</span>
<span class="fc" id="L173">        isSelfSigned = true;</span>

        /* Create the ids */
<span class="fc" id="L176">        theSubject = buildSubjectId();</span>
<span class="fc" id="L177">        theIssuer = buildIssuerId();</span>

        /* Store the encoded representation */
<span class="fc" id="L180">        theEncoded = encodeCertificate();</span>
<span class="fc" id="L181">    }</span>

    /**
     * Create a new certificate, signed by the relevant authority.
     *
     * @param pFactory the factory
     * @param pSigner  the signing keyPair/certificate
     * @param pKeyPair the keyPair
     * @param pSubject the name of the entity
     * @param pUsage   the key usage
     * @throws GordianException on error
     */
    public GordianCoreCertificate(final GordianBaseFactory pFactory,
                                  final GordianKeyStorePair pSigner,
                                  final GordianKeyPair pKeyPair,
                                  final X500Name pSubject,
<span class="fc" id="L197">                                  final GordianKeyPairUsage pUsage) throws GordianException {</span>
        /* Store the parameters */
<span class="fc" id="L199">        theFactory = pFactory;</span>
<span class="fc" id="L200">        theKeyPair = getPublicOnly(pKeyPair);</span>
<span class="fc" id="L201">        theKeyUsage = pUsage;</span>

        /* Check that the signer is allowed to sign certificates */
<span class="fc" id="L204">        final GordianKeyPair mySignerPair = pSigner.getKeyPair();</span>
<span class="fc" id="L205">        final GordianCoreCertificate mySignerCert = (GordianCoreCertificate) pSigner.getCertificateChain().get(0);</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (!mySignerCert.getUsage().hasUse(GordianKeyPairUse.CERTIFICATE)</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">                || !mySignerCert.isValidNow()</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">                || isPublicOnly(mySignerPair)) {</span>
<span class="nc" id="L209">            throw new GordianLogicException(&quot;Invalid signer&quot;);</span>
        }

        /* Determine CA Status */
<span class="fc" id="L213">        theCAStatus = new GordianCAStatus(theKeyUsage, mySignerCert.theCAStatus);</span>

        /* Determine the signatureSpec */
<span class="fc" id="L216">        theSigSpec = determineSignatureSpecForKeyPair(pSigner.getKeyPair());</span>

        /* Determine the algorithm Id for the signatureSpec */
<span class="fc" id="L219">        theSigAlgId = determineAlgIdForSignatureSpec(theSigSpec, pSigner.getKeyPair());</span>

        /* Create the TBSCertificate */
<span class="fc" id="L222">        theTbsCertificate = buildCertificate(mySignerCert, pSubject);</span>
<span class="fc" id="L223">        theSerialNo = theTbsCertificate.getSerialNumber().getValue();</span>

        /* Create the signature */
<span class="fc" id="L226">        theSignature = createSignature(mySignerPair);</span>
<span class="fc" id="L227">        isSelfSigned = false;</span>

        /* Create the ids */
<span class="fc" id="L230">        theSubject = buildSubjectId();</span>
<span class="fc" id="L231">        theIssuer = buildIssuerId();</span>

        /* Store the encoded representation */
<span class="fc" id="L234">        theEncoded = encodeCertificate();</span>
<span class="fc" id="L235">    }</span>

    /**
     * Parse a certificate.
     *
     * @param pFactory    the factory
     * @param pSequence   the DER representation of the certificate
     * @throws GordianException on error
     */
    public GordianCoreCertificate(final GordianBaseFactory pFactory,
                                  final byte[] pSequence) throws GordianException {
<span class="fc" id="L246">        this(pFactory, Certificate.getInstance(pSequence));</span>
<span class="fc" id="L247">    }</span>

    /**
     * Parse a certificate.
     *
     * @param pFactory     the factory
     * @param pCertificate the certificate
     * @throws GordianException on error
     */
    public GordianCoreCertificate(final GordianBaseFactory pFactory,
<span class="fc" id="L257">                                  final Certificate pCertificate) throws GordianException {</span>
        /* Protect against exceptions */
        try {
            /* Store the parameters */
<span class="fc" id="L261">            theFactory = pFactory;</span>

            /* Extract the details */
<span class="fc" id="L264">            theTbsCertificate = pCertificate.getTBSCertificate();</span>
<span class="fc" id="L265">            theSigAlgId = pCertificate.getSignatureAlgorithm();</span>
<span class="fc" id="L266">            theSignature = pCertificate.getSignature().getBytes();</span>

            /* Determine the signatureSpec for the algorithmId */
<span class="fc" id="L269">            theSigSpec = determineSignatureSpecForAlgId(theSigAlgId);</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">            if (theSigSpec == null) {</span>
<span class="nc" id="L271">                throw new GordianDataException(&quot;Unsupported Signature AlgorithmId: &quot; + theSigAlgId);</span>
            }

            /* Derive the keyPair */
<span class="fc" id="L275">            theKeyPair = parseEncodedKey();</span>

            /* Access the extensions */
<span class="fc" id="L278">            final Extensions myExtensions = theTbsCertificate.getExtensions();</span>
<span class="fc" id="L279">            theKeyUsage = determineUsage(myExtensions);</span>
<span class="fc" id="L280">            theCAStatus = GordianCAStatus.determineStatus(myExtensions);</span>

            /* Determine whether we are self-signed */
<span class="fc" id="L283">            final X500Name mySignerName = getSubjectName();</span>
<span class="fc" id="L284">            isSelfSigned = mySignerName.equals(getIssuerName());</span>

            /* Create the ids */
<span class="fc" id="L287">            theSubject = buildSubjectId();</span>
<span class="fc" id="L288">            theIssuer = buildIssuerId();</span>
<span class="fc" id="L289">            theSerialNo = theTbsCertificate.getSerialNumber().getValue();</span>

            /* Store the encoded representation */
<span class="fc" id="L292">            theEncoded = pCertificate.getEncoded();</span>
<span class="nc" id="L293">        } catch (IOException e) {</span>
<span class="nc" id="L294">            throw new GordianIOException(&quot;Failed to parse certificate&quot;, e);</span>
<span class="fc" id="L295">        }</span>
<span class="fc" id="L296">    }</span>

    /**
     * Obtain the factory.
     * @return the factory
     */
    protected GordianBaseFactory getFactory() {
<span class="fc" id="L303">        return theFactory;</span>
    }

    /**
     * Build the issuer Id for a certificate.
     * @return get the issuer id
     */
    private GordianCoreCertificateId buildSubjectId() {
<span class="fc" id="L311">        return new GordianCoreCertificateId(getSubjectName(), DERBitString.convert(getSubjectId()));</span>
    }

    /**
     * Build the issuer Id for a certificate.
      * @return get the issuer id
     */
    private GordianCoreCertificateId buildIssuerId() {
<span class="fc" id="L319">        return new GordianCoreCertificateId(getIssuerName(), DERBitString.convert(getIssuerId()));</span>
    }

    @Override
    public boolean isValidOnDate(final Date pDate) {
        /* Access the date */
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        return pDate.compareTo(theTbsCertificate.getStartDate().getDate()) &gt;= 0</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">                &amp;&amp; pDate.compareTo(theTbsCertificate.getEndDate().getDate()) &lt;= 0;</span>
    }

    /**
     * Obtain the certificate.
     * @return the certificate
     */
    public Certificate getCertificate() {
<span class="fc" id="L334">        return Certificate.getInstance(getEncoded());</span>
    }

    @Override
    public byte[] getEncoded() {
<span class="fc" id="L339">        return Arrays.copyOf(theEncoded, theEncoded.length);</span>
    }

    @Override
    public GordianCertificateId getSubject() {
<span class="fc" id="L344">        return theSubject;</span>
    }

    @Override
    public GordianCertificateId getIssuer() {
<span class="fc" id="L349">        return theIssuer;</span>
    }

    /**
     * Obtain the subject of the certificate.
     *
     * @return the subject
     */
    public X500Name getSubjectName() {
<span class="fc" id="L358">        return theTbsCertificate.getSubject();</span>
    }

    /**
     * Obtain the subjectId of the certificate.
     *
     * @return the subjectId
     */
    ASN1BitString getSubjectId() {
<span class="fc" id="L367">        return theTbsCertificate.getSubjectUniqueId();</span>
    }

    /**
     * Obtain the issuer of the certificate.
     *
     * @return the issuer name
     */
    X500Name getIssuerName() {
<span class="fc" id="L376">        return theTbsCertificate.getIssuer();</span>
    }

    /**
     * Obtain the issuerId of the certificate.
     *
     * @return the issuerId
     */
    ASN1BitString getIssuerId() {
<span class="fc bfc" id="L385" title="All 2 branches covered.">        return isSelfSigned</span>
<span class="fc" id="L386">               ? getSubjectId()</span>
<span class="fc" id="L387">               : theTbsCertificate.getIssuerUniqueId();</span>
    }

    @Override
    public boolean isSelfSigned() {
<span class="fc" id="L392">        return isSelfSigned;</span>
    }

    @Override
    public GordianKeyPairUsage getUsage() {
<span class="fc" id="L397">        return theKeyUsage;</span>
    }

    @Override
    public GordianKeyPair getKeyPair() {
<span class="fc" id="L402">        return theKeyPair;</span>
    }

    /**
     * Obtain the serial#.
     * @return the serial number.
     */
    public BigInteger getSerialNo() {
<span class="fc" id="L410">        return theSerialNo;</span>
    }

    /**
     * Obtain the signatureSpec.
     * @return the signatureSpec
     */
    protected GordianSignatureSpec getSignatureSpec() {
<span class="fc" id="L418">        return theSigSpec;</span>
    }

    /**
     * Is the keyPair publicOnly?
     * @param pKeyPair the keyPair
     * @return true/false
     */
    protected boolean isPublicOnly(final GordianKeyPair pKeyPair) {
<span class="fc" id="L427">        return pKeyPair.isPublicOnly();</span>
    }

    /**
     * get public only version of key.
     * @param pKeyPair the key
     * @return the publicOnly version
     */
    protected GordianKeyPair getPublicOnly(final GordianKeyPair pKeyPair) {
<span class="fc bfc" id="L436" title="All 2 branches covered.">        return pKeyPair instanceof GordianCompositeKeyPair myComposite</span>
<span class="fc" id="L437">                ? myComposite.getPublicOnly()</span>
<span class="fc" id="L438">                : ((GordianCoreKeyPair) pKeyPair).getPublicOnly();</span>
    }

    /**
     * Determine the signatureSpec for the key.
     *
     * @param pKeyPair the keyPair
     * @return the signatureSpec
     */
    GordianSignatureSpec determineSignatureSpecForKeyPair(final GordianKeyPair pKeyPair) {
<span class="fc" id="L448">        return theFactory.getAsyncFactory().getSignatureFactory().defaultForKeyPair(pKeyPair.getKeyPairSpec());</span>
    }

    /**
     * Determine the signatureSpec for the algorithmId.
     *
     * @param pAlgId the algorithmId
     * @return the signatureSpec
     */
    GordianSignatureSpec determineSignatureSpecForAlgId(final AlgorithmIdentifier pAlgId) {
<span class="fc" id="L458">        final GordianCoreSignatureFactory mySigns = (GordianCoreSignatureFactory) getFactory().getAsyncFactory().getSignatureFactory();</span>
<span class="fc" id="L459">        return mySigns.getSpecForIdentifier(pAlgId);</span>
    }

    /**
     * Determine the algorithmId for the signatureSpec.
     *
     * @param pSpec the signatureSpec
     * @param pSigner the signer
     * @return the algorithmId
     */
    AlgorithmIdentifier determineAlgIdForSignatureSpec(final GordianSignatureSpec pSpec,
                                                       final GordianKeyPair pSigner) {
<span class="fc" id="L471">        final GordianCoreSignatureFactory mySigns = (GordianCoreSignatureFactory) getFactory().getAsyncFactory().getSignatureFactory();</span>
<span class="fc" id="L472">        return mySigns.getIdentifierForSpecAndKeyPair(getSignatureSpec(), pSigner);</span>
    }

    /**
     * Validate that the keyPair public Key matches.
     * @param pKeyPair the key pair
     * @return matches true/false
     */
    public boolean checkMatchingPublicKey(final GordianKeyPair pKeyPair) {
<span class="fc bfc" id="L481" title="All 2 branches covered.">        return pKeyPair instanceof GordianCompositeKeyPair myComposite</span>
<span class="fc" id="L482">                ? myComposite.checkMatchingPublicKey(getKeyPair())</span>
<span class="fc" id="L483">                : ((GordianCoreKeyPair) pKeyPair).checkMatchingPublicKey(getKeyPair());</span>
    }

    /**
     * parse encodedKey.
     * @return the parsed key
     * @throws GordianException on error
     */
    protected GordianKeyPair parseEncodedKey() throws GordianException {
        /* Derive the keyPair */
<span class="fc" id="L493">        final GordianKeyPairFactory myFactory = getFactory().getAsyncFactory().getKeyPairFactory();</span>
<span class="fc" id="L494">        final X509EncodedKeySpec myX509 = getX509KeySpec();</span>
<span class="fc" id="L495">        final GordianKeyPairSpec myKeySpec = myFactory.determineKeyPairSpec(myX509);</span>
<span class="fc" id="L496">        final GordianKeyPairGenerator myGenerator = myFactory.getKeyPairGenerator(myKeySpec);</span>
<span class="fc" id="L497">        return myGenerator.derivePublicOnlyKeyPair(myX509);</span>
    }

    /**
     * Obtain the encoded publicKey.
     * @return the encoded bytes
     * @throws GordianException on error
     */
    protected byte[] getPublicKeyEncoded() throws GordianException {
        /* Access the keyPair */
<span class="fc" id="L507">        final GordianKeyPair myPair = getKeyPair();</span>

        /* Access the keyPair generator */
<span class="fc" id="L510">        final GordianKeyPairFactory myFactory = getFactory().getAsyncFactory().getKeyPairFactory();</span>
<span class="fc" id="L511">        final GordianKeyPairGenerator myGenerator = myFactory.getKeyPairGenerator(myPair.getKeyPairSpec());</span>

        /* Obtain the publicKey Info */
<span class="fc" id="L514">        return myGenerator.getX509Encoding(myPair).getEncoded();</span>
    }

    /**
     * Obtain the digestSpec.
     *
     * @return the digestSpec
     */
    protected GordianDigestSpec getDigestSpec() {
<span class="fc" id="L523">        return getSignatureSpec().getDigestSpec();</span>
    }

    /**
     * Create the signer.
     *
     * @return the signer
     * @throws GordianException on error
     */
    protected GordianSignature createSigner() throws GordianException {
        /* Create the signer */
<span class="fc" id="L534">        final GordianCoreSignatureFactory mySigns = (GordianCoreSignatureFactory) getFactory().getAsyncFactory().getSignatureFactory();</span>
<span class="fc" id="L535">        return mySigns.createSigner(getSignatureSpec());</span>
    }

    /**
     * Determine usage.
     *
     * @param pExtensions the extensions.
     * @return the usage
     */
    public static GordianKeyPairUsage determineUsage(final Extensions pExtensions) {
        /* Access details */
<span class="fc" id="L546">        final KeyUsage myUsage = KeyUsage.fromExtensions(pExtensions);</span>
<span class="fc" id="L547">        final BasicConstraints myConstraint = BasicConstraints.fromExtensions(pExtensions);</span>
<span class="fc" id="L548">        final GordianKeyPairUsage myResult = new GordianKeyPairUsage();</span>

        /* Check for CERTIFICATE */
<span class="pc bpc" id="L551" title="1 of 4 branches missed.">        final boolean isCA = myConstraint != null &amp;&amp; myConstraint.isCA();</span>
<span class="pc bpc" id="L552" title="1 of 4 branches missed.">        if (isCA &amp;&amp; checkUsage(myUsage, KeyUsage.keyCertSign)) {</span>
<span class="fc" id="L553">            myResult.addUse(GordianKeyPairUse.CERTIFICATE);</span>
        }

        /* Check for signer. */
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if (checkUsage(myUsage, KeyUsage.digitalSignature)) {</span>
<span class="fc" id="L558">            myResult.addUse(GordianKeyPairUse.SIGNATURE);</span>
        }

        /* Check for nonRepudiation. */
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">        if (checkUsage(myUsage, KeyUsage.nonRepudiation)) {</span>
<span class="nc" id="L563">            myResult.addUse(GordianKeyPairUse.NONREPUDIATION);</span>
        }

        /* Check for keyAgreement. */
<span class="fc bfc" id="L567" title="All 2 branches covered.">        if (checkUsage(myUsage, KeyUsage.keyAgreement)) {</span>
<span class="fc" id="L568">            myResult.addUse(GordianKeyPairUse.AGREEMENT);</span>
        }

        /* Check for keyEncryption. */
<span class="fc bfc" id="L572" title="All 2 branches covered.">        if (checkUsage(myUsage, KeyUsage.keyEncipherment)) {</span>
<span class="fc" id="L573">            myResult.addUse(GordianKeyPairUse.KEYENCRYPT);</span>
        }

        /* Check for dataEncryption. */
<span class="fc bfc" id="L577" title="All 2 branches covered.">        if (checkUsage(myUsage, KeyUsage.dataEncipherment)) {</span>
<span class="fc" id="L578">            myResult.addUse(GordianKeyPairUse.DATAENCRYPT);</span>
        }

        /* Check for encipherOnly. */
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">        if (checkUsage(myUsage, KeyUsage.encipherOnly)) {</span>
<span class="nc" id="L583">            myResult.addUse(GordianKeyPairUse.ENCRYPTONLY);</span>
        }

        /* Check for decipherOnly. */
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">        if (checkUsage(myUsage, KeyUsage.decipherOnly)) {</span>
<span class="nc" id="L588">            myResult.addUse(GordianKeyPairUse.DECRYPTONLY);</span>
        }

        /* Return the result */
<span class="fc" id="L592">        return myResult;</span>
    }

    /**
     * Check for usage.
     * @param pUsage the usage control
     * @param pRequired  the required usage
     * @return true/false
     */
    private static boolean checkUsage(final KeyUsage pUsage,
                                      final int pRequired) {
<span class="pc bpc" id="L603" title="1 of 4 branches missed.">        return pUsage == null || pUsage.hasUsages(pRequired);</span>
    }

    /**
     * Validate a certificate.
     *
     * @param pSigner the signer of the certiicate
     * @return valid? true/false
     * @throws GordianException on error
     */
    public boolean validateCertificate(final GordianCoreCertificate pSigner) throws GordianException {
        /* Check that the certificate is not self-signed */
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">        if (isSelfSigned) {</span>
<span class="nc" id="L616">            throw new GordianDataException(&quot;Root certificate used as intermediary&quot;);</span>
        }

        /* Check that the signing certificate is correct */
<span class="fc" id="L620">        final X500Name mySignerName = pSigner.getSubjectName();</span>
<span class="fc" id="L621">        final DERBitString mySignerId = DERBitString.convert(pSigner.getSubjectId());</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">        if (!mySignerName.equals(getIssuerName())</span>
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">                || !Objects.equals(mySignerId, getIssuerId())) {</span>
<span class="nc" id="L624">            throw new GordianDataException(&quot;Incorrect signer certificate&quot;);</span>
        }

        /* Check that the signing certificate is valid */
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">        if (!pSigner.getUsage().hasUse(GordianKeyPairUse.CERTIFICATE)</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">                || !pSigner.isValidNow()) {</span>
<span class="nc" id="L630">            throw new GordianDataException(&quot;Invalid signer certificate&quot;);</span>
        }

        /* Check that the signature is valid */
<span class="fc" id="L634">        return validateSignature(pSigner.getKeyPair());</span>
     }

    /**
     * Validate a root certificate.
     *
     * @return valid? true/false
     * @throws GordianException on error
     */
    public boolean validateRootCertificate() throws GordianException {
        /* Check that the certificate is self-signed */
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">        if (!isSelfSigned) {</span>
<span class="nc" id="L646">            throw new GordianDataException(&quot;Non-root certificate used as root&quot;);</span>
        }

        /* Check that the certificate is valid self-signed */
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">        if (!theKeyUsage.hasUse(GordianKeyPairUse.CERTIFICATE)</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">                || theCAStatus.getPathLen() != null) {</span>
<span class="nc" id="L652">            throw new GordianDataException(&quot;Invalid root certificate&quot;);</span>
        }

        /* Check that the issuerId is null */
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (theTbsCertificate.getIssuerUniqueId() != null) {</span>
<span class="nc" id="L657">            throw new GordianDataException(&quot;Root certificate has distinct issuerUniqueId&quot;);</span>
        }

        /* Check that the signature is valid */
<span class="fc" id="L661">        return validateSignature(theKeyPair);</span>
    }

    /**
     * Create a certificate.
     * @param pSigner the signing certificate
     * @param pSubject the name of the certificate
     * @return the theCertificate
     * @throws GordianException on error
     */
    private TBSCertificate buildCertificate(final GordianCoreCertificate pSigner,
                                            final X500Name pSubject) throws GordianException {
        /* Create the name of the certificate */
<span class="fc bfc" id="L674" title="All 2 branches covered.">        final X500Name myIssuer = pSigner == null</span>
<span class="fc" id="L675">                                  ? pSubject</span>
<span class="fc" id="L676">                                  : pSigner.getSubjectName();</span>

        /* Using the current timestamp as the certificate serial number */
<span class="fc" id="L679">        final long myNow = System.currentTimeMillis();</span>
<span class="fc" id="L680">        final BigInteger mySerialNo = BigInteger.valueOf(myNow);</span>

        /* Create the startDate and endDate for the certificate */
<span class="fc" id="L683">        final Date myStart = new Date(myNow);</span>
<span class="fc" id="L684">        final Calendar myCalendar = Calendar.getInstance();</span>
<span class="fc" id="L685">        myCalendar.setTime(myStart);</span>
<span class="fc" id="L686">        myCalendar.add(Calendar.YEAR, 1);</span>
<span class="fc" id="L687">        final Date myEnd = myCalendar.getTime();</span>

        /* Obtain the publicKey Info */
<span class="fc" id="L690">        final byte[] myPublicKeyEncoded = getPublicKeyEncoded();</span>
<span class="fc" id="L691">        final SubjectPublicKeyInfo myPublicKeyInfo = SubjectPublicKeyInfo.getInstance(myPublicKeyEncoded);</span>

        /* Build basic information */
<span class="fc" id="L694">        final V3TBSCertificateGenerator myCertBuilder = new V3TBSCertificateGenerator();</span>
<span class="fc" id="L695">        myCertBuilder.setSubject(pSubject);</span>
<span class="fc" id="L696">        myCertBuilder.setIssuer(myIssuer);</span>
<span class="fc" id="L697">        myCertBuilder.setStartDate(new Time(myStart));</span>
<span class="fc" id="L698">        myCertBuilder.setEndDate(new Time(myEnd));</span>
<span class="fc" id="L699">        myCertBuilder.setSerialNumber(new ASN1Integer(mySerialNo));</span>
<span class="fc" id="L700">        myCertBuilder.setSubjectPublicKeyInfo(myPublicKeyInfo);</span>
<span class="fc" id="L701">        myCertBuilder.setSignature(theSigAlgId);</span>
<span class="fc" id="L702">        myCertBuilder.setSubjectUniqueID(createSubjectId(myPublicKeyEncoded, mySerialNo));</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">        if (pSigner != null) {</span>
<span class="fc" id="L704">            myCertBuilder.setIssuerUniqueID(DERBitString.convert(pSigner.getSubjectId()));</span>
        }

        /* Create extensions for the certificate */
<span class="fc" id="L708">        myCertBuilder.setExtensions(createExtensions());</span>

        /* Generate the TBS Certificate */
<span class="fc" id="L711">        return myCertBuilder.generateTBSCertificate();</span>
    }

    /**
     * Create extensions for tbsCertificate.
     *
     * @return the extensions
     * @throws GordianException on error
     */
    private Extensions createExtensions() throws GordianException {
        /* Create extensions for the certificate */
<span class="fc" id="L722">        final ExtensionsGenerator myExtGenerator = new ExtensionsGenerator();</span>
<span class="fc" id="L723">        createKeyUseExtensions(myExtGenerator);</span>
<span class="fc" id="L724">        theCAStatus.createExtensions(myExtGenerator);</span>
<span class="fc" id="L725">        return myExtGenerator.generate();</span>
    }

    /**
     * Create extensions.
     * @param pGenerator the extensions generator
     * @throws GordianException on error
     */
    private void createKeyUseExtensions(final ExtensionsGenerator pGenerator) throws GordianException {
        /* Protect against exceptions */
        try {
<span class="fc" id="L736">            pGenerator.addExtension(Extension.keyUsage, true, theKeyUsage.getKeyUsage());</span>
<span class="nc" id="L737">        } catch (IOException e) {</span>
<span class="nc" id="L738">            throw new GordianIOException(&quot;Failed to create extensions&quot;, e);</span>
<span class="fc" id="L739">        }</span>
<span class="fc" id="L740">    }</span>

    /**
     * Create the subjectId.
     *
     * @param pEncodedPublicKey the publicKey
     * @param pSerialNo         the certificate Serial#
     * @return the subjectId
     * @throws GordianException on error
     */
    private DERBitString createSubjectId(final byte[] pEncodedPublicKey,
                                         final BigInteger pSerialNo) throws GordianException {
        /* Build the hash */
<span class="fc" id="L753">        final GordianDigestSpec mySpec = getDigestSpec();</span>
<span class="fc" id="L754">        final GordianDigestFactory myDigests = theFactory.getDigestFactory();</span>
<span class="fc" id="L755">        final GordianDigest myDigest = myDigests.createDigest(mySpec);</span>
<span class="fc" id="L756">        myDigest.update(pEncodedPublicKey);</span>
<span class="fc" id="L757">        myDigest.update(pSerialNo.toByteArray());</span>

        /* Create the subjectId */
<span class="fc" id="L760">        return new DERBitString(myDigest.finish());</span>
    }

    /**
     * Create the signature.
     *
     * @param pSigner the signer
     * @return the generated signature
     * @throws GordianException on error
     */
    private byte[] createSignature(final GordianKeyPair pSigner) throws GordianException {
        /* Protect against exceptions */
        try {
            /* Build the signature */
<span class="fc" id="L774">            final GordianSignature mySigner = createSigner();</span>
<span class="fc" id="L775">            mySigner.initForSigning(GordianSignParams.keyPair(pSigner));</span>
<span class="fc" id="L776">            final GordianStreamConsumer myConsumer = new GordianStreamConsumer(mySigner);</span>
<span class="fc" id="L777">            final ASN1OutputStream myOut = ASN1OutputStream.create(myConsumer);</span>
<span class="fc" id="L778">            myOut.writeObject(theTbsCertificate);</span>
<span class="fc" id="L779">            myOut.close();</span>

            /* Create the signature */
<span class="fc" id="L782">            return mySigner.sign();</span>
<span class="nc" id="L783">        } catch (IOException e) {</span>
<span class="nc" id="L784">            throw new GordianIOException(&quot;Failed to create signature&quot;, e);</span>
        }
    }

    /**
     * Obtain the X509EncodedKeySpec.
     *
     * @return the keySpec
     * @throws GordianException on error
     */
    public X509EncodedKeySpec getX509KeySpec() throws GordianException {
        /* Protect against exceptions */
        try {
            /* Obtain the X509 keySpec */
<span class="fc" id="L798">            final SubjectPublicKeyInfo myInfo = theTbsCertificate.getSubjectPublicKeyInfo();</span>
<span class="fc" id="L799">            return new X509EncodedKeySpec(myInfo.getEncoded());</span>
<span class="nc" id="L800">        } catch (IOException e) {</span>
<span class="nc" id="L801">            throw new GordianIOException(&quot;Failed to extract keySpec&quot;, e);</span>
        }
    }

    /**
     * Validate the signature.
     *
     * @param pSigner the signer
     * @return true/false is the signature valid?
     * @throws GordianException on error
     */
    private boolean validateSignature(final GordianKeyPair pSigner) throws GordianException {
        /* Protect against exceptions */
        try {
            /* Build the signature */
<span class="fc" id="L816">            final GordianSignature myValidator = createSigner();</span>
<span class="fc" id="L817">            myValidator.initForVerify(GordianSignParams.keyPair(pSigner));</span>
<span class="fc" id="L818">            final GordianStreamConsumer myConsumer = new GordianStreamConsumer(myValidator);</span>
<span class="fc" id="L819">            final ASN1OutputStream myOut = ASN1OutputStream.create(myConsumer);</span>
<span class="fc" id="L820">            myOut.writeObject(theTbsCertificate);</span>
<span class="fc" id="L821">            myOut.close();</span>

            /* Verify the signature */
<span class="fc" id="L824">            return myValidator.verify(theSignature);</span>
<span class="nc" id="L825">        } catch (IOException e) {</span>
<span class="nc" id="L826">            throw new GordianIOException(&quot;Failed to validate signature&quot;, e);</span>
        }
    }

    /**
     * Create the DERSequence for a certificate.
     *
     * @return the DERSequence
     * @throws GordianException on error
     */
    private byte[] encodeCertificate() throws GordianException {
        /* Protect against exceptions */
        try {
            /* Create the DERSequence */
<span class="fc" id="L840">            final ASN1EncodableVector myVector = new ASN1EncodableVector();</span>
<span class="fc" id="L841">            myVector.add(theTbsCertificate);</span>
<span class="fc" id="L842">            myVector.add(theSigAlgId);</span>
<span class="fc" id="L843">            myVector.add(new DERBitString(theSignature));</span>
<span class="fc" id="L844">            final DERSequence mySeq = new DERSequence(myVector);</span>
<span class="fc" id="L845">            return mySeq.getEncoded();</span>
<span class="nc" id="L846">        } catch (IOException e) {</span>
<span class="nc" id="L847">            throw new GordianIOException(&quot;Failed to generate encoding&quot;, e);</span>
        }
    }

    @Override
    public boolean equals(final Object pThat) {
        /* Handle the trivial case */
<span class="fc bfc" id="L854" title="All 2 branches covered.">        if (pThat == this) {</span>
<span class="fc" id="L855">            return true;</span>
        }
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">        if (pThat == null) {</span>
<span class="nc" id="L858">            return false;</span>
        }

        /* Ensure object is correct class */
<span class="fc" id="L862">        return pThat instanceof GordianCoreCertificate myThat</span>
<span class="pc bpc" id="L863" title="1 of 4 branches missed.">                &amp;&amp; Arrays.equals(theEncoded, myThat.theEncoded);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L868">        return Arrays.hashCode(theEncoded);</span>
    }

    /**
     * CA Status.
     */
    public static class GordianCAStatus {
        /**
         * Is this a CA.
         */
        private final boolean isCA;

        /**
         * The Path Length.
         */
        private final BigInteger thePathLen;

        /**
         * Constructor.
         * @param pCA is this a CA?
         */
<span class="fc" id="L889">        GordianCAStatus(final boolean pCA) {</span>
<span class="fc" id="L890">            isCA = pCA;</span>
<span class="fc" id="L891">            thePathLen = null;</span>
<span class="fc" id="L892">        }</span>

        /**
         * Constructor.
         *
         * @param pPathLen the path length.
         */
<span class="fc" id="L899">        GordianCAStatus(final BigInteger pPathLen) {</span>
<span class="fc" id="L900">            isCA = true;</span>
<span class="fc" id="L901">            thePathLen = pPathLen;</span>
<span class="fc" id="L902">        }</span>

        /**
         * Constructor.
         *
         * @param pUsage the keyPair usage
         * @param pSignerStatus the signerStatus.
         */
        GordianCAStatus(final GordianKeyPairUsage pUsage,
<span class="fc" id="L911">                        final GordianCAStatus pSignerStatus) {</span>
<span class="fc" id="L912">            isCA = pUsage.getUsageSet().contains(GordianKeyPairUse.CERTIFICATE);</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">            if (isCA) {</span>
<span class="fc" id="L914">                 final BigInteger mySignerPath = pSignerStatus.getPathLen();</span>
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">                 thePathLen = mySignerPath == null</span>
<span class="fc" id="L916">                             ? BigInteger.ZERO</span>
<span class="pc" id="L917">                             : mySignerPath.add(BigInteger.ONE);</span>
<span class="fc" id="L918">            } else {</span>
<span class="fc" id="L919">                thePathLen = null;</span>
            }
<span class="fc" id="L921">        }</span>

        /**
         * is this a CA?.
         *
         * @return true/false
         */
        boolean isCA() {
<span class="nc" id="L929">            return isCA;</span>
        }

        /**
         * Obtain the pathLen.
         *
         * @return the pathLen
         */
        BigInteger getPathLen() {
<span class="fc" id="L938">            return thePathLen;</span>
        }

        /**
         * Create extensions.
         * @param pGenerator the extensions generator
         * @throws GordianException on error
         */
        void createExtensions(final ExtensionsGenerator pGenerator) throws GordianException {
            /* Protect against exceptions */
            try {
<span class="fc bfc" id="L949" title="All 2 branches covered.">                pGenerator.addExtension(Extension.basicConstraints, isCA, thePathLen == null</span>
<span class="fc" id="L950">                                                                               ? new BasicConstraints(isCA)</span>
<span class="fc" id="L951">                                                                               : new BasicConstraints(thePathLen.intValue()));</span>
<span class="nc" id="L952">            } catch (IOException e) {</span>
<span class="nc" id="L953">                throw new GordianIOException(&quot;Failed to create extensions&quot;, e);</span>
<span class="fc" id="L954">            }</span>
<span class="fc" id="L955">        }</span>

        /**
         * Determine CAStatus.
         *
         * @param pExtensions the extensions.
         * @return the CAStatus
         */
        static GordianCAStatus determineStatus(final Extensions pExtensions) {
            /* Access details */
<span class="fc" id="L965">            final BasicConstraints myConstraint = BasicConstraints.fromExtensions(pExtensions);</span>

            /* Check for CA */
<span class="pc bpc" id="L968" title="1 of 4 branches missed.">            if (myConstraint != null &amp;&amp; myConstraint.isCA()) {</span>
<span class="fc" id="L969">                return new GordianCAStatus(myConstraint.getPathLenConstraint());</span>
            }

            /* Not CA */
<span class="fc" id="L973">            return new GordianCAStatus(false);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
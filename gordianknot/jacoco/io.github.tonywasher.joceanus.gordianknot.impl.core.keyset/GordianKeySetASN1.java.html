<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianKeySetASN1.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">io.github.tonywasher.joceanus.gordianknot.impl.core.keyset</a> &gt; <span class="el_source">GordianKeySetASN1.java</span></div><h1>GordianKeySetASN1.java</h1><pre class="source lang-java linenums">/*
 * GordianKnot: Security Suite
 * Copyright 2012-2026. Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.github.tonywasher.joceanus.gordianknot.impl.core.keyset;

import io.github.tonywasher.joceanus.gordianknot.api.base.GordianException;
import io.github.tonywasher.joceanus.gordianknot.api.base.GordianLength;
import io.github.tonywasher.joceanus.gordianknot.api.cipher.GordianCipherFactory;
import io.github.tonywasher.joceanus.gordianknot.api.cipher.GordianSymKeySpec;
import io.github.tonywasher.joceanus.gordianknot.api.cipher.GordianSymKeyType;
import io.github.tonywasher.joceanus.gordianknot.api.key.GordianKey;
import io.github.tonywasher.joceanus.gordianknot.api.keyset.GordianKeySetSpec;
import io.github.tonywasher.joceanus.gordianknot.impl.core.base.GordianASN1Util;
import io.github.tonywasher.joceanus.gordianknot.impl.core.base.GordianASN1Util.GordianASN1Object;
import io.github.tonywasher.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import io.github.tonywasher.joceanus.gordianknot.impl.core.exc.GordianDataException;
import io.github.tonywasher.joceanus.gordianknot.impl.core.exc.GordianIOException;
import io.github.tonywasher.joceanus.gordianknot.impl.core.key.GordianCoreKey;
import io.github.tonywasher.joceanus.gordianknot.impl.core.key.GordianCoreKeyGenerator;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.DERSequence;

import java.util.Enumeration;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;

/**
 * ASN1 Encoding of KeySet.
 * &lt;pre&gt;
 * GordianKeySetASN1 ::= SEQUENCE {
 *      keySetSpec GordianKeySetSpecASN1
 *      keySet keySetDefinition
 * } securedKey
 *
 * keySetDefinition ::= SEQUENCE OF keyDefinition
 *
 * keyDefinition ::= SEQUENCE {
 *      keyId INTEGER
 *      key OCTET STRING
 * }
 * &lt;/pre&gt;
 */
public class GordianKeySetASN1
        extends GordianASN1Object {
    /**
     * The keySetSpec.
     */
    private final GordianKeySetSpec theSpec;

    /**
     * The map of keyTypes to key.
     */
    private final Map&lt;Integer, byte[]&gt; theMap;

    /**
     * Create the ASN1 sequence.
     *
     * @param pKeySet the keySet
     */
<span class="fc" id="L80">    GordianKeySetASN1(final GordianBaseKeySet pKeySet) {</span>
        /* Store the KeySetSpec */
<span class="fc" id="L82">        theSpec = pKeySet.getKeySetSpec();</span>

        /* Create the map */
<span class="fc" id="L85">        theMap = new LinkedHashMap&lt;&gt;();</span>

        /* Loop through the keys placing keyBytes into the map */
<span class="fc" id="L88">        final Map&lt;GordianSymKeySpec, GordianKey&lt;GordianSymKeySpec&gt;&gt; myMap = pKeySet.getSymKeyMap();</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        for (Entry&lt;GordianSymKeySpec, GordianKey&lt;GordianSymKeySpec&gt;&gt; myEntry : myMap.entrySet()) {</span>
<span class="fc" id="L90">            theMap.put(myEntry.getKey().getSymKeyType().ordinal() + 1,</span>
<span class="fc" id="L91">                    ((GordianCoreKey&lt;GordianSymKeySpec&gt;) myEntry.getValue()).getKeyBytes());</span>
<span class="fc" id="L92">        }</span>
<span class="fc" id="L93">    }</span>

    /**
     * Constructor.
     *
     * @param pSequence the Sequence
     * @throws GordianException on error
     */
<span class="fc" id="L101">    private GordianKeySetASN1(final ASN1Sequence pSequence) throws GordianException {</span>
        /* Protect against exceptions */
        try {
            /* Create the map */
<span class="fc" id="L105">            theMap = new LinkedHashMap&lt;&gt;();</span>

            /* Build the map from the sequence */
<span class="fc" id="L108">            Enumeration&lt;?&gt; en = pSequence.getObjects();</span>
<span class="fc" id="L109">            theSpec = GordianKeySetSpecASN1.getInstance(en.nextElement()).getSpec();</span>
<span class="fc" id="L110">            final ASN1Sequence myKeySet = ASN1Sequence.getInstance(en.nextElement());</span>

            /* Make sure that we have completed the sequence */
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            if (en.hasMoreElements()) {</span>
<span class="nc" id="L114">                throw new GordianDataException(&quot;Unexpected additional values in ASN1 sequence&quot;);</span>
            }

            /* Build the map from the keySet sequence */
<span class="fc" id="L118">            en = myKeySet.getObjects();</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            while (en.hasMoreElements()) {</span>
<span class="fc" id="L120">                final ASN1Sequence k = ASN1Sequence.getInstance(en.nextElement());</span>
<span class="fc" id="L121">                final Enumeration&lt;?&gt; ek = k.getObjects();</span>
<span class="fc" id="L122">                theMap.put(ASN1Integer.getInstance(ek.nextElement()).getValue().intValue(),</span>
<span class="fc" id="L123">                        ASN1OctetString.getInstance(ek.nextElement()).getOctets());</span>
<span class="fc" id="L124">            }</span>

            /* handle exceptions */
<span class="nc" id="L127">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L128">            throw new GordianIOException(&quot;Unable to parse ASN1 sequence&quot;, e);</span>
<span class="fc" id="L129">        }</span>
<span class="fc" id="L130">    }</span>

    /**
     * Parse the ASN1 object.
     *
     * @param pObject the object to parse
     * @return the parsed object
     * @throws GordianException on error
     */
    public static GordianKeySetASN1 getInstance(final Object pObject) throws GordianException {
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (pObject instanceof GordianKeySetASN1 myASN1) {</span>
<span class="nc" id="L141">            return myASN1;</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        } else if (pObject != null) {</span>
<span class="fc" id="L143">            return new GordianKeySetASN1(ASN1Sequence.getInstance(pObject));</span>
        }
<span class="nc" id="L145">        throw new GordianDataException(&quot;Null sequence&quot;);</span>
    }

    @Override
    public ASN1Primitive toASN1Primitive() {
        /* Build the keySetSequence */
<span class="fc" id="L151">        final ASN1EncodableVector ks = new ASN1EncodableVector();</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">        for (Entry&lt;Integer, byte[]&gt; myEntry : theMap.entrySet()) {</span>
<span class="fc" id="L153">            final ASN1EncodableVector k = new ASN1EncodableVector();</span>
<span class="fc" id="L154">            k.add(new ASN1Integer(myEntry.getKey()));</span>
<span class="fc" id="L155">            k.add(new DEROctetString(myEntry.getValue()));</span>
<span class="fc" id="L156">            ks.add(new DERSequence(k).toASN1Primitive());</span>
<span class="fc" id="L157">        }</span>

        /* Build the overall sequence */
<span class="fc" id="L160">        final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="fc" id="L161">        v.add(new GordianKeySetSpecASN1(theSpec).toASN1Primitive());</span>
<span class="fc" id="L162">        v.add(new DERSequence(ks));</span>
<span class="fc" id="L163">        return new DERSequence(v);</span>
    }

    /**
     * Build a keySet from the details.
     *
     * @param pFactory the keySet factory
     * @return the new keySet
     * @throws GordianException on error
     */
    GordianBaseKeySet buildKeySet(final GordianBaseFactory pFactory) throws GordianException {
        /* Create the new keySet */
<span class="fc" id="L175">        final GordianBaseKeySetFactory myKeySetFactory = (GordianBaseKeySetFactory) pFactory.getKeySetFactory();</span>
<span class="fc" id="L176">        final GordianCipherFactory myCipherFactory = pFactory.getCipherFactory();</span>
<span class="fc" id="L177">        final GordianBaseKeySet myKeySet = myKeySetFactory.createKeySet(theSpec);</span>

        /* Declare the keys */
<span class="fc bfc" id="L180" title="All 2 branches covered.">        for (Entry&lt;Integer, byte[]&gt; myEntry : theMap.entrySet()) {</span>
<span class="fc" id="L181">            final GordianSymKeyType myKeyType = GordianSymKeyType.values()[myEntry.getKey() - 1];</span>
<span class="fc" id="L182">            final GordianSymKeySpec mySpec = new GordianSymKeySpec(myKeyType, GordianLength.LEN_128, theSpec.getKeyLength());</span>
<span class="fc" id="L183">            final GordianCoreKeyGenerator&lt;GordianSymKeySpec&gt; myGenerator =</span>
<span class="fc" id="L184">                    (GordianCoreKeyGenerator&lt;GordianSymKeySpec&gt;) myCipherFactory.getKeyGenerator(mySpec);</span>

            /* Generate and declare the key */
<span class="fc" id="L187">            final GordianKey&lt;GordianSymKeySpec&gt; myKey = myGenerator.buildKeyFromBytes(myEntry.getValue());</span>
<span class="fc" id="L188">            myKeySet.declareSymKey(myKey);</span>
<span class="fc" id="L189">        }</span>

        /* Return the keySet */
<span class="fc" id="L192">        return myKeySet;</span>
    }

    /**
     * Obtain the byte length for a given wrapped keyLength and # of keys.
     *
     * @param pKeyLen  the wrapped key length
     * @param pNumKeys the number of keys
     * @return the byte length
     */
    static int getEncodedLength(final int pKeyLen,
                                final int pNumKeys) {
        /* Key length is type + length + value */
<span class="fc" id="L205">        int myLength = GordianASN1Util.getLengthByteArrayField(pKeyLen);</span>

        /* KeyType is guaranteed single byte value */
<span class="fc" id="L208">        myLength += GordianASN1Util.getLengthIntegerField(1);</span>

        /* Calculate the length of the sequence */
<span class="fc" id="L211">        myLength = GordianASN1Util.getLengthSequence(myLength);</span>

        /* We have pNumKeys of these in a sequence */
<span class="fc" id="L214">        myLength = GordianASN1Util.getLengthSequence(myLength * pNumKeys);</span>

        /* Return the sequence length */
<span class="fc" id="L217">        return GordianASN1Util.getLengthSequence(myLength + GordianKeySetSpecASN1.getEncodedLength());</span>
    }

    @Override
    public boolean equals(final Object pThat) {
        /* Handle trivial cases */
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (this == pThat) {</span>
<span class="nc" id="L224">            return true;</span>
        }
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (pThat == null) {</span>
<span class="nc" id="L227">            return false;</span>
        }

        /* Check that the fields are equal */
<span class="nc" id="L231">        return pThat instanceof GordianKeySetASN1 myThat</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                &amp;&amp; Objects.equals(theSpec, myThat.theSpec)</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">                &amp;&amp; Objects.equals(theMap, myThat.theMap);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L238">        return Objects.hash(theSpec, theMap);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
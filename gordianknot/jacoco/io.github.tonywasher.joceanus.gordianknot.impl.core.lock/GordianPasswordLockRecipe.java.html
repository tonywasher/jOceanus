<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GordianPasswordLockRecipe.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GordianKnot Security Framework</a> &gt; <a href="index.source.html" class="el_package">io.github.tonywasher.joceanus.gordianknot.impl.core.lock</a> &gt; <span class="el_source">GordianPasswordLockRecipe.java</span></div><h1>GordianPasswordLockRecipe.java</h1><pre class="source lang-java linenums">/*
 * GordianKnot: Security Suite
 * Copyright 2012-2026. Tony Washer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.github.tonywasher.joceanus.gordianknot.impl.core.lock;

import io.github.tonywasher.joceanus.gordianknot.api.base.GordianException;
import io.github.tonywasher.joceanus.gordianknot.api.base.GordianLength;
import io.github.tonywasher.joceanus.gordianknot.api.digest.GordianDigest;
import io.github.tonywasher.joceanus.gordianknot.api.digest.GordianDigestFactory;
import io.github.tonywasher.joceanus.gordianknot.api.digest.GordianDigestSpec;
import io.github.tonywasher.joceanus.gordianknot.api.digest.GordianDigestType;
import io.github.tonywasher.joceanus.gordianknot.api.keyset.GordianBadCredentialsException;
import io.github.tonywasher.joceanus.gordianknot.api.lock.GordianPasswordLockSpec;
import io.github.tonywasher.joceanus.gordianknot.api.mac.GordianMac;
import io.github.tonywasher.joceanus.gordianknot.api.mac.GordianMacFactory;
import io.github.tonywasher.joceanus.gordianknot.api.mac.GordianMacSpec;
import io.github.tonywasher.joceanus.gordianknot.api.mac.GordianMacSpecBuilder;
import io.github.tonywasher.joceanus.gordianknot.impl.core.base.GordianBaseFactory;
import io.github.tonywasher.joceanus.gordianknot.impl.core.base.GordianDataConverter;
import io.github.tonywasher.joceanus.gordianknot.impl.core.base.GordianIdManager;
import io.github.tonywasher.joceanus.gordianknot.impl.core.base.GordianPersonalisation;
import io.github.tonywasher.joceanus.gordianknot.impl.core.base.GordianPersonalisation.GordianPersonalId;
import io.github.tonywasher.joceanus.gordianknot.impl.core.keyset.GordianCoreKeySet;
import io.github.tonywasher.joceanus.gordianknot.impl.core.keyset.GordianCoreKeySetFactory;

import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Random;

/**
 * Class for assembling/disassembling PasswordLocks.
 */
public final class GordianPasswordLockRecipe {
    /**
     * Hash margins.
     */
    private static final int HASH_MARGIN = 4;

    /**
     * The PasswordLockSpec.
     */
    private final GordianPasswordLockSpec theLockSpec;

    /**
     * The Recipe.
     */
    private final byte[] theRecipe;

    /**
     * The Salt.
     */
    private final byte[] theSalt;

    /**
     * The Initialisation Vector.
     */
    private final byte[] theInitVector;

    /**
     * The Hash.
     */
    private byte[] theHashBytes;

    /**
     * The Payload.
     */
    private final byte[] thePayload;

    /**
     * The Lock Parameters.
     */
    private final GordianPasswordLockParams theParams;

    /**
     * Constructor for random choices.
     *
     * @param pFactory  the factory
     * @param pLockSpec the passwordLockSpec
     */
    GordianPasswordLockRecipe(final GordianBaseFactory pFactory,
<span class="fc" id="L94">                              final GordianPasswordLockSpec pLockSpec) {</span>
        /* Access the secureRandom */
<span class="fc" id="L96">        final SecureRandom myRandom = pFactory.getRandomSource().getRandom();</span>

        /* Create the Salt vector */
<span class="fc" id="L99">        theSalt = new byte[GordianLockData.SALTLEN];</span>
<span class="fc" id="L100">        myRandom.nextBytes(theSalt);</span>

        /* Calculate the initVector */
<span class="fc" id="L103">        final GordianPersonalisation myPersonal = pFactory.getPersonalisation();</span>
<span class="fc" id="L104">        theInitVector = myPersonal.adjustIV(theSalt);</span>

        /* Allocate new set of parameters */
<span class="fc" id="L107">        theParams = new GordianPasswordLockParams(pFactory);</span>
<span class="fc" id="L108">        theRecipe = theParams.getRecipe();</span>
<span class="fc" id="L109">        theLockSpec = pLockSpec;</span>
<span class="fc" id="L110">        theHashBytes = null;</span>
<span class="fc" id="L111">        thePayload = null;</span>
<span class="fc" id="L112">    }</span>

    /**
     * Constructor for external form parse.
     *
     * @param pFactory    the factory
     * @param pPassLength the password length
     * @param pLockASN1   the lockASN1
     */
    GordianPasswordLockRecipe(final GordianBaseFactory pFactory,
                              final int pPassLength,
<span class="fc" id="L123">                              final GordianPasswordLockASN1 pLockASN1) {</span>
        /* Parse the ASN1 external form */
<span class="fc" id="L125">        final byte[] myHashBytes = pLockASN1.getHashBytes();</span>
<span class="fc" id="L126">        theLockSpec = pLockASN1.getLockSpec();</span>
<span class="fc" id="L127">        thePayload = pLockASN1.getPayload();</span>

        /* Create the byte arrays */
<span class="fc" id="L130">        theRecipe = new byte[GordianLockData.RECIPELEN];</span>
<span class="fc" id="L131">        theSalt = new byte[GordianLockData.SALTLEN];</span>
<span class="fc" id="L132">        theHashBytes = new byte[GordianLockData.HASHLEN];</span>

        /* Determine offset position */
<span class="fc" id="L135">        int myOffSet = Math.max(pPassLength, HASH_MARGIN);</span>
<span class="fc" id="L136">        myOffSet = Math.min(myOffSet, GordianLockData.HASHLEN</span>
                - HASH_MARGIN);

        /* Copy Data into buffers */
<span class="fc" id="L140">        System.arraycopy(myHashBytes, 0, theHashBytes, 0, myOffSet);</span>
<span class="fc" id="L141">        System.arraycopy(myHashBytes, myOffSet, theRecipe, 0, GordianLockData.RECIPELEN);</span>
<span class="fc" id="L142">        System.arraycopy(myHashBytes, myOffSet</span>
                + GordianLockData.RECIPELEN, theSalt, 0, GordianLockData.SALTLEN);
<span class="fc" id="L144">        System.arraycopy(myHashBytes, myOffSet</span>
                + GordianLockData.RECIPELEN
                + GordianLockData.SALTLEN, theHashBytes, myOffSet, GordianLockData.HASHLEN
                - myOffSet);

        /* Calculate the initVector */
<span class="fc" id="L150">        final GordianPersonalisation myPersonal = pFactory.getPersonalisation();</span>
<span class="fc" id="L151">        theInitVector = myPersonal.adjustIV(theSalt);</span>

        /* Allocate new set of parameters */
<span class="fc" id="L154">        theParams = new GordianPasswordLockParams(pFactory, theRecipe);</span>
<span class="fc" id="L155">    }</span>

    /**
     * Obtain the payload.
     *
     * @return the payLoad
     */
    byte[] getPayload() {
<span class="fc" id="L163">        return thePayload;</span>
    }

    /**
     * Build lockBytes for hash and password length.
     *
     * @param pPassLength the password length
     * @param pPayload    the payload
     * @return the lockBytes
     */
    GordianPasswordLockASN1 buildLockASN1(final int pPassLength,
                                          final byte[] pPayload) {
        /* Allocate the new buffer */
<span class="fc" id="L176">        final int myHashLen = theHashBytes.length;</span>
<span class="fc" id="L177">        final int myLen = GordianLockData.RECIPELEN</span>
                + GordianLockData.SALTLEN
                + myHashLen;
<span class="fc" id="L180">        final byte[] myBuffer = new byte[myLen];</span>

        /* Determine offset position */
<span class="fc" id="L183">        int myOffSet = Math.max(pPassLength, HASH_MARGIN);</span>
<span class="fc" id="L184">        myOffSet = Math.min(myOffSet, myHashLen</span>
                - HASH_MARGIN);

        /* Copy Data into buffer */
<span class="fc" id="L188">        System.arraycopy(theHashBytes, 0, myBuffer, 0, myOffSet);</span>
<span class="fc" id="L189">        System.arraycopy(theRecipe, 0, myBuffer, myOffSet, GordianLockData.RECIPELEN);</span>
<span class="fc" id="L190">        System.arraycopy(theSalt, 0, myBuffer, myOffSet</span>
                + GordianLockData.RECIPELEN, GordianLockData.SALTLEN);
<span class="fc" id="L192">        System.arraycopy(theHashBytes, myOffSet, myBuffer, myOffSet</span>
                + GordianLockData.RECIPELEN
                + GordianLockData.SALTLEN, myHashLen
                - myOffSet);

        /* Build the ASN1 form */
<span class="fc" id="L198">        return new GordianPasswordLockASN1(theLockSpec, myBuffer, pPayload);</span>
    }

    /**
     * Process password.
     *
     * @param pFactory  the factory
     * @param pPassword the password for the keys
     * @return the locking KeySet
     * @throws GordianException on error
     */
    GordianCoreKeySet processPassword(final GordianBaseFactory pFactory,
                                      final byte[] pPassword) throws GordianException {
        /* Obtain configuration details */
<span class="fc" id="L212">        final GordianPersonalisation myPersonal = pFactory.getPersonalisation();</span>
<span class="fc" id="L213">        final int iIterations = theLockSpec.getNumIterations();</span>
<span class="fc" id="L214">        final int iFinal = theParams.getAdjustment()</span>
                + iIterations;

        /* Create a byte array of the iterations */
<span class="fc" id="L218">        final byte[] myLoops = GordianDataConverter.integerToByteArray(iFinal);</span>

        /* Access factories */
<span class="fc" id="L221">        final GordianDigestFactory myDigests = pFactory.getDigestFactory();</span>
<span class="fc" id="L222">        final GordianMacFactory myMacs = pFactory.getMacFactory();</span>

        /* Create the primeMac */
<span class="fc" id="L225">        GordianMacSpec myMacSpec = GordianMacSpecBuilder.hMac(theParams.getPrimeDigest());</span>
<span class="fc" id="L226">        final GordianMac myPrimeMac = myMacs.createMac(myMacSpec);</span>
<span class="fc" id="L227">        myPrimeMac.initKeyBytes(pPassword);</span>

        /* Create the alternateMac */
<span class="fc" id="L230">        myMacSpec = GordianMacSpecBuilder.hMac(theParams.getSecondaryDigest());</span>
<span class="fc" id="L231">        final GordianMac mySecondaryMac = myMacs.createMac(myMacSpec);</span>
<span class="fc" id="L232">        mySecondaryMac.initKeyBytes(pPassword);</span>

        /* Create the alternateMac */
<span class="fc" id="L235">        myMacSpec = GordianMacSpecBuilder.hMac(theParams.getTertiaryDigest());</span>
<span class="fc" id="L236">        final GordianMac myTertiaryMac = myMacs.createMac(myMacSpec);</span>
<span class="fc" id="L237">        myTertiaryMac.initKeyBytes(pPassword);</span>

        /* Create the secretMac */
<span class="fc" id="L240">        myMacSpec = GordianMacSpecBuilder.hMac(new GordianDigestSpec(theParams.getSecretDigest(), GordianLength.LEN_512));</span>
<span class="fc" id="L241">        final GordianMac mySecretMac = myMacs.createMac(myMacSpec);</span>
<span class="fc" id="L242">        mySecretMac.initKeyBytes(pPassword);</span>

        /* Initialise hash bytes and counter */
<span class="fc" id="L245">        final byte[] myPrimeBytes = new byte[myPrimeMac.getMacSize()];</span>
<span class="fc" id="L246">        final byte[] mySecondaryBytes = new byte[mySecondaryMac.getMacSize()];</span>
<span class="fc" id="L247">        final byte[] myTertiaryBytes = new byte[myTertiaryMac.getMacSize()];</span>
<span class="fc" id="L248">        final byte[] mySecretBytes = new byte[mySecretMac.getMacSize()];</span>
<span class="fc" id="L249">        final byte[] myPrimeHash = new byte[myPrimeMac.getMacSize()];</span>
<span class="fc" id="L250">        final byte[] mySecondaryHash = new byte[mySecondaryMac.getMacSize()];</span>
<span class="fc" id="L251">        final byte[] myTertiaryHash = new byte[myTertiaryMac.getMacSize()];</span>
<span class="fc" id="L252">        final byte[] mySecretHash = new byte[mySecretMac.getMacSize()];</span>

        /* Access final digest */
<span class="fc" id="L255">        final GordianDigestSpec myDigestSpec = new GordianDigestSpec(theParams.getExternalDigest(), GordianLength.LEN_512);</span>
<span class="fc" id="L256">        final GordianDigest myDigest = myDigests.createDigest(myDigestSpec);</span>

        /* Initialise the hash input values as the salt bytes */
<span class="fc" id="L259">        final byte[] mySaltBytes = theInitVector;</span>
<span class="fc" id="L260">        byte[] myPrimeInput = mySaltBytes;</span>
<span class="fc" id="L261">        byte[] mySecondaryInput = mySaltBytes;</span>
<span class="fc" id="L262">        byte[] myTertiaryInput = mySaltBytes;</span>
<span class="fc" id="L263">        byte[] mySecretInput = mySaltBytes;</span>

        /* Protect from exceptions */
        try {
            /* Update each Hash with the personalisation */
<span class="fc" id="L268">            myPersonal.updateMac(myPrimeMac);</span>
<span class="fc" id="L269">            myPersonal.updateMac(mySecondaryMac);</span>
<span class="fc" id="L270">            myPersonal.updateMac(myTertiaryMac);</span>
<span class="fc" id="L271">            myPersonal.updateMac(mySecretMac);</span>

            /* Update each Hash with the loops */
<span class="fc" id="L274">            myPrimeMac.update(myLoops);</span>
<span class="fc" id="L275">            mySecondaryMac.update(myLoops);</span>
<span class="fc" id="L276">            myTertiaryMac.update(myLoops);</span>
<span class="fc" id="L277">            mySecretMac.update(myLoops);</span>

            /* Loop through the iterations */
<span class="fc bfc" id="L280" title="All 2 branches covered.">            for (int iPass = 0; iPass &lt; iFinal; iPass++) {</span>
                /* Update the prime Mac */
<span class="fc" id="L282">                myPrimeMac.update(mySecondaryInput);</span>
<span class="fc" id="L283">                myPrimeMac.update(myTertiaryInput);</span>

                /* Update the secondary Mac */
<span class="fc" id="L286">                mySecondaryMac.update(myPrimeInput);</span>
<span class="fc" id="L287">                mySecondaryMac.update(myTertiaryInput);</span>

                /* Update the tertiary Mac */
<span class="fc" id="L290">                myTertiaryMac.update(myPrimeInput);</span>
<span class="fc" id="L291">                myTertiaryMac.update(mySecondaryInput);</span>

                /* Update the secret Mac */
<span class="fc" id="L294">                mySecretMac.update(mySecretInput);</span>
<span class="fc" id="L295">                mySecretMac.update(myPrimeInput);</span>
<span class="fc" id="L296">                mySecretMac.update(mySecondaryInput);</span>
<span class="fc" id="L297">                mySecretMac.update(myTertiaryInput);</span>

                /* Update inputs */
<span class="fc" id="L300">                myPrimeInput = myPrimeHash;</span>
<span class="fc" id="L301">                mySecondaryInput = mySecondaryHash;</span>
<span class="fc" id="L302">                myTertiaryInput = myTertiaryHash;</span>
<span class="fc" id="L303">                mySecretInput = mySecretHash;</span>

                /* Recalculate hashes and combine them */
<span class="fc" id="L306">                myPrimeMac.finish(myPrimeHash, 0);</span>
<span class="fc" id="L307">                GordianPersonalisation.buildHashResult(myPrimeBytes, myPrimeHash);</span>
<span class="fc" id="L308">                mySecondaryMac.finish(mySecondaryHash, 0);</span>
<span class="fc" id="L309">                GordianPersonalisation.buildHashResult(mySecondaryBytes, mySecondaryHash);</span>
<span class="fc" id="L310">                myTertiaryMac.finish(myTertiaryHash, 0);</span>
<span class="fc" id="L311">                GordianPersonalisation.buildHashResult(myTertiaryBytes, myTertiaryHash);</span>
<span class="fc" id="L312">                mySecretMac.finish(mySecretHash, 0);</span>
<span class="fc" id="L313">                GordianPersonalisation.buildHashResult(mySecretBytes, mySecretHash);</span>
            }

            /* Combine the Primary, Secondary and Tertiary bytes to form the external hash */
<span class="fc" id="L317">            myDigest.update(myPrimeBytes);</span>
<span class="fc" id="L318">            myDigest.update(mySecondaryBytes);</span>
<span class="fc" id="L319">            myDigest.update(myTertiaryBytes);</span>
<span class="fc" id="L320">            final byte[] myHashBytes = myDigest.finish();</span>

            /* If we are resolving the lock, check the hash */
<span class="fc bfc" id="L323" title="All 2 branches covered.">            if (theHashBytes != null</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">                    &amp;&amp; !Arrays.equals(theHashBytes, myHashBytes)) {</span>
                /* Fail the password attempt */
<span class="nc" id="L326">                throw new GordianBadCredentialsException(&quot;Invalid Password&quot;);</span>
            }
<span class="fc" id="L328">            theHashBytes = myHashBytes;</span>

            /* Create the Key Set */
<span class="fc" id="L331">            final GordianCoreKeySet myKeySet = ((GordianCoreKeySetFactory) pFactory.getKeySetFactory()).createKeySet(theLockSpec.getKeySetSpec());</span>
<span class="fc" id="L332">            myKeySet.buildFromSecret(mySecretBytes);</span>

            /* Return to caller */
<span class="fc" id="L335">            return myKeySet;</span>

            /* Clear intermediate arrays */
        } finally {
<span class="fc" id="L339">            Arrays.fill(myPrimeHash, (byte) 0);</span>
<span class="fc" id="L340">            Arrays.fill(myPrimeBytes, (byte) 0);</span>
<span class="fc" id="L341">            Arrays.fill(mySecondaryHash, (byte) 0);</span>
<span class="fc" id="L342">            Arrays.fill(mySecondaryBytes, (byte) 0);</span>
<span class="fc" id="L343">            Arrays.fill(myTertiaryHash, (byte) 0);</span>
<span class="fc" id="L344">            Arrays.fill(myTertiaryBytes, (byte) 0);</span>
<span class="fc" id="L345">            Arrays.fill(mySecretHash, (byte) 0);</span>
<span class="fc" id="L346">            Arrays.fill(mySecretBytes, (byte) 0);</span>
        }
    }

    /**
     * The parameters class.
     */
    private static final class GordianPasswordLockParams {
        /**
         * The Recipe.
         */
        private final byte[] theRecipe;

        /**
         * The secret hMac type.
         */
        private final GordianDigestType theSecretDigest;

        /**
         * The hMac types.
         */
        private final GordianDigestType[] theDigests;

        /**
         * The external Digest type.
         */
        private final GordianDigestType theExternalDigest;

        /**
         * The Adjustment.
         */
        private final int theAdjust;

        /**
         * Construct the parameters from random.
         *
         * @param pFactory the factory
         */
<span class="fc" id="L384">        GordianPasswordLockParams(final GordianBaseFactory pFactory) {</span>
            /* Obtain Id manager and random */
<span class="fc" id="L386">            final GordianIdManager myManager = pFactory.getIdManager();</span>
<span class="fc" id="L387">            final GordianPersonalisation myPersonal = pFactory.getPersonalisation();</span>
<span class="fc" id="L388">            final SecureRandom myRandom = pFactory.getRandomSource().getRandom();</span>

            /* Generate recipe and derive digestTypes */
<span class="fc" id="L391">            final int mySeed = myRandom.nextInt();</span>
<span class="fc" id="L392">            theRecipe = GordianDataConverter.integerToByteArray(mySeed);</span>
<span class="fc" id="L393">            final Random mySeededRandom = myPersonal.getSeededRandom(GordianPersonalId.LOCKRANDOM, theRecipe);</span>
<span class="fc" id="L394">            theSecretDigest = myManager.deriveLockSecretTypeFromSeed(mySeededRandom);</span>
<span class="fc" id="L395">            theDigests = myManager.deriveLockDigestTypesFromSeed(mySeededRandom, GordianLockData.NUM_DIGESTS);</span>
<span class="fc" id="L396">            theExternalDigest = myManager.deriveExternalDigestTypeFromSeed(mySeededRandom);</span>

            /* Derive random adjustment value */
<span class="fc" id="L399">            theAdjust = mySeededRandom.nextInt(GordianDataConverter.NYBBLE_MASK + 1);</span>
<span class="fc" id="L400">        }</span>

        /**
         * Construct the parameters from recipe.
         *
         * @param pFactory the factory
         * @param pRecipe  the recipe bytes
         */
        GordianPasswordLockParams(final GordianBaseFactory pFactory,
<span class="fc" id="L409">                                  final byte[] pRecipe) {</span>
            /* Obtain Id manager */
<span class="fc" id="L411">            final GordianIdManager myManager = pFactory.getIdManager();</span>
<span class="fc" id="L412">            final GordianPersonalisation myPersonal = pFactory.getPersonalisation();</span>

            /* Store recipe and derive digestTypes */
<span class="fc" id="L415">            theRecipe = pRecipe;</span>
<span class="fc" id="L416">            final Random mySeededRandom = myPersonal.getSeededRandom(GordianPersonalId.LOCKRANDOM, theRecipe);</span>
<span class="fc" id="L417">            theSecretDigest = myManager.deriveLockSecretTypeFromSeed(mySeededRandom);</span>
<span class="fc" id="L418">            theDigests = myManager.deriveLockDigestTypesFromSeed(mySeededRandom, GordianLockData.NUM_DIGESTS);</span>
<span class="fc" id="L419">            theExternalDigest = myManager.deriveExternalDigestTypeFromSeed(mySeededRandom);</span>

            /* Derive random adjustment value */
<span class="fc" id="L422">            theAdjust = mySeededRandom.nextInt(GordianDataConverter.NYBBLE_MASK + 1);</span>
<span class="fc" id="L423">        }</span>

        /**
         * Obtain the Recipe.
         *
         * @return the recipe
         */
        byte[] getRecipe() {
<span class="fc" id="L431">            return theRecipe;</span>
        }

        /**
         * Obtain the Prime Digest type.
         *
         * @return the digest type
         */
        GordianDigestType getPrimeDigest() {
<span class="fc" id="L440">            return theDigests[0];</span>
        }

        /**
         * Obtain the Secondary Digest type.
         *
         * @return the digest type
         */
        GordianDigestType getSecondaryDigest() {
<span class="fc" id="L449">            return theDigests[1];</span>
        }

        /**
         * Obtain the Tertiary Digest type.
         *
         * @return the digest type
         */
        GordianDigestType getTertiaryDigest() {
<span class="fc" id="L458">            return theDigests[2];</span>
        }

        /**
         * Obtain the Secret Digest type.
         *
         * @return the digest type
         */
        GordianDigestType getSecretDigest() {
<span class="fc" id="L467">            return theSecretDigest;</span>
        }

        /**
         * Obtain the external Digest type.
         *
         * @return the digest type
         */
        GordianDigestType getExternalDigest() {
<span class="fc" id="L476">            return theExternalDigest;</span>
        }

        /**
         * Obtain the Adjustment.
         *
         * @return the adjustment
         */
        int getAdjustment() {
<span class="fc" id="L485">            return theAdjust;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
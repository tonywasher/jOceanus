<document>
    <properties>
        <title>GordianKnot Asymmetric Agreements</title>
        <author email="Tony.Washer@yahoo.co.uk">Tony Washer</author>
    </properties>
    <body>
        <section name="Overview">
            <p>Algorithms are represented by <b>GordianAgreementSpec</b>. A <b>GordianAgreement</b> is obtained via the agreementSpec,
                and then agreements are created between the two parties depending on the type of the agreement and the resultType.
                The resultTypes can be any of the following</p>
            <table>
                <tr><th>ResultType</th><th>Description</th></tr>
                <tr><td>GordianParameters</td><td>The underlying agreement is used as the security phrase with the rest of the supplied parameters to
                    generate a new personalised <strong>GordianFactory</strong></td></tr>
                <tr><td>GordianKeySetSpec</td><td>The underlying agreement is used to generate a new <strong>GordianKeySet</strong> of the specified type,
                    belonging to an agreed BC factory.</td></tr>
                <tr><td>GordianSymCipherSpec</td><td>The agreement is used to generate a new <strong>GordianSymCipher</strong> Key and InitVector (if required),
                    belonging to an agreed BC factory. A pair of <strong>GordianSymCipher</strong>s are returned as the result, one for encryption
                    and one for decryption</td></tr>
                <tr><td>GordianStreamCipherSpec</td><td>Similar to <strong>GordianSymKeySpec</strong>.</td></tr>
                <tr><td>null</td><td>The raw agreement bytes are returned.</td></tr>
            </table>
            <p>Agreements are always targeted by a <strong>Client</strong> towards a <strong>Server</strong>. The <strong>GordianAgreement</strong>
                that is created will implement an appropriate interface as per the following sections</p>
        </section>
        <section name="Anonymous Agreement">
            <p><strong>GordianAnonymousAgreement</strong> is is a oneShot process where the <strong>Client</strong> must already
                know the publicKey of the <strong>Server</strong>. It will generate a <strong>ClientHello</strong> message that is sent to
                the <strong>Server</strong>. The <strong>Server</strong> knows nothing about the <strong>Client</strong>.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianAsymFactory myKeyPairFactory = myBase.getAsymmetricFactory();
                    final GordianAgreementFactory myAgreementFactory = myKeyPairFactory.getAgreementFactory();

                    /* Access keyPairGenerator and create sending/receiving pairs */
                    final GordianAsymKeySpec mySpec = GordianAsymKeySpec.dh(GordianDHGroup.rfc7919_ffdhe2048);
                    final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
                    final GordianKeyPair myClientPair = myGenerator.generateKeyPair();
                    final GordianKeyPair myServerPair = myGenerator.generateKeyPair();

                    /* Create anonymous agreement */
                    final GordianAgreementSpec myAgreeSpec = GordianAgreementSpec.dhAnon(GordianKDFType.SHA256KDF);
                    final GordianSymCipherSpec myCipherSpec = GordianSymCipherSpec.cbc(GordianGordianSymKeySpec.aes(GordianLength.LEN_256), GordianPadding.PKCS7);
                    final GordianAnonymousAgreement myAnonClient = (GordianAnonymousAgreement) myAgreementFactory.createAgreement(myAgreeSpec);
                    final GordianAnonymousAgreement myAnonServer = (GordianAnonymousAgreement) myAgreementFactory.createAgreement(myAgreeSpec);

                    /* Client side */
                    myAnonClient.setResultType(myCipherSpec);
                    final byte[] myClientHello = myAnonClient.createClientHello(myServerPair);
                    final GordianSymCipher[] myClientCiphers = (GordianSymCipher[]) myAnonClient.getResult();

                    /* Send myClientHello to server */

                    /* Server side */
                    myAnonServer.acceptClientHello(myServerPair, myClientHello);
                    final GordianSymCipherSpec myResultCipherSpec = (GordianSymCipherSpec) myAnonServer.getResultType();
                    final GordianSymCipher[] myServerCiphers = (GordianSymCipher[]) myAnonServer.getResult();
                </source>
            </subsection>
        </section>
        <section name="Handshake Agreement">
            <p><strong>GordianHandshakeAgreement</strong> requires the <strong>Client</strong> to generate a <strong>ClientHello</strong>
                message that is sent to the <strong>Server</strong>. The <strong>Server</strong> will process the <strong>ClientHello</strong> and generate
                a <strong>ServerHello</strong> messages in response which is returned to the <strong>Client</strong>. Generally both parties should know
                the publicKey of the partner, and it is expected that the user would pass the certificates for the publicKeys along with the
                <strong>ClientHello</strong> and <strong>ServerHello</strong> messages.</p>
            <p>Confirmation can also be required by the agreementSpec. In this case the <strong>Client</strong> will send an additional <strong>ClientConfirm</strong> message to the <strong>Server</strong>
                after processing the <strong>ServerHello</strong> message. The <strong>Server</strong> can determine that a confirmation is due either by
                checking the agreementSpec of by checking the status of the agreement.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianAsymFactory myKeyPairFactory = myBase.getAsymmetricFactory();
                    final GordianAgreementFactory myAgreementFactory = myKeyPairFactory.getAgreementFactory();

                    /* Access keyPairGenerator and create sending/receiving pairs */
                    final GordianAsymKeySpec mySpec = GordianAsymKeySpec.dh(GordianDHGroup.rfc7919_ffdhe2048);
                    final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
                    final GordianKeyPair myClientPair = myGenerator.generateKeyPair();
                    final GordianKeyPair myServerPair = myGenerator.generateKeyPair();

                    /* Create handshake agreement */
                    final GordianAgreementSpec myAgreeSpec = GordianAgreementSpec.dhUnified(GordianKDFType.SHA256KDF);
                    final GordianKeySetSpec myKeySetSpec = new GordianKeySetSpec(GordianLength.LEN_256);
                    final GordianHandshakeAgreement myHandshakeClient = (GordianHandshakeAgreement) myAgreementFactory.createAgreement(myAgreeSpec);
                    final GordianHandshakeAgreement myHandshakeServer = (GordianHandshakeAgreement) myAgreementFactory.createAgreement(myAgreeSpec);

                    /* Client side */
                    myHandshakeClient.setResultType(myKeySetSpec);
                    final byte[] myClientHello = myHandshakeClient.createClientHello(myClientPair);

                    /* Send myClientHello (plus Client Certificate) to server */

                    /* Server side */
                    final byte[] myServerHello = myHandshakeServer.acceptClientHello(myClientPair, myServerPair, myClientHello);
                    if (myHandshakeServer.getStatus() == GordianAgreementStatus.RESULT_AVAILABLE) {
                        /* Can access result now without waiting for confirmation */
                    }

                    /* Send myServerHello (plus Server Certificate) to server */

                    /* Client side */
                    final byte[] myClientConfirm = myHandshakeClient.acceptServerHello(myServerPair, myServerHello);
                    final GordianKeySet myClientKeySet = (GordianKeySet) myHandshakeClient.getResult();

                    /* If we are performing a confirm */
                    if (myClientConfirm != null) {
                        /* Send myClientConfirm to server */

                        /* Server side */
                        myHandshakeServer.processClientConfirm(myClientConfirm);
                    }

                    /* Server side */
                    final GordianKeySetSpec myResultKeySetSpec = (GordianKeySetSpec) myHandshakeServer.getResultType();
                    final GordianKeySet myServerKeySet = (GordianKeySet) myHandshakeServer.getResult();
                </source>
            </subsection>
        </section>
        <section name="Algorithms">
            <p>The following agreement algorithms are supported.</p>
            <table class="defTable">
                <tr><td class="defHdr">Algorithm</td><td class="defHdr">Variants</td></tr>
                <tr><td>RSA</td><td>RSA-KEM</td></tr>
                <tr><td>DH</td><td>Anonymous, Basic, MQV, Unified</td></tr>
                <tr><td>EC</td><td>ECIES, Anonymous, Basic, MQV, Unified</td></tr>
                <tr><td>GOST2012</td><td>ECIES, Anonymous, Basic, MQV, Unified</td></tr>
                <tr><td>DSTU4145</td><td>ECIES, Anonymous, Basic, MQV, Unified</td></tr>
                <tr><td>SM2</td><td>ECIES, Anonymous, Basic, MQV, Unified, SM2</td></tr>
                <tr><td>XDH</td><td>Anonymous, Basic, Unified</td></tr>
                <tr><td>NewHope</td><td>Anonymous</td></tr>
            </table>
            <p>The RSA-KEM, ECIES and Anonymous variants use Anonymous Agreements. All others use Handshake agreements.</p>
            <p>The Unified, MQV and SM2 variants support keyConfirmation.</p>
        </section>
    </body>
</document>

<document>
    <properties>

        <title>GordianKnot Asymmetric</title>
        <author email="Tony.Washer@yahoo.co.uk">Tony Washer</author>
    </properties>
    <body>
        <section name="Overview">
            <p>GordianKnot supports most Asymmetric algorithms that are available from BouncyCastle through the JCA.</p>
            <p>A keyPairGenerator can be created for an asymKeySpec (algorithm plus additional configuration)
                This will allow generation of a random keyPair plus translation to/from PKCS8/X509 encodings,
                and combines the role of KeyPairGenerator and KeyFactory in JCA.</p>
            <p>The various algorithms support Signature/Encryption/Agreement as available</p>
            <p>JCA supports all algorithms</p>
        </section>
        <section name="Key Management">
            <p>Algorithms are represented by <b>GordianAsymKeySpec</b>. A <b>GordianKeyPairGenerator</b> is obtained via the keySpec,
            and then keyPairs are generated or derived by the generator. The keyPair may be publicOnly if only the public key is known.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianAsymFactory myKeyPairFactory = myBaseFactory.getAsymmetricFactory();

                    /* Access keyPairGenerator */
                    final GordianAsymKeySpec mySpec = GordianAsymKeySpec.rsa(GordianRSAModulus.MOD2048);
                    final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
                    final GordianKeyPair myPair = myGenerator.generateKeyPair();

                    /* Access encodings */
                    final PKCS8EncodedKeySpec myPKCS8 = myGenerator.getPKCS8Encoding(myPair);
                    final X509EncodedKeySpec myX509 = myGenerator.getX509Encoding(myPair);

                    /* Derive publicOnly KeyPair */
                    final GordianKeyPair myPublicOnly = myGenerator.derivePublicOnlyKeyPair(myX509);

                    /* Derive full keyPair */
                    final GordianKeyPair myDerived = myGenerator.deriveKeyPair(myX509, myPKCS8);
                </source>
            </subsection>
            <subsection name="Algorithms">
                <p>The following asymmetric algorithms and variants are supported.</p>
                <table class="defTable">
                    <tr><td class="defHdr">Algorithm</td><td class="defHdr">Variants</td></tr>
                    <tr><td>RSA</td><td>Modulus 1024, 1536, 2048, 3072, 4096, 6144, 8192</td></tr>
                    <tr><td>DSA</td><td>Modulus 1024, 2048, 3096</td></tr>
                    <tr><td>DiffieHellman</td><td>rfc2409_1024, rfc3526_1536, rfc3526_2048, rfc3526_3072, rfc3526_4096, rfc3526_6144, rfc3526_8192,
                        rfc7919_ffdhe2048, rfc7919_ffdhe3072, rfc7919_ffdhe4096, rfc7919_ffdhe6144, rfc7919_ffdhe8192</td></tr>
                    <tr><td>EC</td><td>sect571k1, sect571r1, secp521r1, sect409k1, sect409r1, secp384r1, sect283k1, sect283r1, secp256k1,
                        secp256r1, sect239k1, sect233k1, sect233r1, secp224k1, secp224r1, sect193r1, sect193r2, secp192k1, secp192r1, sect163k1,
                        sect163r1, sect163r2, secp160k1, secp160r1, secp160r2, sect131r1, sect131r2, secp128r1, secp128r2, sect113r1, sect113r2,
                        secp112r1, secp112r2,
                        prime239v1, prime239v2, prime239v3, prime192v2, prime192v3,
                        c2tnb431r1, c2pnb368w1, c2tnb359v1, c2pnb304w1, c2pnb272w1, c2tnb239v1, c2tnb239v2, c2tnb239v3, c2pnb208w1, c2tnb191v1,
                        c2tnb191v2, c2tnb191v3, c2pnb176w1, c2pnb163v1, c2pnb163v2, c2pnb163v3,
                        brainpoolP512r1, brainpoolP512t1, brainpoolP384r1, brainpoolP384t1, brainpoolP320r1, brainpoolP320t1, brainpoolP256r1,
                        brainpoolP256t1, brainpoolP224r1, brainpoolP224t1, brainpoolP192r1, brainpoolP192t1, brainpoolP160r1, brainpoolP160t1</td></tr>
                    <tr><td>DSTU4145</td><td>Curves 1-9</td></tr>
                    <tr><td>GOST2012</td><td>Tc26-Gost-3410-12-512-paramSetA,B,C Tc26-Gost-3410-12-256-paramSetA</td></tr>
                    <tr><td>SM2</td><td>sm2p256v1, wapip192v1</td></tr>
                    <tr><td>EdDSA</td><td>Curve25518, Curve448</td></tr>
                    <tr><td>XDH</td><td>Curve25518, Curve448</td></tr>
                    <tr><td>McEliece</td><td>Standard, CCA2(SHA1,SHA224,SHA256,SHA384,SHA512)</td></tr>
                    <tr><td>NewHope</td><td/></tr>
                    <tr><td>SPHINCS256</td><td>SHA2, SHA3</td></tr>
                    <tr><td>Rainbow</td><td/></tr>
                    <tr><td>XMSS</td><td>XMSS(SHA256,SHA512,SHAKE128,SHAKE256), XMSS^MT(SHA256,SHA512,SHAKE128,SHAKE256)</td></tr>
                    <tr><td>QTESLA</td><td>PROVABLY_SECURE_I,III</td></tr>
                    <tr><td rowspan="2">LMS</td><td>SIG(H5,H10,H25,H20,H25) * OTS(W1,W2,W4,W8)</td></tr>
                    <tr><td>HSS(LMS * DEPTH(2..8)</td></tr>
                </table>
            </subsection>
        </section>
        <section name="Signatures">
            <p>Algorithms are represented by <b>GordianSignatureSpec</b>. A <b>GordianSignature</b> is obtained via the signatureSpec,
                and then signatures are generated or verified  by the signer.</p>
            <p>The <b>LMS</b> and <b>XMSS</b> signature schemes are stateful signature schemes and as such their keyPairs support the
                <b>GordianStateAwareKeyPair</b> interface which allows sharding of the privateKey</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianAsymFactory myKeyPairFactory = myBase.getAsymmetricFactory();
                    final GordianSignatureFactory mySignatureFactory = myKeyPairFactory.getSignatureFactory();

                    /* Access keyPairGenerator */
                    final GordianAsymKeySpec mySpec = GordianAsymKeySpec.rsa(GordianRSAModulus.MOD2048);
                    final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
                    final GordianKeyPair myPair = myGenerator.generateKeyPair();

                    /* Access signer */
                    final GordianSignatureSpec mySignSpec = GordianSignatureSpec.rsa(GordianSignatureType.PSS,
                                                                                     GordianDigestSpec.sha2(GordianLength.LEN_256));
                    final GordianSignature mySigner = mySignatureFactory.createSigner(mySignSpec);

                    /* Sign message */
                    final byte[] message = ....;
                    mySigner.initForSigning(myPair);
                    mySigner.update(message);
                    final byte[] mySignature = mySigner.sign();

                    /* Verify signature */
                    mySigner.initForVerify(myPair);
                    mySigner.update(message);
                    final boolean verified = mySigner.verify(mySignature);
                </source>
            </subsection>
            <subsection name="Algorithms">
                <p>The following signature algorithms are supported.</p>
                <table class="defTable">
                    <tr><td class="defHdr">Algorithm</td><td class="defHdr">Variants</td></tr>
                    <tr><td>RSA</td><td>PSS, X931, ISO9796D2, PreHash</td></tr>
                    <tr><td>DSA</td><td>DSA, DetDSA</td></tr>
                    <tr><td>EC</td><td>ECDSA, ECDetDSA, ECNR</td></tr>
                    <tr><td>DSTU4145</td><td>Native</td></tr>
                    <tr><td>GOST2012</td><td>Native</td></tr>
                    <tr><td>SM2</td><td>Native</td></tr>
                    <tr><td>EdDSA</td><td>Pure, PreHash</td></tr>
                    <tr><td>Rainbow</td><td>Native</td></tr>
                    <tr><td>SPHINCS256</td><td>PreHash</td></tr>
                    <tr><td>XMSS</td><td>Pure, PreHash</td></tr>
                    <tr><td>QTESLA</td><td>Pure</td></tr>
                    <tr><td>LMS</td><td>Pure</td></tr>
                </table>
            </subsection>
        </section>
        <section name="Agreements">
            <p>Algorithms are represented by <b>GordianAgreementSpec</b>. A <b>GordianAgreement</b> is obtained via the agreementSpec,
                and then agreements are created between the two parties depending on the type of the agreement and the resultType.
                The resultTypes can be any of the following</p>
            <dl>
                <dt>GordianParameters</dt><dd>The underlying agreement is used as the security phrase with the rest of the supplied parameters to generate a
                    new personalised <strong>GordianFactory</strong></dd>
                <dt>GordianKeySetSpec</dt><dd>The underlying agreement is used to generate a new GordianKeySet of the specified type, belonging to an agreed BC factory.</dd>
                <dt>GordianSymCipherSpec</dt><dd>The agreement is used to generate a new GordianSymCipher Key and InitVector (if required). A pair of GordianSymCiphers are
                    returned as the result, one for encryption and one for decryption</dd>
                <dt>GordianStreamCipherSpec</dt><dd>Similar to SymKeySpec.</dd>
                <dt>null</dt><dd>The raw agreement bytes are returned.</dd>
            </dl>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianAsymFactory myKeyPairFactory = myBase.getAsymmetricFactory();
                    final GordianAgreementFactory myAgreementFactory = myKeyPairFactory.getSignatureFactory();

                    /* Access keyPairGenerator and create sending/reciving pairs */
                    final GordianAsymKeySpec mySpec = GordianAsymKeySpec.dh(GordianDHGroup.rfc7919_ffdhe2048);
                    final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
                    final GordianKeyPair mySendingPair = myGenerator.generateKeyPair();
                    final GordianKeyPair myReceivingPair = myGenerator.generateKeyPair();

                    /*
                     * Create anonymous agreement
                     */
                    GordianAgreementSpec myAgreeSpec = GordianAgreementSpec.dhAnon(GordianKDFType.SHA256KDF);
                    GordianSymCipherSpec myCipherSpec = GordianSymCipherSpec.cbc(GordianGordianSymKeySpec.aes(GordianLength.LEN_256), GordianPadding.PKCS7);
                    final GordianAnonymousAgreement myAnonSender = (GordianAnonymousAgreement) myAgreementFactory.createAgreement(myAgreeSpec);
                    myAnonSender.setResultType(myCipherSpec);
                    final GordianAnonymousAgreement myAnonReceiver = (GordianAnonymousAgreement) myAgreementFactory.createAgreement(myAgreeSpec);

                    /* Sender side */
                    byte[] myMessage = myAnonSender.initiateAgreement(myReceivingPair);
                    GordianKey&lt;GordianSymKeySpec&gt; myKey = (GordianKey&lt;GordianSymKeySpec&gt;) myAnonSender.getResult();

                    /* Receiving side */
                    myAnonReceiver.acceptAgreement(myReceivingPair, myMessage);
                    GordianSymCipherSpec myResultSpec = (GordianSymCipherSpec) myAnonReceiver.getResultType();
                    GordianKey&lt;GordianSymKeySpec&gt; myKey = (GordianKey&lt;GordianSymKeySpec&gt;) myAnonReceiver.getResult();

                    /*
                     * Create basic agreement
                     */
                    myAgreeSpec = GordianAgreementSpec.dhBasic(GordianKDFType.SHA256KDF);
                    GordianBasicAgreement myBasicSender = (GordianBasicAgreement) myAgreementFactory.createAgreement(myAgreeSpec);
                    myBasicSender.setResultType(myCipherSpec);
                    GordianBasicAgreement myBasicReceiver = (GordianBasicAgreement) myAgreementFactory.createAgreement(myAgreeSpec);

                    /* Sender side */
                    myMessage = myBasicSender.initiateAgreement(mySendingPair, myReceivingPair);
                    GordianKey&lt;GordianSymKeySpec&gt; myKey = (GordianKey&lt;GordianSymKeySpec&gt;) myBasicSender.getResult();

                    /* Receiving side */
                    myBasicReceiver.acceptAgreement(mySendingPair, myReceivingPair, myMessage);
                    myResultSpec = (GordianSymCipherSpec) myBasicReceiver.getResultType();
                    GordianKey&lt;GordianSymKeySpec&gt; myKey = (GordianKey&lt;GordianSymKeySpec&gt;) myBasicReceiver.getResult();

                    /*
                     * Create ephemeral agreement
                     */
                    myAgreeSpec = GordianAgreementSpec.dhUnified(GordianKDFType.SHA256KDF);
                    GordianEphemeralAgreement myBasicSender = (GordianEphemeralAgreement) myAgreementFactory.createAgreement(myAgreeSpec);
                    myEphemeralSender.setResultType(myCipherSpec);
                    GordianEphemeralAgreement myBasicReceiver = (GordianEphemeralAgreement) myAgreementFactory.createAgreement(myAgreeSpec);

                    /* Sender side */
                    myMessage = myEphemeralSender.initiateAgreement(mySendingPair);

                    /* Receiving side */
                    byte[] myResponse = myEphemeralReceiver.acceptAgreement(mySendingPair, myReceivingPair, myMessage);
                    myResultSpec = (GordianSymCipherSpec) myBasicReceiver.getResultType();
                    GordianKey&lt;GordianSymKeySpec&gt; myKey = (GordianKey&lt;GordianSymKeySpec&gt;) myEphemeralReceiver.getResult();

                    /* Sender side */
                    myEphemeralSender.confirmAgreement(myReceivingPair, myResponse);
                    GordianKey&lt;GordianSymKeySpec&gt; myKey = (GordianKey&lt;GordianSymKeySpec&gt;) myEphemeralSender.getResult();
                </source>
            </subsection>
            <subsection name="Algorithms">
                <p>The following agreement algorithms are supported.</p>
                <table class="defTable">
                    <tr><td class="defHdr">Algorithm</td><td class="defHdr">Variants</td></tr>
                    <tr><td>RSA</td><td>RSA-KEM</td></tr>
                    <tr><td>DH</td><td>Anonymous, Basic, MQV, Unified</td></tr>
                    <tr><td>EC</td><td>ECIES, Anonymous, Basic, MQV, Unified</td></tr>
                    <tr><td>GOST2012</td><td>ECIES, Anonymous, Basic, MQV, Unified</td></tr>
                    <tr><td>DSTU4145</td><td>ECIES, Anonymous, Basic, MQV, Unified</td></tr>
                    <tr><td>SM2</td><td>ECIES, Anonymous, Basic, MQV, Unified, SM2</td></tr>
                    <tr><td>XDH</td><td>Anonymous, Basic, Unified</td></tr>
                    <tr><td>NewHope</td><td>Anonymous</td></tr>
                </table>
            </subsection>
        </section>
        <section name="Encryptors">
            <p>Algorithms are represented by <b>GordianEncryptorSpec</b>. A <b>GordianEncryptor</b> is obtained via the encryptorSpec,
                and then messages are encrypted/decrypted by the encryptor.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianAsymFactory myKeyPairFactory = myBase.getAsymmetricFactory();
                    final GordianEncryptorFactory myEncryptorFactory = myKeyPairFactory.getEncryptorFactory();

                    /* Access keyPairGenerator */
                    final GordianAsymKeySpec mySpec = GordianAsymKeySpec.rsa(GordianRSAModulus.MOD2048);
                    final GordianKeyPairGenerator myGenerator = myKeyPairFactory.getKeyPairGenerator(mySpec);
                    final GordianKeyPair myPair = myGenerator.generateKeyPair();

                    /* Access encryptor */
                    final GordianEncryptorSpec myEncryptSpec = GordianEncryptorSpec.rsa(GordianDigestSpec.sha2(GordianLength.LEN_256));
                    final GordianEncryptor myEncryptor = myEncryptorFactory.createEncryptor(myEncryptSpec);

                    /* Encrypt message */
                    final byte[] message = ....;
                    myEncryptor.initForEncrypt(myPair);
                    final byte[] myEncrypted = myEncryptor.encrypt(myMessage);

                    /* Decrypt message */
                    myEncryptor.initForDecrypt(myPair);
                    final byte[] myResult = myEncryptor.decrypt(myEncrypted);
                </source>
            </subsection>
            <subsection name="Algorithms">
                <p>The following encryptor algorithms are supported</p>
                <table class="defTable">
                    <tr><td class="defHdr">Algorithm</td><td class="defHdr">Variants</td></tr>
                    <tr><td>RSA</td><td/></tr>
                    <tr><td>EC</td><td/></tr>
                    <tr><td>SM2</td><td/></tr>
                    <tr><td>McEliece</td><td>Standard, KobaraImai, Fujisaki, Pointcheval, </td></tr>
                </table>
            </subsection>
        </section>
    </body>
</document>

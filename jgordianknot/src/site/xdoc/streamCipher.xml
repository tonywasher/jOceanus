<document>
    <properties>
        <title>GordianKnot Symmetric Stream Ciphers</title>
        <author email="Tony.Washer@yahoo.co.uk">Tony Washer</author>
    </properties>
    <body>
        <section name="Overview">
            <p>Stream Ciphers are supported via the <strong>GordianCipherFactory</strong> interface.</p>
            <p>GordianKnot supports most Symmetric Stream Ciphers available from BouncyCastle plus some additional ciphers.</p>
            <p>A key for stream encryption is created by specifying the algorithm and keySize as a <strong>GordianStreamKeySpec</strong>.</p>
            <p>A cipher for stream encryption is created by specifying the <strong>GordianStreamKeySpec</strong> (plus variant details eg AEAD)
                as a <strong>GordianStreamCipherSpec</strong> and can be used similarly to a blockCipher.</p>
            <p>A keyGenerator for a <strong>GordianStreamKeySpec</strong> can be created, which can be used to generate random keys for the keySpec</p>
            <p>JCA provides a subset of available algorithms as indicated</p>
        </section>
        <section name="Key Generation">
            <p>Algorithms are represented by <strong>GordianSymKeySpec</strong>. A <strong>GordianKeyGenerator</strong> is obtained via the keySpec,
                and then keys are generated by the generator.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                    /* Access keyGenerator */
                    final GordianStreamKeySpec mySpec = GordianStreamKeySpec.hc(GordianLength.LEN_256);
                    final GordianKeyGenerator&lt;GordianStreamKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(mySpec);
                    final GordianKey&lt;GordianStreamKeySpec&gt; myKey = myGenerator.generateKey();
                </source>
            </subsection>
            <subsection name="Algorithms">
                <p>The following streamKey algorithms are supported.</p>
                <table class="defTable">
                    <tr><td class="defHdr">Algorithm</td><td class="defHdr">Variant</td><td class="defHdr">JCA</td><td class="defHdr">128</td><td class="defHdr">192</td>
                        <td class="defHdr">256</td><td class="defHdr">512</td><td class="defHdr">1024</td><td class="defHdr">Notes</td></tr>
                    <tr><td rowspan="3">ChaCha20</td><td>Standard</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/><td/></tr>
                    <tr><td>ChaCha7359</td><td>Y</td><td/><td/><td>Y</td><td/><td/><td/></tr>
                    <tr><td>XChaCha20</td><td/><td/><td/><td>Y</td><td/><td/><td/></tr>
                    <tr><td rowspan="2">Salsa20</td><td>Standard</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/><td/></tr>
                    <tr><td>XSalsa20</td><td>Y</td><td/><td/><td>Y</td><td/><td/><td/></tr>
                    <tr><td>HC</td><td/><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/><td>HC128/HC256 as appropriate</td></tr>
                    <tr><td>VMPC</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                    <tr><td>ISAAC</td><td/><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                    <tr><td>RC4</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                    <tr><td>Grain128</td><td/><td>Y</td><td>Y</td><td/><td/><td/><td/><td/></tr>
                    <tr><td>Rabbit</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
                    <tr><td>Sosemanuk</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
                    <tr><td>Snow3G</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
                    <tr><td>Zuc</td><td/><td/><td>Y</td><td/><td>Y</td><td/><td/><td>Zuc-128/Zuc-256 as appropriate</td></tr>
                    <tr><td rowspan="3">SkeinXof</td><td>Skein-256</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                    <tr><td>Skein-512</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                    <tr><td>Skein-1024</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                    <tr><td rowspan="2">Blake2X</td><td>Blake2Xs</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/><td/></tr>
                    <tr><td>Blake2Xb</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td rowspan="2">KMACXof</td><td>KMAC128</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                    <tr><td>KMAC256</td><td/><td/><td/><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                </table>
            </subsection>
        </section>
        <section name="Cipher Usage">
            <p>Cipher Algorithms are represented by <strong>GordianStreamCipherSpec</strong>. A <strong>GordianStreamCipher</strong> is obtained via the cipherSpec,
                and then messages are encrypted/decrypted by the cipher.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                    /* Create key */
                    final GordianStreamKeySpec myKeySpec = GordianStreamKeySpec.hc(GordianLength.LEN_256);
                    final GordianKeyGenerator&lt;GordianStreamKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(myKeySpec);
                    final GordianKey&lt;GordianStreamKeySpec&gt; myKey = myGenerator.generateKey();

                    /* Create cipher */
                    final GordianStreamCipherSpec myCipherSpec = GordianStreamCipherSpec.stream(myKeySpec);
                    final GordianStreamCipher myCipher = myCipherFactory.createStreamKeyCipher(myCipherSpec);

                    /* Encrypt message with random nonce */
                    GordianCipherParameters myParams = GordianCipherParameters.keyWithRandomNonce(myKey);
                    myCipher.initForEncrypt(myParams);
                    final byte[] myMessage = ...
                    int myOutLen = myCipher.getOutputLength(myMessage.length);
                    final byte[] myEncrypted = new byte[myOutLen];
                    int myProcessed = myCipher.update(myMessage, 0, myMessage.length, myEncrypted);
                    myCipher.finish(myEncrypted, myProcessed);

                    /* Decrypt message */
                    myParams = GordianCipherParameters.keyWithNonce(myKey, myCipher.getNonce());
                    myCipher.initForDecrypt(myParams);
                    myOutLen = myCipher.getOutputLength(myEncrypted.length);
                    final byte[] myResult = new byte[myOutLen];
                    myProcessed = myCipher.update(myEncrypted, 0, myEncrypted.length, myResult);
                    myCipher.finish(myResult, myProcessed);
                </source>
            </subsection>
        </section>
    </body>
</document>

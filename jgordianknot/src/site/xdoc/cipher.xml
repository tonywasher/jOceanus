<document>
    <properties>
        <title>GordianKnot Symmetric Ciphers</title>
        <author email="Tony.Washer@yahoo.co.uk">Tony Washer</author>
    </properties>
    <body>
        <section name="Overview">
            <p>GordianKnot supports most Symmetric Block and Stream Ciphers available from BouncyCastle plus some additional ciphers.</p>
            <p>A cipher for block encryption/decryption is created by specifying a cipherSpec which comprises the symKeySpec (algorithm/blockSize/keySize)
                with the cipherMode and padding (if required). The cipher can be used in much the same way as a JCA Cipher,
                allowing init, update and finalise methods.</p>
            <p>A cipher for stream encryption is created by specifying the algorithm and keySize. The cipher can be used similarly to a blockCipher.</p>
            <p>A cipher for blockCipher keyWrapping is created by specifying the symKeySpec. The cipher allows init, secure and derive methods</p>
            <p>A keyGenerator for a symKeySpec can be created, which can be used to generate random keys for the keySpec</p>
            <p>JCA provides a subset of available algorithms as indicated</p>
        </section>
        <section name="Block Ciphers">
            <subsection name="Key Generation">
                <p>Algorithms are represented by <strong>GordianSymKeySpec</strong>. A <strong>GordianKeyGenerator</strong> is obtained via the keySpec,
                    and then keys are generated by the generator.</p>
                <h4 name="Sample">
                    <source>
                        /* Access factory */
                        final GordianParameters myParams = new GordianParameters();
                        final GordianFactory myBaseFactory = GordianGenerator.createFactory(myParams);
                        final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                        /* Access keyGenerator */
                        final GordianSymKeySpec mySpec = GordianSymKeySpec.aes(GordianLength.LEN_256);
                        final GordianKeyGenerator&lt;GordianSymKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(mySpec);
                        final GordianKey&lt;GordianSymKeySpec&gt; myKey = myGenerator.generateKey();
                    </source>
                </h4>
                <h4 name="Algorithms">
                    <p>The following symKey algorithms are supported.</p>
                    <table class="defTable">
                        <tr><td class="defHdr">Algorithm</td><td class="defHdr">BlockSize</td><td class="defHdr">JCA</td>
                            <td class="defHdr">128</td><td class="defHdr">192</td><td class="defHdr">256</td><td class="defHdr">512</td><td class="defHdr">1024</td></tr>
                        <tr><td>AES</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td>Serpent</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td>TwoFish</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td>Camellia</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td>CAST6</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td>RC6</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td>ARIA</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td rowspan="2">Kalyna</td><td>128</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/></tr>
                        <tr><td>256</td><td>Y</td><td/><td/><td>Y</td><td>Y</td><td/></tr><td/>
                        <tr><td>Kuznyechik</td><td>128</td><td>Y</td><td/><td/><td>Y</td><td/><td/></tr>
                        <tr><td>ThreeFish</td><td>256</td><td>Y</td><td/><td/><td>Y</td><td>Y</td><td>Y</td></tr>
                        <tr><td>NoeKeon</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>SM4</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>SEED</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>SKIPJACK</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>BlowFish</td><td>64</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td>RC2</td><td>64</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
                        <tr><td>DESede</td><td>64</td><td>Y</td><td>Y</td><td>Y</td><td/><td/><td/></tr>
                        <tr><td>CAST5</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td rowspan="2">RC5</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/><td/></tr>
                        <tr><td>128</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>IDEA</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>TEA</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>XTEA</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>Magma</td><td>64</td><td>Y</td><td/><td/><td>Y</td><td/><td/></tr>
                        <tr><td>SHACAL2</td><td>256</td><td>Y</td><td/><td/><td>Y</td><td>Y</td><td/></tr>
                        <tr><td rowspan="2">Speck</td><td>64</td><td/><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td rowspan="2">Simon</td><td>64</td><td/><td>Y</td><td/><td/><td/><td/></tr>
                        <tr><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td>MARS</td><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td>Anubis</td><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    </table>
                </h4>
            </subsection>
            <subsection name="Cipher Usage">
                <p>Cipher Algorithms are represented by <strong>GordianSymCipherSpec</strong>. A <strong>GordianSymCipher</strong> is obtained via the cipherSpec,
                    and then messages are encrypted/decrypted by the cipher.</p>
                <h4 name="Sample">
                    <source>
                        /* Access factory */
                        final GordianParameters myParams = new GordianParameters();
                        final GordianFactory myBaseFactory = GordianGenerator.createFactory(myParams);
                        final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                        /* Create key */
                        final GordianSymKeySpec myKeySpec = GordianSymKeySpec.aes(GordianLength.LEN_256);
                        final GordianKeyGenerator&lt;GordianSymKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(myKeySpec);
                        final GordianKey&lt;GordianSymKeySpec&gt; myKey = myGenerator.generateKey();

                        /* Create cipher */
                        final GordianSymCipherSpec myCipherSpec = GordianSymCipherSpec.cbc(myKeySpec, GordianPadding.PKCS7);
                        final GordianSymCipher myCipher = myCipherFactory.createSymKeyCipher(myCipherSpec);

                        /* Encrypt message with random nonce */
                        GordianCipherParameters myParams = GordianCipherParameters.keyWithRandomNonce(myKey);
                        myCipher.init(true, myParams);
                        final byte[] myMessage = ...
                        int myOutLen = myCipher.getOutputLength(myMessage.length);
                        final byte[] myEncrypted = new byte[myOutLen];
                        int myProcessed = myCipher.update(myMessage, 0, myMessage.length, myEncrypted);
                        myCipher.finish(myEncrypted, myProcessed);

                        /* Decrypt message */
                        myParams = GordianCipherParameters.keyWithNonce(myKey, myCipher.getNonce());
                        myCipher.init(false, myParams);
                        myOutLen = myCipher.getOutputLength(myEncrypted.length);
                        final byte[] myResult = new byte[myOutLen];
                        myProcessed = myCipher.update(myEncrypted, 0, myEncrypted.length, myResult);
                        myCipher.finish(myResult, myProcessed);
                    </source>
                </h4>
                <h4 name="Cipher Modes">
                    <p>The following modes can be used</p>
                    <table class="defTable">
                        <tr><td class="defHdr">Mode</td><td class="defHdr">JCA</td><td class="defHdr">Notes</td></tr>
                        <tr><td>ECB</td><td>Y</td><td/></tr>
                        <tr><td>CBC</td><td>Y</td><td>JCA does not support for Kuznyechik</td></tr>
                        <tr><td>K3413CBC</td><td/><td>Only available for Kuznyechik</td></tr>
                        <tr><td>SIC</td><td>Y</td><td>Jca does not support for Kalyna and Kuznyechik</td></tr>
                        <tr><td>KCTR</td><td/><td>Only available for Kalyna</td></tr>
                        <tr><td>K3413CTR</td><td/><td>Only available for Kuznyechik</td></tr>
                        <tr><td>OFB</td><td>Y</td><td>Jca does not support for Magma and Kuznyechik</td></tr>
                        <tr><td>GOFB</td><td/><td>Only available for Magma</td></tr>
                        <tr><td>K3413OFB</td><td/><td>Only available for Kuznyechik</td></tr>
                        <tr><td>CFB</td><td>Y</td><td>Jca does not support for Magma and Kuznyechik</td></tr>
                        <tr><td>GCFB</td><td/><td>Only available for Magma</td></tr>
                        <tr><td>K3413CFB</td><td/><td>Only available for Kuznyechik</td></tr>
                        <tr><td>CCM</td><td>Y</td><td>Jca does not support for Kalyna</td></tr>
                        <tr><td>KCCM</td><td/><td>Only available for Kalyna</td></tr>
                        <tr><td>GCM</td><td>Y</td><td>Jca does not support for Kalyna</td></tr>
                        <tr><td>KGCM</td><td/><td>Only available for Kalyna</td></tr>
                        <tr><td>EAX</td><td>Y</td><td/></tr>
                        <tr><td>OCB</td><td>Y</td><td/></tr>
                    </table>
                </h4>
                <h4 name="Padding">
                    <p>The following paddings can be used for ECB and CBC modes</p>
                    <table class="defTable">
                        <tr><td class="defHdr">Padding</td><td class="defHdr">JCA</td><td class="defHdr">Notes</td></tr>
                        <tr><td>CTS</td><td>Y</td><td/></tr>
                        <tr><td>ISO7816-4</td><td>Y</td><td/></tr>
                        <tr><td>PKCS7</td><td>Y</td><td/></tr>
                        <tr><td>X9.63</td><td>Y</td><td/></tr>
                        <tr><td>TBC</td><td>Y</td><td/></tr>
                        <tr><td>NONE</td><td>Y</td><td>Implicitly used for modes other than ECB/CBC</td></tr>
                    </table>
                </h4>
            </subsection>
            <subsection name="Key Wrapping">
                <p>Key Wrapping is performed by GordianKnot using a variant of the AES Key Wrapping algorithm specified in <a href="https://tools.ietf.org/html/rfc5649">RFC 5649</a></p>
                <p>The differences are necessary to enable support of ciphers that do not have the standard blockSize of 128 bits, since RFC 5649 assumes a 128 bit blockSize.</p>
                <ol>
                    <li>For blockSizes of 256 bits, the 32-bit Integrity Vector of <strong>0xA65959A6</strong> is expanded to the 96-bit <strong>0xA65959A6A65959A6A65959A6</strong>
                        so that when combined with the 32-bit dataLen of the wrapped data it comprises the half-block needed for the wrapping algorithm.
                        This method can be extended to support any block size &gt;= 128.</li>
                    <li>For blockSizes of 64, the Integrity Vector using the above adjustment becomes zero length, which is not very useful. In this case, we retain the
                        standard 32-bit	Integrity Vector of <strong>0xA65959A6</strong> and prefix the 32-bit dataLen to the data to be wrapped.</li>
                </ol>
                <p>In addition, a block of random data is inserted immediately prior to the data to be wrapped.</p>
                <h4 name="Sample">
                    <source>
                        /* Access factory */
                        final GordianParameters myParams = new GordianParameters();
                        final GordianFactory myBaseFactory = GordianGenerator.createFactory(myParams);
                        final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                        /* Create keys */
                        final GordianSymKeySpec myKeySpec = GordianSymKeySpec.aes(GordianLength.LEN_256);
                        final GordianKeyGenerator&lt;GordianSymKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(myKeySpec);
                        final GordianKey&lt;GordianSymKeySpec&gt; myKey = myGenerator.generateKey();
                        final GordianKey&lt;GordianSymKeySpec&gt; myKeyToWrap = myGenerator.generateKey();

                        /* Create keyWrapper */
                        final GordianKeyWrapper myWrapper = myCipherFactory.createSymKeyCipher(myKeySpec);

                        /* Secure key */
                        final byte[] myWrapped = myWrapper.secureKey(myKey, myKeyToWrap);

                        /* Derive Key */
                        final GordianKey&lt;GordianSymKeySpec&gt; myResult = myWrapper.deriveKey(myKey, myWrapped, myKeySpec);
                    </source>
                </h4>
            </subsection>
        </section>
        <section name="Stream Ciphers">
            <subsection name="Key Generation">
                <p>Algorithms are represented by <strong>GordianSymKeySpec</strong>. A <strong>GordianKeyGenerator</strong> is obtained via the keySpec,
                    and then keys are generated by the generator.</p>
                <h4 name="Sample">
                    <source>
                        /* Access factory */
                        final GordianParameters myParams = new GordianParameters();
                        final GordianFactory myBaseFactory = GordianGenerator.createFactory(myParams);
                        final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                        /* Access keyGenerator */
                        final GordianStreamKeySpec mySpec = GordianStreamKeySpec.hc(GordianLength.LEN_256);
                        final GordianKeyGenerator&lt;GordianStreamKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(mySpec);
                        final GordianKey&lt;GordianStreamKeySpec&gt; myKey = myGenerator.generateKey();
                    </source>
                </h4>
                <h4 name="Algorithms">
                    <p>The following streamKey algorithms are supported.</p>
                    <table class="defTable">
                        <tr><td class="defHdr">Algorithm</td><td class="defHdr">Variant</td><td class="defHdr">JCA</td><td class="defHdr">128</td><td class="defHdr">192</td>
                            <td class="defHdr">256</td><td class="defHdr">512</td><td class="defHdr">1024</td><td class="defHdr">Notes</td></tr>
                        <tr><td rowspan="3">ChaCha20</td><td>Standard</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/><td/></tr>
                        <tr><td>ChaCha7359</td><td>Y</td><td/><td/><td>Y</td><td/><td/><td/></tr>
                        <tr><td>XChaCha20</td><td/><td/><td/><td>Y</td><td/><td/><td/></tr>
                        <tr><td rowspan="2">Salsa20</td><td>Standard</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/><td/></tr>
                        <tr><td>XSalsa20</td><td>Y</td><td/><td/><td>Y</td><td/><td/><td/></tr>
                        <tr><td>HC</td><td/><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/><td>HC128/HC256 as appropriate</td></tr>
                        <tr><td>VMPC</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                        <tr><td>ISAAC</td><td/><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                        <tr><td>RC4</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                        <tr><td>Grain128</td><td/><td>Y</td><td>Y</td><td/><td/><td/><td/><td/></tr>
                        <tr><td>Rabbit</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
                        <tr><td>Sosemanuk</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
                        <tr><td>Snow3G</td><td/><td/><td>Y</td><td/><td/><td/><td/><td/></tr>
                        <tr><td>Zuc</td><td/><td/><td>Y</td><td/><td>Y</td><td/><td/><td>Zuc-128/Zuc-256 as appropriate</td></tr>
                        <tr><td rowspan="3">SkeinXof</td><td>Skein-256</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                        <tr><td>Skein-512</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                        <tr><td>Skein-1024</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                        <tr><td rowspan="2">Blake2X</td><td>Blake2Xs</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/><td/></tr>
                        <tr><td>Blake2Xb</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                        <tr><td rowspan="2">KMACXof</td><td>KMAC128</td><td/><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                        <tr><td>KMAC256</td><td/><td/><td/><td>Y</td><td>Y</td><td>Y</td><td/></tr>
                    </table>
                </h4>
            </subsection>
            <subsection name="Cipher Usage">
                <p>Cipher Algorithms are represented by <strong>GordianStreamCipherSpec</strong>. A <strong>GordianStreamCipher</strong> is obtained via the cipherSpec,
                    and then messages are encrypted/decrypted by the cipher.</p>
                <h4 name="Sample">
                    <source>
                        /* Access factory */
                        final GordianParameters myParams = new GordianParameters();
                        final GordianFactory myBaseFactory = GordianGenerator.createFactory(myParams);
                        final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                        /* Create key */
                        final GordianStreamKeySpec myKeySpec = GordianStreamKeySpec.hc(GordianLength.LEN_256);
                        final GordianKeyGenerator&lt;GordianStreamKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(myKeySpec);
                        final GordianKey&lt;GordianStreamKeySpec&gt; myKey = myGenerator.generateKey();

                        /* Create cipher */
                        final GordianStreamCipherSpec myCipherSpec = GordianStreamCipherSpec.stream(myKeySpec);
                        final GordianStreamCipher myCipher = myCipherFactory.createStreamKeyCipher(myCipherSpec);

                        /* Encrypt message with random nonce */
                        GordianCipherParameters myParams = GordianCipherParameters.keyWithRandomNonce(myKey);
                        myCipher.init(true, myParams);
                        final byte[] myMessage = ...
                        int myOutLen = myCipher.getOutputLength(myMessage.length);
                        final byte[] myEncrypted = new byte[myOutLen];
                        int myProcessed = myCipher.update(myMessage, 0, myMessage.length, myEncrypted);
                        myCipher.finish(myEncrypted, myProcessed);

                        /* Decrypt message */
                        myParams = GordianCipherParameters.keyWithNonce(myKey, myCipher.getNonce());
                        myCipher.init(false, myParams);
                        myOutLen = myCipher.getOutputLength(myEncrypted.length);
                        final byte[] myResult = new byte[myOutLen];
                        myProcessed = myCipher.update(myEncrypted, 0, myEncrypted.length, myResult);
                        myCipher.finish(myResult, myProcessed);
                    </source>
                </h4>
            </subsection>
        </section>
        <section name="Password-based Encryption">
            <p>Password-based encryption is available for both Block and Stream Ciphers. To use PBE, the parameters for the init call are modified to provide
                a <strong>GordianPBESpec</strong> rather than a key</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianParameters myParams = new GordianParameters();
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory(myParams);
                    final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                    /* Create cipher */
                    final GordianSymKeySpec myKeySpec = GordianSymKeySpec.aes(GordianLength.LEN_256);
                    final GordianSymCipherSpec myCipherSpec = GordianSymSpec.cbc(myKeySpec, GordianPadding.PKCS7);
                    final GordianSymCipher myCipher = myCipherFactory.createSymKeyCipher(myCipherSpec);

                    /* Create pbeSpec */
                    final GordianPBESpec myPBESpec = GordianPBESpec.pbKDF2(GordianDigestSpec.sha2(GordianLength.LEN_256), 2000);
                    final byte[] myPassword = ....

                    /* Encrypt message with random nonce */
                    GordianCipherParameters myParams = GordianCipherParameters.pbe(myPBESpec, myPassword);
                    myCipher.init(true, myParams);
                    final byte[] myMessage = ...
                    int myOutLen = myCipher.getOutputLength(myMessage.length);
                    final byte[] myEncrypted = new byte[myOutLen];
                    int myProcessed = myCipher.update(myMessage, 0, myMessage.length, myEncrypted);
                    myCipher.finish(myEncrypted, myProcessed);

                    /* Decrypt message */
                    myParams = GordianCipherParameters.pbeAndNonce(myPBESpec, myCipher.getPBESalt());
                    myCipher.init(false, myParams);
                    myOutLen = myCipher.getOutputLength(myEncrypted.length);
                    final byte[] myResult = new byte[myOutLen];
                    myProcessed = myCipher.update(myEncrypted, 0, myEncrypted.length, myResult);
                    myCipher.finish(myResult, myProcessed);
                </source>
            </subsection>
            <subsection name="Algorithms">
                <p>The following pbe algorithms are supported.</p>
                <table class="defTable">
                    <tr><td class="defHdr">Algorithm</td></tr>
                    <tr><td>pbKDF2</td></tr>
                    <tr><td>pkcs12</td></tr>
                    <tr><td>scrypt</td></tr>
                    <tr><td>argon2</td></tr>
                </table>
            </subsection>
        </section>
    </body>
</document>

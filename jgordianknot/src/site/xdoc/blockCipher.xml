<document>
    <properties>
        <title>GordianKnot Symmetric Block Ciphers</title>
        <author email="Tony.Washer@yahoo.co.uk">Tony Washer</author>
    </properties>
    <body>
        <section name="Overview">
            <p>Block Ciphers are supported via the <strong>GordianCipherFactory</strong> interface.</p>
            <p>GordianKnot supports most Symmetric Block Ciphers available from BouncyCastle plus some additional ciphers.</p>
            <p>A cipher for block encryption/decryption is created by specifying a <strong>GordianSymCipherSpec</strong> which comprises
                the <strong>GordianSymKeySpec</strong> (algorithm/blockSize/keySize) with the cipherMode and padding (if required).
                The cipher can be used in much the same way as a JCA Cipher, allowing init, update and finalise methods.</p>
            <p>A cipher for blockCipher keyWrapping is created by specifying the symKey. The cipher allows init, secure and derive methods</p>
            <p>A keyGenerator for a <strong>GordianSymKeySpec</strong> can be created, which can be used to generate random keys for the keySpec</p>
            <p>JCA provides a subset of available algorithms as indicated</p>
        </section>
        <section name="Key Generation">
            <p>Algorithms are represented by <strong>GordianSymKeySpec</strong>. A <strong>GordianKeyGenerator</strong> is obtained via the keySpec,
                and then keys are generated by the generator.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                    /* Access keyGenerator */
                    final GordianSymKeySpec mySpec = GordianSymKeySpec.aes(GordianLength.LEN_256);
                    final GordianKeyGenerator&lt;GordianSymKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(mySpec);
                    final GordianKey&lt;GordianSymKeySpec&gt; myKey = myGenerator.generateKey();
                </source>
            </subsection>
            <subsection name="Algorithms">
                <p>The following symKey algorithms are supported.</p>
                <table class="defTable">
                    <tr><th class="defHdr">Algorithm</th><th class="defHdr">BlockSize</th><th class="defHdr">JCA</th>
                        <th class="defHdr">128</th><th class="defHdr">192</th><th class="defHdr">256</th><th class="defHdr">512</th><th class="defHdr">1024</th></tr>
                    <tr><td>AES</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td>Serpent</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td>TwoFish</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td>Camellia</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td>CAST6</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td>RC6</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td>ARIA</td><td>128</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td rowspan="2">Kalyna</td><td>128</td><td>Y</td><td>Y</td><td/><td>Y</td><td/><td/></tr>
                    <tr><td>256</td><td>Y</td><td/><td/><td>Y</td><td>Y</td><td/></tr><td/>
                    <tr><td>Kuznyechik</td><td>128</td><td>Y</td><td/><td/><td>Y</td><td/><td/></tr>
                    <tr><td>ThreeFish</td><td>256</td><td>Y</td><td/><td/><td>Y</td><td>Y</td><td>Y</td></tr>
                    <tr><td>NoeKeon</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td>SM4</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td>SEED</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td>SKIPJACK</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td>BlowFish</td><td>64</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td>RC2</td><td>64</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
                    <tr><td>DESede</td><td>64</td><td>Y</td><td>Y</td><td>Y</td><td/><td/><td/></tr>
                    <tr><td>CAST5</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td rowspan="2">RC5</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/><td/></tr>
                    <tr><td>128</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td>IDEA</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td>TEA</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td>XTEA</td><td>64</td><td>Y</td><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td>Magma</td><td>64</td><td>Y</td><td/><td/><td>Y</td><td/><td/></tr>
                    <tr><td>SHACAL2</td><td>256</td><td>Y</td><td/><td/><td>Y</td><td>Y</td><td/></tr>
                    <tr><td rowspan="2">Speck</td><td>64</td><td/><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td rowspan="2">Simon</td><td>64</td><td/><td>Y</td><td/><td/><td/><td/></tr>
                    <tr><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td>MARS</td><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                    <tr><td>Anubis</td><td>128</td><td/><td>Y</td><td>Y</td><td>Y</td><td/><td/></tr>
                </table>
            </subsection>
        </section>
        <section name="Cipher Usage">
            <p>Cipher Algorithms are represented by <strong>GordianSymCipherSpec</strong>. A <strong>GordianSymCipher</strong> is obtained via the cipherSpec,
                and then messages are encrypted/decrypted by the cipher.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                    /* Create key */
                    final GordianSymKeySpec myKeySpec = GordianSymKeySpec.aes(GordianLength.LEN_256);
                    final GordianKeyGenerator&lt;GordianSymKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(myKeySpec);
                    final GordianKey&lt;GordianSymKeySpec&gt; myKey = myGenerator.generateKey();

                    /* Create cipher */
                    final GordianSymCipherSpec myCipherSpec = GordianSymCipherSpec.cbc(myKeySpec, GordianPadding.PKCS7);
                    final GordianSymCipher myCipher = myCipherFactory.createSymKeyCipher(myCipherSpec);

                    /* Encrypt message with random nonce */
                    GordianCipherParameters myParams = GordianCipherParameters.keyWithRandomNonce(myKey);
                    myCipher.initForEncrypt(myParams);
                    final byte[] myMessage = ...
                    int myOutLen = myCipher.getOutputLength(myMessage.length);
                    final byte[] myEncrypted = new byte[myOutLen];
                    int myProcessed = myCipher.update(myMessage, 0, myMessage.length, myEncrypted);
                    myCipher.finish(myEncrypted, myProcessed);

                    /* Decrypt message */
                    myParams = GordianCipherParameters.keyWithNonce(myKey, myCipher.getNonce());
                    myCipher.initForDecrypt(myParams);
                    myOutLen = myCipher.getOutputLength(myEncrypted.length);
                    final byte[] myResult = new byte[myOutLen];
                    myProcessed = myCipher.update(myEncrypted, 0, myEncrypted.length, myResult);
                    myCipher.finish(myResult, myProcessed);
                </source>
            </subsection>
            <subsection name="Cipher Modes">
                <p>The following modes can be used</p>
                <table class="defTable">
                    <tr><th class="defHdr">Mode</th><th class="defHdr">JCA</th><th class="defHdr">Notes</th></tr>
                    <tr><td>ECB</td><td>Y</td><td/></tr>
                    <tr><td>CBC</td><td>Y</td><td>JCA does not support for Kuznyechik</td></tr>
                    <tr><td>G3413CBC</td><td>Y</td><td>Only available for Kuznyechik</td></tr>
                    <tr><td>SIC</td><td>Y</td><td/></tr>
                    <tr><td>KCTR</td><td>Y</td><td>Only available for Kalyna</td></tr>
                    <tr><td>G3413CTR</td><td>Y</td><td>Only available for Kuznyechik</td></tr>
                    <tr><td>OFB</td><td>Y</td><td>Jca does not support for Magma and Kuznyechik</td></tr>
                    <tr><td>GOFB</td><td/><td>Only available for Magma</td></tr>
                    <tr><td>G3413OFB</td><td>Y</td><td>Only available for Kuznyechik</td></tr>
                    <tr><td>CFB</td><td>Y</td><td>Jca does not support for Magma and Kuznyechik</td></tr>
                    <tr><td>GCFB</td><td/><td>Only available for Magma</td></tr>
                    <tr><td>G3413CFB</td><td>Y</td><td>Only available for Kuznyechik</td></tr>
                    <tr><td>CCM</td><td>Y</td><td>Jca does not support for Kalyna</td></tr>
                    <tr><td>KCCM</td><td/><td>Only available for Kalyna</td></tr>
                    <tr><td>GCM</td><td>Y</td><td>Jca does not support for Kalyna</td></tr>
                    <tr><td>KGCM</td><td/><td>Only available for Kalyna</td></tr>
                    <tr><td>EAX</td><td>Y</td><td/></tr>
                    <tr><td>OCB</td><td>Y</td><td>JCA does not support for Kuznyechik or Kalyna</td></tr>
                </table>
            </subsection>
            <subsection name="Padding">
                <p>The following paddings can be used for ECB and CBC modes</p>
                <table class="defTable">
                    <tr><th class="defHdr">Padding</th><th class="defHdr">JCA</th><th class="defHdr">Notes</th></tr>
                    <tr><td>CTS</td><td>Y</td><td/></tr>
                    <tr><td>ISO7816-4</td><td>Y</td><td/></tr>
                    <tr><td>PKCS7</td><td>Y</td><td/></tr>
                    <tr><td>X9.63</td><td>Y</td><td/></tr>
                    <tr><td>TBC</td><td>Y</td><td/></tr>
                    <tr><td>NONE</td><td>Y</td><td>Implicitly used for modes other than ECB/CBC</td></tr>
                </table>
            </subsection>
        </section>
        <section name="Key Wrapping">
            <p>Key Wrapping is performed by GordianKnot using a variant of the AES Key Wrapping algorithm specified in <a href="https://tools.ietf.org/html/rfc5649">RFC 5649</a></p>
            <p>The differences are necessary to enable support of ciphers that do not have the standard blockSize of 128 bits, since RFC 5649 assumes a 128 bit blockSize.</p>
            <ol>
                <li>For blockSizes of 256 bits, the 32-bit Integrity Vector of <strong>0xA65959A6</strong> is expanded to the 96-bit <strong>0xA65959A6A65959A6A65959A6</strong>
                    so that when combined with the 32-bit dataLen of the wrapped data it comprises the half-block needed for the wrapping algorithm.
                    This method can be extended to support any block size &gt;= 128.</li>
                <li>For blockSizes of 64, the Integrity Vector using the above adjustment becomes zero length, which is not very useful. In this case, we retain the
                    standard 32-bit	Integrity Vector of <strong>0xA65959A6</strong> and prefix the 32-bit dataLen to the data to be wrapped.</li>
            </ol>
            <p>In addition, a block of random data is inserted immediately prior to the data to be wrapped.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianCipherFactory myCipherFactory = myBaseFactory.getCipherFactory();

                    /* Create keys */
                    final GordianSymKeySpec myKeySpec = GordianSymKeySpec.aes(GordianLength.LEN_256);
                    final GordianKeyGenerator&lt;GordianSymKeySpec&gt; myGenerator = myCipherFactory.getKeyGenerator(myKeySpec);
                    final GordianKey&lt;GordianSymKeySpec&gt; myKey = myGenerator.generateKey();
                    final GordianKey&lt;GordianSymKeySpec&gt; myKeyToWrap = myGenerator.generateKey();

                    /* Create keyWrapper */
                    final GordianKeyWrapper myWrapper = myCipherFactory.createSymKeyCipher(myKey);

                    /* Secure key */
                    final byte[] myWrapped = myWrapper.secureKey(myKeyToWrap);

                    /* Derive Key */
                    final GordianKey&lt;GordianSymKeySpec&gt; myResult = myWrapper.deriveKey(myWrapped, myKeySpec);
                </source>
            </subsection>
        </section>
    </body>
</document>

<document>
    <properties>
        <title>GordianKnot KeySets</title>
        <author email="Tony.Washer@yahoo.co.uk">Tony Washer</author>
    </properties>
    <body>
        <section name="Overview">
            <p>KeySets are supported via the <strong>GordianKeySetFactory</strong> interface.</p>
            <p>GordianKnot supports the notion of a KeySet, which is a set of keys of each available algorithm with a 128-bit blockSize.
            The keySet may be used to encrypt/decrypt and to secure/derive keys or keySets</p>
        </section>
        <section name="KeySet Generation">
            <p>A keySet can be generated by specifying a <strong>GordianKeySetSpec</strong>.</p>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

                    /* Create keySet */
                    final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
                    final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);
                </source>
            </subsection>
        </section>
        <section name="KeySet Encryption">
            <subsection name="Algorithm">
                <p>Encryption works by selecting a subSet of the available keys and encrypting the message using each key in turn. The number of keys selected and
                    hence the number of encryption steps is specified in the <strong>GordianKeySetSpec</strong> and can vary betweeen 3 and 6</p>
                <ol>
                    <li>A random 32-bit seed <strong>S</strong> and a random 128-bit initVector <strong>V</strong> are generated.</li>
                    <li>A subSet of keys is selected (all different) in a deterministic fashion using the seed <strong>S</strong> xor-ed with the personalisation value
                        <strong>I<sub>4</sub></strong></li>
                    <li>Two initiation vectors <strong>V<sub>1</sub></strong> and <strong>V<sub>2</sub></strong> are calculated by xor-ing <strong>V</strong> with
                        <strong>IV<sub>1</sub></strong> and <strong>IV<sub>2</sub></strong> respectively</li>
                    <li>The first encryption is performed on the message <strong>M</strong> using <strong>K<sub>1</sub></strong> in <strong>SIC</strong> mode
                        using <strong>V<sub>1</sub></strong> as the initialisation vector to create <strong>C<sub>1</sub></strong></li>
                    <li>The second encryption is performed on <strong>C<sub>1</sub></strong> using <strong>K<sub>2</sub></strong> in
                        <strong>ECB</strong> mode with <strong>ISO7816D4</strong> padding to create <strong>C<sub>2</sub></strong>.</li>
                    <li>Further intermediate encryptions are performed on <strong>C<sub>x-1</sub></strong> using <strong>K<sub>x</sub></strong>
                        in <strong>ECB</strong> mode with no padding to produce <strong>C<sub>x</sub></strong>.</li>
                    <li>The final encryption is performed on <strong>C<sub>n-1</sub></strong> using <strong>K<sub>n</sub></strong> in <strong>SIC</strong> mode
                        using <strong>V<sub>2</sub></strong> as the initialisation vector to create <strong>C<sub>n</sub></strong></li>
                    <li>The result is the concatenation of <strong>S||V||C<sub>n</sub></strong></li>
                </ol>
            </subsection>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

                    /* Create keySet */
                    final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
                    final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);

                    /* Encrypt data */
                    final byte[] myMessage = ...
                    final byte[] myEncrypted = myKeySet.encryptBytes(myMessage);
                    final byte[] myResult = myKeySet.decryptBytes(myEncrypted);
                </source>
            </subsection>
        </section>
        <section name="KeySet Wrapping">
            <subsection name="Algorithm">
                <p>Wrapping works by selecting a subSet of the available keys and initially encrypting the message with the first key and then wrapping the result
                    using each remaining key in turn.</p>
                <ol>
                    <li>A random 32-bit seed <strong>S</strong> and a random 128-bit initVector <strong>V</strong> are generated.</li>
                    <li>A subSet of keys is selected (all different) in a deterministic fashion using the seed <strong>S</strong> xor-ed with the personalisation value
                        <strong>I<sub>4</sub></strong></li>
                    <li>An initiation vectors <strong>V<sub>1</sub></strong> is calculated by xor-ing <strong>V</strong> with <strong>IV<sub>1</sub></strong></li>
                    <li>The first encryption is performed on the bytes <strong>B</strong> using <strong>K<sub>1</sub></strong> in <strong>SIC</strong>
                        mode using <strong>V<sub>1</sub></strong> as the initialisation vector to create <strong>W<sub>1</sub></strong></li>
                    <li>Further wrapping occurs wrapping <strong>W<sub>x-1</sub></strong> with keys <strong>K<sub>x</sub></strong> to produce <strong>W<sub>x</sub></strong></li>
                    <li>The result is the concatenation of <strong>S||V||W<sub>n</sub></strong></li>
                </ol>
            </subsection>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

                    /* Create keySet */
                    final GordianKeySetSpec mySpec = new GordianKeySetSpec(GordianLength.LEN_256);
                    final GordianKeySet myKeySet = myKeySetFactory.generateKeySet(mySpec);

                    /* Secure key */
                    final GordianKey&lt;GordianSymKeySpec&gt; myKey =  ...
                    final byte[] mySecured = myKeySet.secureKey(myKey);
                    final GordianKey&lt;GordianSymKeySpec&gt; myResult = myKeySet.deriveKey(mySecured, myKeySpec);
                </source>
            </subsection>
        </section>
        <section name="KeySetHash">
            <p>A keySet can also be derived from a password and a hash.</p>
            <subsection name="Creation Algorithm">
                <ol>
                     <li>A random 32-bit seed <strong>S</strong> and a random 128-bit initVector <strong>V</strong> are generated.</li>
                     <li>A set of three hMacs (all different) <strong>H<sub>M</sub></strong>, <strong>H<sub>A</sub></strong> and <strong>H<sub>S</sub></strong> are
                         selected in a deterministic fashion using the seed <strong>S</strong> xor-ed with the personalisation value
                         <strong>I<sub>4</sub></strong>. In addition a 512-bit length digest <strong>X</strong> is selected from the same seed.</li>
                     <li>Each of the hMacs is initialised with the password as the key</li>
                     <li>Each of the macs is updated with <strong>I</strong>, <strong>IV</strong> and the number of iterations <strong>L</strong> </li>
                     <li>Set input <strong>D<sub>M</sub></strong>, <strong>D<sub>A</sub></strong> and <strong>D<sub>S</sub></strong> to <strong>V</strong></li>
                     <li>Repeat the following loop <strong>L</strong> times
                         <ol>
                             <li>Update <strong>H<sub>M</sub></strong> with <strong>D<sub>M</sub></strong></li>
                             <li>Update <strong>H<sub>A</sub></strong> with <strong>D<sub>A</sub></strong></li>
                             <li>Update <strong>H<sub>S</sub></strong> with <strong>D<sub>S</sub></strong>, <strong>D<sub>M</sub></strong> and <strong>D<sub>A</sub></strong></li>
                             <li>Build new <strong>D<sub>M</sub></strong> as the hash of <strong>H<sub>M</sub></strong> and xor the result into <strong>C<sub>M</sub></strong>.
                                Repeat for other hashes.</li>
                         </ol>
                     </li>
                     <li>Update digest <strong>X</strong> with <strong>D<sub>M</sub></strong> and <strong>D<sub>A</sub></strong> and calculate the hash as
                         <strong>R<sub>V</sub></strong></li>
                     <li>Update digest <strong>X</strong> with <strong>C<sub>M</sub></strong> and <strong>C<sub>A</sub></strong> and calculate the hash as
                         <strong>R<sub>X</sub></strong></li>
                     <li>Calculate external hash as the concatenation of <strong>S||V||R<sub>X</sub></strong></li>
                     <li>Create keys for the keySet using <strong>C<sub>S</sub></strong> as the secret and <strong>R<sub>V</sub></strong> as the initVector</li>
                </ol>
            </subsection>
            <subsection name="Derivation Algorithm">
                <ol>
                    <li>Extract <strong>S</strong>, <strong>V</strong> and <strong>R<sub>X</sub></strong> from the hash.</li>
                    <li>Repeat creation algorithm with <strong>S</strong>, <strong>V</strong> and the password</li>
                    <li>Compare the calculated <strong>R<sub>X</sub></strong> with the one extracted from the hash. Only create the keySet if it matches</li>
                 </ol>
            </subsection>
            <subsection name="Sample">
                <source>
                    /* Access factory */
                    final GordianFactory myBaseFactory = GordianGenerator.createFactory();
                    final GordianKeySetFactory myKeySetFactory = myBaseFactory.getKeySetFactory();

                    /* Create the hash and access the resultant keySet */
                    final GordianKeySetSpec mySpec = new GordianKeySetHashSpec(new GordianKeySetSpec(GordianLength.LEN_256));
                    final char[] myPassword = ...
                    final GordianKeySetHash myKeySetHash = myKeySetFactory.generateKeySetHash(mySpec, myPassword);
                    final GordianKeySet myKeySet = myKeySetHash.getKeySet();

                    /* Access hash and derive keySet from hash and password */
                    final byte[] myHash = myKeySetHash.getHash();
                    final GordianKeySetHash myResolved = myKeySetFactory.deriveKeySetHash(myHash, myPassword);
               </source>
            </subsection>
        </section>
    </body>
</document>
